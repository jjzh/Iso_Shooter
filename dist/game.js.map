{
  "version": 3,
  "sources": ["../src/config/arena.ts", "../src/config/terrain.ts", "../src/engine/renderer.ts", "../src/config/player.ts", "../src/config/abilities.ts", "../src/ui/damageNumbers.ts", "../src/engine/aoeTelegraph.ts", "../src/config/enemies.ts", "../src/engine/pools.ts", "../src/entities/projectile.ts", "../src/entities/enemyRig.ts", "../src/engine/events.ts", "../src/engine/tags.ts", "../src/engine/profileManager.ts", "../src/engine/visionCone.ts", "../src/entities/enemy.ts", "../src/entities/mortarProjectile.ts", "../src/entities/playerRig.ts", "../src/entities/playerAnimator.ts", "../src/engine/aerialVerbs.ts", "../src/engine/bulletTime.ts", "../src/verbs/floatSelector.ts", "../src/verbs/dunk.ts", "../src/engine/entityCarrier.ts", "../src/verbs/spike.ts", "../src/config/physics.ts", "../src/effects/launchPillar.ts", "../src/effects/launchIndicator.ts", "../src/entities/player.ts", "../src/engine/input.ts", "../src/config/rooms.ts", "../src/engine/groundShadows.ts", "../src/config/spawn.ts", "../src/engine/meleemath.ts", "../src/engine/physics.ts", "../src/engine/particles.ts", "../src/engine/telegraph.ts", "../src/engine/roomHighlights.ts", "../src/config/door.ts", "../src/engine/door.ts", "../src/entities/physicsObject.ts", "../src/config/bends.ts", "../src/engine/bendSystem.ts", "../src/ui/radialMenu.ts", "../src/engine/bendMode.ts", "../src/engine/pressurePlate.ts", "../src/ui/roomIntro.ts", "../src/engine/roomManager.ts", "../src/config/mobileControls.ts", "../src/ui/hud.ts", "../src/ui/roomSelector.ts", "../src/ui/screens.ts", "../src/engine/audio.ts", "../src/config/boss.ts", "../src/engine/urlParams.ts", "../src/engine/game.ts"],
  "sourcesContent": ["import { Obstacle, Pit, AABB } from '../types/index';\n\nexport let ARENA_HALF_X = 20;\nexport let ARENA_HALF_Z = 20;\n// Legacy alias \u2014 equals ARENA_HALF_X for backward compat (spawn editor export)\nexport let ARENA_HALF = 20;\n\nexport const OBSTACLES: Obstacle[] = [\n  { x: 5, z: 9, w: 2, h: 1.5, d: 3 },\n  { x: -9, z: -7.5, w: 4, h: 1.5, d: 2 },\n  { x: 3.5, z: -3, w: 1.5, h: 2, d: 1.5 },\n  { x: 3.5, z: -9.5, w: 1.5, h: 2, d: 1.5 },\n  { x: 1, z: 10, w: 9, h: 1, d: 1 },\n  { x: 8.5, z: -8, w: 3, h: 1, d: 1 },\n  { x: 10, z: 9, w: 1, h: 2.5, d: 1 },\n  { x: -7.5, z: 8, w: 1, h: 2.5, d: 1 },\n];\n\nexport const WALL_THICKNESS = 0.5;\nexport const WALL_HEIGHT = 2;\n\nexport const PITS: Pit[] = [\n  { x: 0, z: 7.5, w: 8, d: 3 },\n  { x: 16, z: -17, w: 4.5, d: 4.5 },\n  { x: -7.5, z: 0, w: 2.5, d: 8 },\n  { x: -0.5, z: -7, w: 8.5, d: 2.5 },\n  { x: 8, z: 0, w: 3, d: 9 },\n];\n\nexport function setArenaConfig(obstacles: Obstacle[], pits: Pit[], arenaHalfX: number, arenaHalfZ?: number) {\n  OBSTACLES.length = 0;\n  obstacles.forEach(o => OBSTACLES.push(o));\n  PITS.length = 0;\n  pits.forEach(p => PITS.push(p));\n  ARENA_HALF_X = arenaHalfX;\n  ARENA_HALF_Z = arenaHalfZ ?? arenaHalfX;\n  ARENA_HALF = ARENA_HALF_X; // legacy alias\n}\n\nexport function getPitBounds(): AABB[] {\n  return PITS.map(p => ({\n    minX: p.x - p.w / 2,\n    maxX: p.x + p.w / 2,\n    minZ: p.z - p.d / 2,\n    maxZ: p.z + p.d / 2,\n  }));\n}\n\nexport function getCollisionBounds(): AABB[] {\n  const bounds: AABB[] = [];\n\n  for (const o of OBSTACLES) {\n    bounds.push({\n      minX: o.x - o.w / 2,\n      maxX: o.x + o.w / 2,\n      minZ: o.z - o.d / 2,\n      maxZ: o.z + o.d / 2,\n    });\n  }\n\n  const hx = ARENA_HALF_X;\n  const hz = ARENA_HALF_Z;\n  const t = WALL_THICKNESS;\n  // North wall (far end, +Z)\n  bounds.push({ minX: -hx - t/2, maxX: hx + t/2, minZ: hz - t/2, maxZ: hz + t/2 });\n  // South wall (near end, -Z)\n  bounds.push({ minX: -hx - t/2, maxX: hx + t/2, minZ: -hz - t/2, maxZ: -hz + t/2 });\n  // East wall (+X)\n  bounds.push({ minX: hx - t/2, maxX: hx + t/2, minZ: -hz - t/2, maxZ: hz + t/2 });\n  // West wall (-X)\n  bounds.push({ minX: -hx - t/2, maxX: -hx + t/2, minZ: -hz - t/2, maxZ: hz + t/2 });\n\n  return bounds;\n}\n", "// Terrain height zones \u2014 axis-aligned rectangular platforms at specified heights.\n// Used by getGroundHeight(x, z) to determine the ground level at any point.\n// Zones are stacked: if multiple overlap, the highest one wins (entity is \"on top\").\n\nexport interface HeightZone {\n  x: number;       // center X\n  z: number;       // center Z\n  w: number;       // width (X extent)\n  d: number;       // depth (Z extent)\n  y: number;       // top surface height\n  label?: string;  // optional debug label\n}\n\n// Active height zones for current room \u2014 mutated by setArenaConfig / room loading\nexport const HEIGHT_ZONES: HeightZone[] = [];\n\nexport function setHeightZones(zones: HeightZone[]) {\n  HEIGHT_ZONES.length = 0;\n  zones.forEach(z => HEIGHT_ZONES.push(z));\n}\n\n/**\n * Sample ground height at a world (x, z) position.\n * Returns the highest platform surface the point is inside, or 0 (floor) if none.\n */\nexport function getGroundHeight(x: number, z: number): number {\n  let maxY = 0; // base floor is always 0\n  for (const zone of HEIGHT_ZONES) {\n    const halfW = zone.w / 2;\n    const halfD = zone.d / 2;\n    if (\n      x >= zone.x - halfW &&\n      x <= zone.x + halfW &&\n      z >= zone.z - halfD &&\n      z <= zone.z + halfD\n    ) {\n      if (zone.y > maxY) maxY = zone.y;\n    }\n  }\n  return maxY;\n}\n\n/**\n * Check if entity at (x, z, y) is standing on a platform (within epsilon of surface).\n */\nexport function isOnPlatform(x: number, z: number, y: number, epsilon = 0.05): boolean {\n  const groundY = getGroundHeight(x, z);\n  return groundY > 0 && Math.abs(y - groundY) <= epsilon;\n}\n", "import { OBSTACLES, PITS, ARENA_HALF_X, ARENA_HALF_Z, WALL_THICKNESS, WALL_HEIGHT } from '../config/arena';\nimport { HEIGHT_ZONES } from '../config/terrain';\n\nlet scene: any, camera: any, renderer: any;\nconst baseFrustum = 12;\nlet currentFrustum = 12;\nconst cameraOffset = new THREE.Vector3(20, 20, 20);\n\n// Tracked arena meshes for dynamic rebuild\nlet obstacleMeshes: any[] = [];\nlet wallMeshes: any[] = [];\nlet pitMeshes: any[] = [];\nlet _platformMeshes: any[] = [];\n\n// Screen shake state\nlet shakeRemaining = 0;\nlet shakeIntensity = 0;\n\n// Reusable vectors\nconst _camTarget = new THREE.Vector3();\nconst _unprojectVec = new THREE.Vector3();\nconst _camDir = new THREE.Vector3();\n\nexport function initRenderer() {\n  scene = new THREE.Scene();\n  scene.background = new THREE.Color(0x0a0a1a);\n  scene.fog = new THREE.Fog(0x0a0a1a, 30, 60);\n\n  const { w, h } = getViewportSize();\n  const aspect = w / h;\n  camera = new THREE.OrthographicCamera(\n    -baseFrustum * aspect, baseFrustum * aspect,\n    baseFrustum, -baseFrustum, 0.1, 100\n  );\n  camera.position.copy(cameraOffset);\n  camera.lookAt(0, 0, 0);\n\n  // Zoom camera in on mobile for tighter view\n  const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n  if (hasTouch) applyFrustum(6.2);\n\n  renderer = new THREE.WebGLRenderer({ antialias: true });\n  renderer.setSize(w, h);\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n  document.body.prepend(renderer.domElement);\n\n  // Lighting\n  const ambient = new THREE.AmbientLight(0x6666aa, 0.4);\n  scene.add(ambient);\n\n  const dirLight = new THREE.DirectionalLight(0xffeedd, 0.8);\n  dirLight.position.set(10, 15, 10);\n  scene.add(dirLight);\n\n  const rimLight = new THREE.DirectionalLight(0x4488ff, 0.3);\n  rimLight.position.set(-10, 5, -10);\n  scene.add(rimLight);\n\n  // Ground \u2014 sized generously so it covers any room shape\n  const groundSize = 120;\n  const ground = new THREE.Mesh(\n    new THREE.PlaneGeometry(groundSize, groundSize),\n    new THREE.MeshStandardMaterial({ color: 0x1a1a2e, roughness: 0.9, metalness: 0.1 })\n  );\n  ground.rotation.x = -Math.PI / 2;\n  scene.add(ground);\n\n  // Grid overlay\n  const grid = new THREE.GridHelper(groundSize, 60, 0x2a4a4a, 0x1a2a3a);\n  grid.position.y = 0.01;\n  scene.add(grid);\n\n  // Arena obstacles\n  createObstacles();\n\n  // Arena pits\n  createPits();\n\n  // Resize handler \u2014 also handle mobile orientation changes\n  window.addEventListener('resize', onResize);\n  window.addEventListener('orientationchange', () => {\n    // Delay to let browser settle after orientation change\n    setTimeout(onResize, 150);\n  });\n  if (window.visualViewport) {\n    window.visualViewport.addEventListener('resize', onResize);\n  }\n\n  return { scene, camera, renderer };\n}\n\nfunction clearObstacleMeshes() {\n  for (const m of obstacleMeshes) {\n    scene.remove(m);\n    if (m.geometry) m.geometry.dispose();\n  }\n  obstacleMeshes = [];\n  for (const m of wallMeshes) {\n    scene.remove(m);\n    if (m.geometry) m.geometry.dispose();\n  }\n  wallMeshes = [];\n}\n\nfunction createObstacles() {\n  clearObstacleMeshes();\n\n  const mat = new THREE.MeshStandardMaterial({\n    color: 0x2a2a4a,\n    emissive: 0x223355,\n    emissiveIntensity: 0.3,\n    roughness: 0.7,\n    metalness: 0.2\n  });\n\n  for (const o of OBSTACLES) {\n    const mesh = new THREE.Mesh(new THREE.BoxGeometry(o.w, o.h, o.d), mat);\n    mesh.position.set(o.x, o.h / 2, o.z);\n    scene.add(mesh);\n    obstacleMeshes.push(mesh);\n  }\n\n  // Arena perimeter walls\n  const wallMat = new THREE.MeshStandardMaterial({\n    color: 0x1a1a2e,\n    emissive: 0x334466,\n    emissiveIntensity: 0.4,\n    roughness: 0.8\n  });\n\n  // North/South walls (span arena width)\n  for (const zSign of [-1, 1]) {\n    const wall = new THREE.Mesh(\n      new THREE.BoxGeometry(ARENA_HALF_X * 2 + WALL_THICKNESS, WALL_HEIGHT, WALL_THICKNESS),\n      wallMat\n    );\n    wall.position.set(0, WALL_HEIGHT / 2, zSign * ARENA_HALF_Z);\n    scene.add(wall);\n    wallMeshes.push(wall);\n  }\n  // East/West walls (span arena depth)\n  for (const xSign of [-1, 1]) {\n    const wall = new THREE.Mesh(\n      new THREE.BoxGeometry(WALL_THICKNESS, WALL_HEIGHT, ARENA_HALF_Z * 2 + WALL_THICKNESS),\n      wallMat\n    );\n    wall.position.set(xSign * ARENA_HALF_X, WALL_HEIGHT / 2, 0);\n    scene.add(wall);\n    wallMeshes.push(wall);\n  }\n}\n\nfunction clearPitMeshes() {\n  for (const m of pitMeshes) {\n    scene.remove(m);\n    if (m.geometry) m.geometry.dispose();\n  }\n  pitMeshes = [];\n}\n\nfunction createPits() {\n  clearPitMeshes();\n\n  const edgeThickness = 0.08;\n  const edgeHeight = 0.02;\n\n  const edgeMat = new THREE.MeshBasicMaterial({\n    color: 0xff2244,\n    transparent: true,\n    opacity: 0.8,\n  });\n\n  for (const p of PITS) {\n    // Dark void floor (slightly below ground)\n    const voidMesh = new THREE.Mesh(\n      new THREE.PlaneGeometry(p.w, p.d),\n      new THREE.MeshBasicMaterial({ color: 0x000000 })\n    );\n    voidMesh.rotation.x = -Math.PI / 2;\n    voidMesh.position.set(p.x, -0.05, p.z);\n    scene.add(voidMesh);\n    pitMeshes.push(voidMesh);\n\n    // North edge\n    const nEdge = new THREE.Mesh(\n      new THREE.BoxGeometry(p.w + edgeThickness * 2, edgeHeight, edgeThickness),\n      edgeMat\n    );\n    nEdge.position.set(p.x, 0.01, p.z + p.d / 2);\n    scene.add(nEdge);\n    pitMeshes.push(nEdge);\n\n    // South edge\n    const sEdge = new THREE.Mesh(\n      new THREE.BoxGeometry(p.w + edgeThickness * 2, edgeHeight, edgeThickness),\n      edgeMat\n    );\n    sEdge.position.set(p.x, 0.01, p.z - p.d / 2);\n    scene.add(sEdge);\n    pitMeshes.push(sEdge);\n\n    // East edge\n    const eEdge = new THREE.Mesh(\n      new THREE.BoxGeometry(edgeThickness, edgeHeight, p.d),\n      edgeMat\n    );\n    eEdge.position.set(p.x + p.w / 2, 0.01, p.z);\n    scene.add(eEdge);\n    pitMeshes.push(eEdge);\n\n    // West edge\n    const wEdge = new THREE.Mesh(\n      new THREE.BoxGeometry(edgeThickness, edgeHeight, p.d),\n      edgeMat\n    );\n    wEdge.position.set(p.x - p.w / 2, 0.01, p.z);\n    scene.add(wEdge);\n    pitMeshes.push(wEdge);\n  }\n}\n\nfunction clearPlatformMeshes() {\n  for (const m of _platformMeshes) {\n    scene.remove(m);\n    if (m.geometry) m.geometry.dispose();\n  }\n  _platformMeshes = [];\n}\n\nfunction createPlatforms() {\n  clearPlatformMeshes();\n\n  const mat = new THREE.MeshStandardMaterial({ color: 0x3366aa, roughness: 0.7 });\n\n  for (const zone of HEIGHT_ZONES) {\n    const geo = new THREE.BoxGeometry(zone.w, zone.y, zone.d);\n    const mesh = new THREE.Mesh(geo, mat);\n    mesh.position.set(zone.x, zone.y / 2, zone.z);\n    scene.add(mesh);\n    _platformMeshes.push(mesh);\n  }\n}\n\n// Rebuild all arena visuals (obstacles + pits + platforms) \u2014 called by level editor\nexport function rebuildArenaVisuals() {\n  createObstacles();\n  createPits();\n  clearPlatformMeshes();\n  createPlatforms();\n}\n\nfunction getViewportSize() {\n  // visualViewport gives accurate size on mobile (accounts for browser chrome)\n  if (window.visualViewport) {\n    return { w: window.visualViewport.width, h: window.visualViewport.height };\n  }\n  return { w: window.innerWidth, h: window.innerHeight };\n}\n\nfunction onResize() {\n  const { w, h } = getViewportSize();\n  applyFrustum(currentFrustum);\n  renderer.setSize(w, h);\n}\n\nfunction applyFrustum(f: number) {\n  const { w, h } = getViewportSize();\n  const aspect = w / h;\n  camera.left = -f * aspect;\n  camera.right = f * aspect;\n  camera.top = f;\n  camera.bottom = -f;\n  camera.updateProjectionMatrix();\n  currentFrustum = f;\n}\n\nexport function setZoom(frustum: number) {\n  applyFrustum(Math.max(6, Math.min(30, frustum)));\n}\n\nexport function setFrustumSize(size: number) {\n  applyFrustum(size);\n}\n\nexport function resetZoom() {\n  applyFrustum(baseFrustum);\n}\n\nexport function getCurrentFrustum() {\n  return currentFrustum;\n}\n\nexport function updateCamera(playerPos: any, dt: number) {\n  // Snap camera to player \u2014 no lerp. Ortho camera + lerp causes a sliding/swimming feel\n  // because the lookAt target and position desync subtly each frame.\n  camera.position.copy(playerPos).add(cameraOffset);\n\n  // Screen shake (offset from snapped position)\n  if (shakeRemaining > 0) {\n    shakeRemaining -= dt * 1000;\n    const decay = Math.max(0, shakeRemaining / 150);\n    const amt = shakeIntensity * decay;\n    camera.position.x += (Math.random() - 0.5) * amt * 0.1;\n    camera.position.z += (Math.random() - 0.5) * amt * 0.1;\n  }\n\n  camera.lookAt(playerPos);\n}\n\nexport function screenShake(intensity: number, durationMs = 100) {\n  shakeIntensity = intensity;\n  shakeRemaining = durationMs;\n}\n\n// Convert mouse NDC to world position on y=0 plane\nexport function screenToWorld(ndcX: number, ndcY: number) {\n  _unprojectVec.set(ndcX, ndcY, 0);\n  _unprojectVec.unproject(camera);\n\n  // Camera direction\n  _camDir.set(0, 0, -1).applyQuaternion(camera.quaternion);\n\n  // Intersect ray with y=0 plane\n  const t = -_unprojectVec.y / _camDir.y;\n  return new THREE.Vector3(\n    _unprojectVec.x + _camDir.x * t,\n    0,\n    _unprojectVec.z + _camDir.z * t\n  );\n}\n\nexport function getScene() { return scene; }\nexport function getCamera() { return camera; }\nexport function getRendererInstance() { return renderer; }\nexport function getPitMeshes() { return pitMeshes; }\nexport function getObstacleMeshes() { return obstacleMeshes; }\n", "import { PlayerConfig } from '../types/index';\n\nexport const PLAYER: PlayerConfig = {\n  maxHealth: 100,\n  speed: 5,\n  fireRate: 410,\n  projectile: { speed: 16, damage: 10, color: 0x44ff88, size: 0.2 },\n  size: { radius: 0.35, height: 1.2 }\n};\n\n// Melee combat config \u2014 tunable via tuning panel\nexport const MELEE = {\n  damage: 10,\n  range: 2.2,           // how far the swing reaches from player center\n  arc: 2.4,             // radians (~137\u00B0) \u2014 generous cone\n  cooldown: 380,         // ms between swings\n  knockback: 1.5,        // units pushed on hit\n  autoTargetRange: 3.0,  // radius to search for snap-targeting\n  autoTargetArc: 2.8,    // radians (~160\u00B0) \u2014 wide search for auto-target\n  screenShake: 1.5,      // shake intensity on hit\n  hitPause: 40,          // ms of freeze-frame on hit (juice)\n};\n\n// Jump config \u2014 tunable via tuning panel\nexport const JUMP = {\n  initialVelocity: 12,     // upward velocity on jump\n  gravity: 25,              // player gravity (may differ from enemy gravity)\n  airControlMult: 1.0,      // XZ speed multiplier while airborne\n  landingLag: 50,           // ms of end-lag on landing\n  coyoteTime: 80,           // ms of grace period after walking off ledge\n};\n\n// Aerial strike config \u2014 LMB while airborne\nexport const AERIAL_STRIKE = {\n  damage: 20,              // bonus damage (more than ground melee)\n  range: 2.5,              // XZ range to find target\n  slamVelocity: -18,       // downward velocity applied to enemy (negative = down)\n  screenShake: 2.5,        // bigger shake than ground melee\n  hitPause: 60,            // longer freeze-frame for impact\n  cooldown: 300,           // ms between aerial strikes (shorter than ground melee)\n};\n\n// Grab and dunk config \u2014 E while airborne near airborne enemy\nexport const DUNK = {\n  slamVelocity: -25,       // downward velocity for both player + enemy\n  damage: 35,              // big damage on impact (the payoff)\n  landingShake: 4.0,       // massive screen shake\n  landingLag: 200,         // ms of end-lag\n  aoeRadius: 1.5,          // splash damage radius on impact\n  aoeDamage: 10,           // splash damage to other nearby enemies\n  aoeKnockback: 10,        // knockback to nearby enemies\n  targetRadius: 6.0,       // radius of landing target circle (world units)\n  homing: 60,              // XZ homing speed toward target (units/sec)\n  grabPause: 60,           // ms freeze-frame on grab\n  grabShake: 1.5,          // screen shake on grab\n  carryOffsetY: -0.4,      // enemy offset below player during slam fall\n  carryOffsetZ: 0.35,      // enemy offset forward during slam fall\n  floatDuration: 600,      // ms of zero-gravity float (aim window before dunk)\n  floatConvergeDist: 3.5,  // Y distance threshold to trigger float\n  floatEnemyOffsetY: 0.6,  // enemy hovers this far above player during float\n  floatDriftSpeed: 3,      // XZ drift speed toward each other during float\n  arcRiseVelocity: 8,      // upward velocity at grab start\n  arcXzFraction: 0.3,      // fraction of XZ distance to landing covered during rise\n};\n\n// Self-slam config \u2014 E while airborne, no enemy nearby\nexport const SELF_SLAM = {\n  slamVelocity: -30,       // fast downward velocity\n  landingShake: 3.0,       // screen shake on impact\n  landingLag: 150,         // ms of end-lag\n  damageRadius: 2.5,       // AoE damage radius on impact\n  damage: 15,              // AoE damage to nearby grounded enemies\n  knockback: 8,            // knockback force on nearby enemies\n};\n\n// Launch verb config \u2014 E while grounded near an enemy\nexport const LAUNCH = {\n  range: 3.0,             // max range to find a target\n  enemyVelMult: 1.3,      // enemy launch velocity = JUMP.initialVelocity \u00D7 this\n  playerVelMult: 1.15,    // player hop velocity = JUMP.initialVelocity \u00D7 this\n  cooldown: 600,          // ms cooldown between launches\n  damage: 5,              // small chip damage on launch\n  arcFraction: 0.7,       // fraction of XZ distance covered by arc velocity\n  pillarDuration: 500,    // total animation time ms\n  pillarRiseTime: 150,    // ms to emerge from ground\n  pillarHoldTime: 100,    // ms at peak before sinking\n  pillarHeight: 1.2,      // rise height above ground\n  pillarRadius: 0.3,      // cylinder radius\n  pillarColor: 0x887766,  // stone gray-brown\n  windupDuration: 120,         // ms delay between E press and launch execution\n  indicatorColor: 0xffaa00,    // ring + emissive color\n  indicatorRingRadius: 0.6,    // outer radius of ground ring\n  indicatorOpacity: 0.4,       // base ring opacity\n};\n\n// Float selector config \u2014 shared aerial verb selection window\nexport const FLOAT_SELECTOR = {\n  holdThreshold: 180,        // ms to differentiate tap (spike) vs hold (dunk)\n  chargeVisualDelay: 50,     // ms before charge ring starts filling\n  floatDriftRate: 6,         // exponential decay rate for XZ drift during float\n};\n\n// Spike verb config \u2014 volleyball spike, enemy becomes projectile\nexport const SPIKE = {\n  damage: 15,                // hit damage to spiked enemy on strike\n  projectileSpeed: 25,       // enemy flight speed (units/sec)\n  projectileAngle: 35,       // degrees below horizontal toward aim point\n  throughDamage: 20,         // damage to enemies hit along flight path\n  throughKnockback: 8,       // knockback to path-hit enemies\n  impactDamage: 15,          // AoE damage on ground impact\n  impactRadius: 2.0,         // AoE radius on ground impact\n  impactKnockback: 10,       // knockback on ground impact\n  windupDuration: 80,        // ms windup before strike\n  hangDuration: 150,         // ms hang after strike (follow-through)\n  fastFallGravityMult: 2.5,  // enhanced gravity during post-spike fall\n  screenShake: 3.0,          // shake on spike strike\n  impactShake: 2.5,          // shake on enemy ground impact\n};\n", "import { AbilitiesConfig } from '../types/index';\n\nexport const ABILITIES: AbilitiesConfig = {\n  dash: {\n    name: 'Shadow Dash',\n    key: 'Shift',\n    cooldown: 3000,\n    duration: 200,\n    distance: 5,\n    curve: 'easeOut',\n    invincible: true,\n    iFrameStart: 0,\n    iFrameEnd: 200,\n    directionSource: 'movement',\n    afterimageCount: 3,\n    afterimageFadeDuration: 300,\n    ghostColor: 0x44ffaa,\n    trailColor: 0x44ff88,\n    screenShakeOnStart: 1.5,\n    canShootDuring: false,\n    canAbilityCancel: false,\n    endLag: 50,\n    description: 'Dash forward, briefly invincible'\n  },\n  ultimate: {\n    name: 'Force Push',\n    key: 'E',\n    cooldown: 500,\n    chargeTimeMs: 1500,\n    minLength: 3,\n    maxLength: 12,\n    width: 3,\n    minKnockback: 4,\n    maxKnockback: 12,\n    color: 0x44ffaa,\n    telegraphOpacity: 0.3,\n    chargeMoveSpeedMult: 0.4,\n    description: 'Charge a directional push \u2014 hold to extend range'\n  }\n};\n", "// Canvas 2D damage number system \u2014 no DOM thrash, scales to hundreds of numbers\nimport { getCamera } from '../engine/renderer';\n\nlet canvas: any, ctx: any;\nconst POOL_SIZE = 40;\nconst LIFETIME = 600; // ms\nconst FLOAT_DISTANCE = 40; // px upward travel\n\n// Pre-allocated pool of damage number slots\nconst pool: any[] = [];\nfor (let i = 0; i < POOL_SIZE; i++) {\n  pool.push({ active: false, x: 0, y: 0, value: 0, life: 0, color: '#ffffff' });\n}\n\n// Reusable vector for world\u2192screen projection\nconst _projVec = new THREE.Vector3();\n\nexport function initDamageNumbers() {\n  canvas = document.createElement('canvas');\n  canvas.id = 'damage-canvas';\n  canvas.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:15;';\n  document.body.appendChild(canvas);\n  resizeCanvas();\n  window.addEventListener('resize', resizeCanvas);\n}\n\nfunction resizeCanvas() {\n  canvas.width = window.innerWidth;\n  canvas.height = window.innerHeight;\n}\n\nexport function spawnDamageNumber(worldX: number, worldZ: number, value: any, color?: string) {\n  if (!color) color = '#ffffff';\n\n  // Find inactive slot\n  let slot: any = null;\n  for (let i = 0; i < POOL_SIZE; i++) {\n    if (!pool[i].active) {\n      slot = pool[i];\n      break;\n    }\n  }\n  // If pool full, recycle oldest\n  if (!slot) {\n    let oldest = pool[0];\n    for (let i = 1; i < POOL_SIZE; i++) {\n      if (pool[i].life > oldest.life) oldest = pool[i];\n    }\n    slot = oldest;\n  }\n\n  // Project world position to screen\n  const camera = getCamera();\n  _projVec.set(worldX, 1.5, worldZ); // slightly above ground\n  _projVec.project(camera);\n\n  slot.active = true;\n  slot.x = (_projVec.x * 0.5 + 0.5) * canvas.width;\n  slot.y = (-_projVec.y * 0.5 + 0.5) * canvas.height;\n  slot.value = typeof value === 'string' ? value : Math.round(value);\n  slot.life = 0;\n  slot.color = color;\n\n  // Add slight random horizontal offset to prevent stacking\n  slot.x += (Math.random() - 0.5) * 20;\n}\n\nexport function updateDamageNumbers(dt: number) {\n  if (!ctx) ctx = canvas.getContext('2d');\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  const dtMs = dt * 1000;\n\n  for (let i = 0; i < POOL_SIZE; i++) {\n    const slot = pool[i];\n    if (!slot.active) continue;\n\n    slot.life += dtMs;\n    if (slot.life >= LIFETIME) {\n      slot.active = false;\n      continue;\n    }\n\n    const t = slot.life / LIFETIME;\n    const alpha = 1 - t * t; // fade out with ease\n    const yOffset = -FLOAT_DISTANCE * t; // float upward\n    const scale = 1 + t * 0.3; // slight grow\n\n    const x = slot.x;\n    const y = slot.y + yOffset;\n\n    ctx.save();\n    ctx.globalAlpha = alpha;\n    ctx.font = `bold ${Math.round(16 * scale)}px 'SF Mono', 'Consolas', monospace`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n\n    // Shadow for readability\n    ctx.shadowColor = 'rgba(0,0,0,0.8)';\n    ctx.shadowBlur = 4;\n    ctx.shadowOffsetX = 1;\n    ctx.shadowOffsetY = 1;\n\n    ctx.fillStyle = slot.color;\n    ctx.fillText(slot.value, x, y);\n    ctx.restore();\n  }\n}\n\nexport function clearDamageNumbers() {\n  for (let i = 0; i < POOL_SIZE; i++) {\n    pool[i].active = false;\n  }\n  if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);\n}\n", "// Generic AoE telegraph system \u2014 expanding rings, rectangles, and cascading per-target effects.\n// Not tied to any specific mechanic \u2014 works for stun, damage, slow, etc.\n\nimport { spawnDamageNumber } from '../ui/damageNumbers';\n\nlet sceneRef: any;\n\n// Active telegraph shapes (rings + rects)\nconst activeTelegraphs: any[] = [];\n\n// Pending per-target effects (delayed callbacks)\nconst pendingEffects: any[] = [];\n\n// Shared geometries (created once)\nlet ringGeo: any;\nlet planeGeo: any;\n\n// --- Easing ---\n\nfunction easeOutQuad(t: number) {\n  return t * (2 - t);\n}\n\n// --- Init ---\n\nexport function initAoeTelegraph(scene: any) {\n  sceneRef = scene;\n}\n\n// --- Ring Shape ---\n\nexport function createAoeRing(x: number, z: number, maxRadius: number, durationMs: number, color: number) {\n  if (!ringGeo) {\n    ringGeo = new THREE.RingGeometry(0.8, 1.0, 32);\n    ringGeo.rotateX(-Math.PI / 2); // lay flat on ground\n  }\n\n  const mat = new THREE.MeshBasicMaterial({\n    color: color,\n    transparent: true,\n    opacity: 0.8,\n    side: THREE.DoubleSide,\n    depthWrite: false,\n  });\n\n  const mesh = new THREE.Mesh(ringGeo, mat);\n  mesh.position.set(x, 0.05, z); // slightly above ground\n  mesh.scale.set(0.01, 0.01, 0.01); // start tiny\n  sceneRef.add(mesh);\n\n  const telegraph = {\n    type: 'ring',\n    mesh: mesh,\n    material: mat,\n    center: { x, z },\n    maxRadius: maxRadius,\n    duration: durationMs,\n    elapsed: 0,\n    color: color,\n  };\n\n  activeTelegraphs.push(telegraph);\n  return telegraph;\n}\n\n// --- Rectangle Shape ---\n\nexport function createAoeRect(x: number, z: number, width: number, height: number, rotation: number, durationMs: number, color: number) {\n  if (!planeGeo) {\n    planeGeo = new THREE.PlaneGeometry(1, 1);\n    planeGeo.rotateX(-Math.PI / 2); // lay flat on ground\n  }\n\n  const group = new THREE.Group();\n  group.position.set(x, 0.05, z);\n  group.rotation.y = rotation;\n\n  // Fill plane\n  const fillMat = new THREE.MeshBasicMaterial({\n    color: color,\n    transparent: true,\n    opacity: 0.0, // ramps up over first 30%\n    side: THREE.DoubleSide,\n    depthWrite: false,\n  });\n  const fillMesh = new THREE.Mesh(planeGeo, fillMat);\n  fillMesh.scale.set(width * 0.8, 1, height * 0.8); // start at 80%\n  group.add(fillMesh);\n\n  // Border outline\n  const edgeGeo = new THREE.EdgesGeometry(new THREE.PlaneGeometry(width, height));\n  edgeGeo.rotateX(-Math.PI / 2);\n  const borderMat = new THREE.LineBasicMaterial({\n    color: color,\n    transparent: true,\n    opacity: 0.9,\n    depthWrite: false,\n  });\n  const borderMesh = new THREE.LineSegments(edgeGeo, borderMat);\n  group.add(borderMesh);\n\n  sceneRef.add(group);\n\n  const telegraph = {\n    type: 'rect',\n    mesh: group,\n    fillMesh: fillMesh,\n    fillMaterial: fillMat,\n    borderMesh: borderMesh,\n    borderMaterial: borderMat,\n    borderEdgeGeo: edgeGeo,\n    center: { x, z },\n    width: width,\n    height: height,\n    rotation: rotation,\n    duration: durationMs,\n    elapsed: 0,\n    color: color,\n  };\n\n  activeTelegraphs.push(telegraph);\n  return telegraph;\n}\n\n// --- Hit Testing ---\n\n/**\n * Check if a point is inside a rotated rectangle.\n */\nexport function isInRotatedRect(ex: number, ez: number, cx: number, cz: number, w: number, h: number, rotation: number, padding?: number) {\n  const pad = padding || 0;\n  const dx = ex - cx;\n  const dz = ez - cz;\n  const cos = Math.cos(-rotation);\n  const sin = Math.sin(-rotation);\n  const localX = dx * cos - dz * sin;\n  const localZ = dx * sin + dz * cos;\n  return Math.abs(localX) < (w / 2 + pad) && Math.abs(localZ) < (h / 2 + pad);\n}\n\n// --- Update Telegraphs ---\n\nexport function updateAoeTelegraphs(dt: number) {\n  const dtMs = dt * 1000;\n\n  for (let i = activeTelegraphs.length - 1; i >= 0; i--) {\n    const t = activeTelegraphs[i];\n    t.elapsed += dtMs;\n    const progress = Math.min(t.elapsed / t.duration, 1);\n\n    if (t.type === 'ring') {\n      updateRing(t, progress);\n    } else if (t.type === 'rect') {\n      updateRect(t, progress);\n    }\n\n    // Remove when complete\n    if (progress >= 1) {\n      removeTelegraph(t);\n      activeTelegraphs.splice(i, 1);\n    }\n  }\n}\n\nfunction updateRing(t: any, progress: number) {\n  const easedProgress = easeOutQuad(progress);\n\n  // Scale \u2014 expand from 0 to maxRadius\n  const currentRadius = t.maxRadius * easedProgress;\n  t.mesh.scale.set(currentRadius, currentRadius, currentRadius);\n\n  // Thickness shrinks (simulated via Y scale stretching the ring thinner feel)\n  // The ring geometry is 0.8\u21921.0 inner/outer, so at scale 1 it's 0.2 thick.\n  // We modulate opacity instead for the thinning effect.\n\n  // Opacity fades out\n  t.material.opacity = 0.8 * (1 - progress);\n}\n\nfunction updateRect(t: any, progress: number) {\n  const easedProgress = easeOutQuad(progress);\n\n  // Fill: opacity ramps 0 \u2192 0.3 over first 30%, then fades\n  let fillOpacity;\n  if (progress < 0.3) {\n    fillOpacity = 0.3 * (progress / 0.3);\n  } else {\n    fillOpacity = 0.3 * (1 - (progress - 0.3) / 0.7);\n  }\n  t.fillMaterial.opacity = Math.max(0, fillOpacity);\n\n  // Fill scale: 80% \u2192 100%\n  const scaleMult = 0.8 + 0.2 * easedProgress;\n  t.fillMesh.scale.set(t.width * scaleMult, 1, t.height * scaleMult);\n\n  // Border: pulse frequency accelerates 2Hz \u2192 8Hz\n  const freq = 2 + 6 * progress;\n  const pulse = 0.5 + 0.5 * Math.sin(performance.now() * freq * 0.00628); // 2\u03C0/1000\n  t.borderMaterial.opacity = 0.4 + 0.5 * pulse;\n\n  // Brightness ramp in last 100ms \u2014 telegraph flashes bright before firing\n  const flashThreshold = 1 - (100 / t.duration); // last 100ms as fraction of total\n  if (progress > flashThreshold) {\n    const flashProgress = (progress - flashThreshold) / (1 - flashThreshold); // 0\u21921\n    // Ramp fill to full bright\n    t.fillMaterial.opacity = 0.3 + 0.5 * flashProgress;\n    // Solid bright border\n    t.borderMaterial.opacity = 0.8 + 0.2 * flashProgress;\n    // Brighten fill color toward white\n    const r = ((t.color >> 16) & 0xff) / 255;\n    const g = ((t.color >> 8) & 0xff) / 255;\n    const b = (t.color & 0xff) / 255;\n    t.fillMaterial.color.setRGB(\n      r + (1 - r) * flashProgress * 0.6,\n      g + (1 - g) * flashProgress * 0.6,\n      b + (1 - b) * flashProgress * 0.6\n    );\n    t.borderMaterial.color.setRGB(\n      r + (1 - r) * flashProgress * 0.6,\n      g + (1 - g) * flashProgress * 0.6,\n      b + (1 - b) * flashProgress * 0.6\n    );\n  } else if (progress > 0.8) {\n    // Border fades in last 20% (but before the flash window)\n    const fadeProgress = (progress - 0.8) / (flashThreshold - 0.8);\n    t.borderMaterial.opacity *= (1 - fadeProgress * 0.5);\n    t.fillMaterial.opacity *= (1 - fadeProgress * 0.5);\n  }\n}\n\nfunction removeTelegraph(t: any) {\n  if (t.type === 'ring') {\n    t.material.dispose();\n    sceneRef.remove(t.mesh);\n  } else if (t.type === 'rect') {\n    t.fillMaterial.dispose();\n    t.borderMaterial.dispose();\n    t.borderEdgeGeo.dispose();\n    sceneRef.remove(t.mesh);\n  }\n}\n\n// --- Pending Effects ---\n\nexport function schedulePendingEffect(enemy: any, delayMs: number, callback: (enemy: any) => void) {\n  pendingEffects.push({ enemy, delay: delayMs, callback });\n}\n\n// Generic delayed callback (not tied to an enemy)\nexport function scheduleCallback(delayMs: number, callback: () => void) {\n  pendingEffects.push({ enemy: null, delay: delayMs, callback });\n}\n\nexport function updatePendingEffects(dt: number) {\n  const dtMs = dt * 1000;\n\n  for (let i = pendingEffects.length - 1; i >= 0; i--) {\n    const p = pendingEffects[i];\n    p.delay -= dtMs;\n    if (p.delay <= 0) {\n      if (p.enemy) {\n        p.callback(p.enemy);\n      } else {\n        p.callback();\n      }\n      pendingEffects.splice(i, 1);\n    }\n  }\n}\n\n// --- Generic AoE Applicator ---\n\n/**\n * Trigger an AoE effect with visual telegraph and cascading per-target application.\n */\nexport function applyAoeEffect({ x, z, radius, durationMs, color, label, effectFn, gameState, excludeEnemy }: {\n  x: number;\n  z: number;\n  radius: number;\n  durationMs: number;\n  color: number;\n  label?: string;\n  effectFn: (enemy: any) => void;\n  gameState: any;\n  excludeEnemy?: any;\n}) {\n  // 1. Create expanding ring visual\n  createAoeRing(x, z, radius, durationMs, color);\n\n  // 2. Schedule cascade effects on each enemy in range\n  const colorStr = '#' + color.toString(16).padStart(6, '0');\n\n  for (const enemy of gameState.enemies) {\n    if (enemy === excludeEnemy) continue;\n\n    const dx = enemy.pos.x - x;\n    const dz = enemy.pos.z - z;\n    const dist = Math.sqrt(dx * dx + dz * dz);\n\n    if (dist < radius) {\n      // Delay proportional to distance \u2014 closest react first\n      const delayMs = (dist / radius) * durationMs;\n\n      schedulePendingEffect(enemy, delayMs, (e) => {\n        // Apply the actual game effect\n        effectFn(e);\n\n        // Visual feedback \u2014 flash enemy to effect color\n        e.flashTimer = 200;\n        e.bodyMesh.material.emissive.setHex(color);\n        if (e.headMesh) e.headMesh.material.emissive.setHex(color);\n\n        // Floating text label\n        if (label) {\n          spawnDamageNumber(e.pos.x, e.pos.z, label, colorStr);\n        }\n      });\n    }\n  }\n}\n\n// --- Rectangle AoE Applicator ---\n\n/**\n * Trigger a rectangle AoE \u2014 shows a telegraph, then fires a damage corridor.\n * Hits both enemies AND the player (friendly fire / environmental hazard).\n */\nexport function applyAoeRectEffect({\n  x, z, width, height, rotation,\n  telegraphDurationMs, lingerDurationMs,\n  color, damage,\n  playerDamageFn, enemyDamageFn,\n  gameState, excludeEnemy\n}: {\n  x: number;\n  z: number;\n  width: number;\n  height: number;\n  rotation: number;\n  telegraphDurationMs: number;\n  lingerDurationMs: number;\n  color: number;\n  damage: number;\n  playerDamageFn?: (x: number, z: number, width: number, height: number, rotation: number) => void;\n  enemyDamageFn?: (enemy: any) => void;\n  gameState: any;\n  excludeEnemy?: any;\n}) {\n  // 1. Show telegraph rect (warning phase)\n  createAoeRect(x, z, width, height, rotation, telegraphDurationMs, color);\n\n  // 2. Schedule the actual damage at the end of the telegraph\n  const colorStr = '#' + color.toString(16).padStart(6, '0');\n\n  scheduleCallback(telegraphDurationMs, () => {\n    // Show a bright \"fired\" rect that lingers briefly\n    createAoeRect(x, z, width, height, rotation, lingerDurationMs, color);\n\n    // Check all enemies in the rect (pad by enemy collision radius for generous hit detection)\n    for (const enemy of gameState.enemies) {\n      if (enemy === excludeEnemy) continue;\n      const enemyRadius = (enemy.config && enemy.config.size) ? enemy.config.size.radius : 0;\n      if (isInRotatedRect(enemy.pos.x, enemy.pos.z, x, z, width, height, rotation, enemyRadius)) {\n        if (enemyDamageFn) {\n          enemyDamageFn(enemy);\n        }\n        // Visual feedback\n        enemy.flashTimer = 200;\n        enemy.bodyMesh.material.emissive.setHex(color);\n        if (enemy.headMesh) enemy.headMesh.material.emissive.setHex(color);\n        spawnDamageNumber(enemy.pos.x, enemy.pos.z, damage, colorStr);\n      }\n    }\n\n    // Check player\n    if (playerDamageFn) {\n      playerDamageFn(x, z, width, height, rotation);\n    }\n  });\n}\n\n// --- Cleanup ---\n\nexport function clearAoeTelegraphs() {\n  // Remove all active telegraph shapes\n  for (const t of activeTelegraphs) {\n    removeTelegraph(t);\n  }\n  activeTelegraphs.length = 0;\n\n  // Clear pending effects\n  pendingEffects.length = 0;\n}\n", "import { EnemyConfig } from '../types/index';\n\n// Global multipliers for tuning all mobs at once\nexport const MOB_GLOBAL = {\n  speedMult: 1,\n  damageMult: 1,\n  healthMult: 1,\n  telegraphMult: 1,\n  recoveryMult: 1,\n};\n\nexport const ENEMY_TYPES: Record<string, EnemyConfig> = {\n  goblin: {\n    name: \"Goblin\",\n    health: 30,\n    speed: 2.45,\n    damage: 10,\n    attackRange: 1.5,\n    attackRate: 800,\n    behavior: \"rush\",\n    knockbackResist: 0,\n    mass: 1.0,\n    color: 16729190,\n    emissive: 16720452,\n    size: { radius: 0.3, height: 0.8 },\n    drops: { currency: { min: 1, max: 3 }, healthChance: 0.1 },\n    rush: { stopDistance: 0.5 },\n    melee: {\n      telegraphDuration: 300,\n      attackDuration: 100,\n      recoveryDuration: 400,\n      lungeDistance: 0.8,\n      damage: 10,\n      hitArc: 1.5,\n      hitRange: 1.2,\n    },\n    pitLeap: {\n      edgeTimeRequired: 1500,\n      leapSpeed: 7,\n      arcHeight: 2,\n      cooldown: 4000\n    },\n    aggroRadius: 8,\n    patrol: {\n      distance: 6,\n      speed: 1.2,\n      pauseMin: 500,\n      pauseMax: 1500,\n    },\n  },\n  skeletonArcher: {\n    name: \"Skeleton Archer\",\n    health: 20,\n    speed: 1.4,\n    damage: 15,\n    attackRange: 12,\n    attackRate: 2500,\n    behavior: \"kite\",\n    knockbackResist: 0.1,\n    mass: 0.8,\n    color: 11176191,\n    emissive: 8930508,\n    size: { radius: 0.25, height: 1 },\n    drops: { currency: { min: 2, max: 4 }, healthChance: 0.05 },\n    kite: { preferredRangeMult: 0.7, retreatBuffer: 1, advanceBuffer: 3 },\n    sniper: {\n      telegraphDuration: 800,\n      shotWidth: 1.2,\n      shotLength: 14,\n      damage: 15,\n      color: 11158783,\n      lingerDuration: 200,\n      slowDuration: 1000,\n      slowMult: 0.5\n    }\n  },\n  iceMortarImp: {\n    name: \"Ice Mortar Imp\",\n    health: 25,\n    speed: 1.6,\n    damage: 12,\n    attackRange: 15.5,\n    attackRate: 3000,\n    behavior: \"mortar\",\n    knockbackResist: 0.1,\n    mass: 0.9,\n    color: 4513279,\n    emissive: 13391104,\n    size: { radius: 0.3, height: 0.9 },\n    drops: { currency: { min: 2, max: 5 }, healthChance: 0.08 },\n    kite: { preferredRangeMult: 0.65, retreatBuffer: 1.5, advanceBuffer: 3 },\n    mortar: {\n      aimDuration: 900,\n      projectileSpeed: 11,\n      arcHeight: 6,\n      blastRadius: 2.5,\n      damage: 18,\n      color: 5765887,\n      inaccuracy: 1.5,\n      slowDuration: 800,\n      slowMult: 0.6,\n      explosionDuration: 300,\n      circleStartScale: 0.25,\n      circleScaleTime: 800,\n      icePatch: {\n        enabled: true,\n        duration: 2000,\n        color: 8454143,\n        speedMult: 2.0,\n        knockbackMult: 2.0,\n        affectsPlayer: true,\n        affectsEnemies: true\n      }\n    }\n  },\n  stoneGolem: {\n    name: \"Stone Golem\",\n    health: 80,\n    speed: 1.05,\n    damage: 25,\n    attackRange: 2,\n    attackRate: 1200,\n    behavior: \"tank\",\n    knockbackResist: 0.6,\n    mass: 3.0,\n    color: 16746547,\n    emissive: 2263244,\n    size: { radius: 0.5, height: 1.4 },\n    drops: { currency: { min: 3, max: 6 }, healthChance: 0.2 },\n    tank: {\n      chargeSpeedMult: 3,\n      chargeDuration: 500,\n      chargeCooldownMin: 3000,\n      chargeCooldownMax: 5000,\n      chargeMinDist: 2,\n      chargeMaxDist: 10,\n      chargeDamageMult: 1.5,\n      telegraphDuration: 300\n    },\n    shield: {\n      maxHealth: 40,\n      stunRadius: 5,\n      stunDuration: 1500,\n      breakRingDuration: 400,\n      color: 8974079,\n      emissive: 4508927,\n      opacity: 0.35\n    },\n    melee: {\n      telegraphDuration: 700,\n      attackDuration: 150,\n      recoveryDuration: 800,\n      damage: 30,\n      hitArc: 2.0,\n      hitRange: 2.5,\n    },\n    deathExplosion: {\n      radius: 4,\n      damage: 20,\n      color: 4513279,\n      ringDuration: 400,\n      stunDuration: 0,\n      telegraphDuration: 1200\n    }\n  },\n};\n", "export class ObjectPool {\n  pool: any[];\n  active: any[];\n  createFn: () => any;\n\n  constructor(createFn: () => any, initialSize = 50) {\n    this.pool = [];\n    this.active = [];\n    this.createFn = createFn;\n    for (let i = 0; i < initialSize; i++) {\n      const obj = createFn();\n      obj.mesh.visible = false;\n      this.pool.push(obj);\n    }\n  }\n\n  acquire() {\n    let obj = this.pool.pop();\n    if (!obj) {\n      obj = this.createFn();\n    }\n    obj.mesh.visible = true;\n    this.active.push(obj);\n    return obj;\n  }\n\n  release(obj: any) {\n    obj.mesh.visible = false;\n    const idx = this.active.indexOf(obj);\n    if (idx !== -1) {\n      // Swap-remove: O(1) instead of O(n) splice\n      const last = this.active.length - 1;\n      if (idx !== last) this.active[idx] = this.active[last];\n      this.active.length = last;\n    }\n    this.pool.push(obj);\n  }\n\n  releaseAll() {\n    for (let i = this.active.length - 1; i >= 0; i--) {\n      const obj = this.active[i];\n      obj.mesh.visible = false;\n      this.pool.push(obj);\n    }\n    this.active.length = 0;\n  }\n\n  getActive() { return this.active; }\n}\n", "import { ObjectPool } from '../engine/pools';\nimport { PLAYER } from '../config/player';\n\nlet playerPool: any, enemyPool: any;\nlet sceneRef: any;\nlet basePlayerProjSize: number; // original geometry radius for scale calculation\n\nexport function initProjectilePool(scene: any) {\n  sceneRef = scene;\n\n  basePlayerProjSize = PLAYER.projectile.size;\n  const playerProjGeo = new THREE.SphereGeometry(basePlayerProjSize, 6, 4);\n  const playerProjMat = new THREE.MeshStandardMaterial({\n    color: PLAYER.projectile.color,\n    emissive: PLAYER.projectile.color,\n    emissiveIntensity: 0.8\n  });\n\n  playerPool = new ObjectPool(() => {\n    const mesh = new THREE.Mesh(playerProjGeo, playerProjMat.clone());\n    scene.add(mesh);\n    return { mesh, dir: new THREE.Vector3(), speed: 0, damage: 0, life: 0, isEnemy: false };\n  }, 80);\n\n  const enemyProjGeo = new THREE.SphereGeometry(0.1, 6, 4);\n\n  enemyPool = new ObjectPool(() => {\n    const mesh = new THREE.Mesh(\n      enemyProjGeo,\n      new THREE.MeshStandardMaterial({\n        color: 0xff4466,\n        emissive: 0xff2244,\n        emissiveIntensity: 0.8\n      })\n    );\n    scene.add(mesh);\n    return { mesh, dir: new THREE.Vector3(), speed: 0, damage: 0, life: 0, isEnemy: true };\n  }, 40);\n}\n\nexport function fireProjectile(origin: any, direction: any, config: any, isEnemy?: boolean) {\n  if (isEnemy === undefined) isEnemy = false;\n  const pool = isEnemy ? enemyPool : playerPool;\n  const p = pool.acquire();\n  p.mesh.position.set(origin.x, 0.8, origin.z);\n  p.dir.copy(direction).normalize();\n  p.speed = config.speed;\n  p.damage = config.damage;\n  p.life = 0;\n\n  // Scale player projectile mesh based on current config size vs base geometry\n  if (!isEnemy && basePlayerProjSize) {\n    const s = PLAYER.projectile.size / basePlayerProjSize;\n    p.mesh.scale.set(s, s, s);\n  }\n\n  // Update enemy projectile color per-type\n  if (isEnemy && config.color) {\n    p.mesh.material.color.setHex(config.color);\n    p.mesh.material.emissive.setHex(config.color);\n  }\n\n  return p;\n}\n\nexport function updateProjectiles(dt: number) {\n  const maxLife = 2.0;\n  for (const pool of [playerPool, enemyPool]) {\n    const active = pool.getActive();\n    for (let i = active.length - 1; i >= 0; i--) {\n      const p = active[i];\n      p.mesh.position.x += p.dir.x * p.speed * dt;\n      p.mesh.position.z += p.dir.z * p.speed * dt;\n      p.life += dt;\n      if (p.life > maxLife) {\n        pool.release(p);\n      }\n    }\n  }\n}\n\nexport function getPlayerProjectiles() { return playerPool ? playerPool.getActive() : []; }\nexport function getEnemyProjectiles() { return enemyPool ? enemyPool.getActive() : []; }\n\nexport function releaseProjectile(p: any) {\n  if (p.isEnemy) {\n    enemyPool.release(p);\n  } else {\n    playerPool.release(p);\n  }\n}\n\nexport function releaseAllProjectiles() {\n  if (playerPool) playerPool.releaseAll();\n  if (enemyPool) enemyPool.releaseAll();\n}\n", "// EnemyRig \u2014 Builds distinctive silhouettes for each enemy type from primitives.\n// Each type has unique proportions and identifying details (ears, ribs, hat, etc.)\n// while sharing the same construction pattern. No animation \u2014 just static models\n// with a shared hit reaction system.\n\n// \u2500\u2500\u2500 Per-Type Silhouette Config \u2500\u2500\u2500\n// Proportions are expressed as multipliers relative to cfg.size.radius and cfg.size.height.\n\ninterface SilhouetteConfig {\n  // Proportions (multiplied by cfg.size dimensions)\n  headScale: number;        // head radius as fraction of body radius\n  torsoW: number;           // torso width multiplier\n  torsoH: number;           // torso height multiplier\n  torsoD: number;           // torso depth multiplier\n  armW: number;             // arm width multiplier\n  armLen: number;           // arm length multiplier\n  legW: number;             // leg width multiplier\n  legLen: number;           // leg length multiplier\n  legSpread: number;        // horizontal distance between legs\n  hipY: number;             // hip height as fraction of total height\n  // Color adjustments\n  limbDarken: number;       // how much to darken limbs (0 = same, 0.3 = 30% darker)\n  headBrighten: number;     // how much to brighten head (0 = same, 0.2 = 20% brighter)\n  // Extras\n  extras: string[];\n}\n\n// Multipliers are relative to cfg.size (radius, height).\n// Old enemies were: cylinder(radius, height*0.6) + sphere(radius*0.7).\n// These are tuned so each type fits within roughly the same bounding volume\n// as the old primitives, while reading as distinct silhouettes.\n\nconst SILHOUETTES: Record<string, SilhouetteConfig> = {\n  goblin: {\n    headScale: 1.2,       // big exaggerated head \u2014 dominant feature\n    torsoW: 0.55, torsoH: 0.30, torsoD: 0.50,\n    armW: 0.28, armLen: 0.42,   // long-ish dangling arms\n    legW: 0.30, legLen: 0.28,   // short stubby legs\n    legSpread: 0.30,\n    hipY: 0.35,\n    limbDarken: 0.15,\n    headBrighten: 0.1,\n    extras: ['snout', 'ears'],\n  },\n  skeletonArcher: {\n    headScale: 0.7,        // small skull\n    torsoW: 0.38, torsoH: 0.42, torsoD: 0.30,  // narrow tall\n    armW: 0.18, armLen: 0.38,\n    legW: 0.20, legLen: 0.45,\n    legSpread: 0.22,\n    hipY: 0.45,\n    limbDarken: 0.1,\n    headBrighten: 0.05,\n    extras: ['bow', 'ribs'],\n  },\n  iceMortarImp: {\n    headScale: 0.9,\n    torsoW: 0.55, torsoH: 0.28, torsoD: 0.50,  // wide round body, scaled down\n    armW: 0.18, armLen: 0.20,   // stubby arms\n    legW: 0.22, legLen: 0.20,   // tiny legs\n    legSpread: 0.25,\n    hipY: 0.28,\n    limbDarken: 0.1,\n    headBrighten: 0.15,\n    extras: ['hat'],\n  },\n  stoneGolem: {\n    headScale: 0.5,        // tiny head sunk in shoulders\n    torsoW: 0.70, torsoH: 0.40, torsoD: 0.60,   // massive (golem already has large cfg.size)\n    armW: 0.38, armLen: 0.45,   // thick heavy arms\n    legW: 0.38, legLen: 0.38,   // thick legs\n    legSpread: 0.32,\n    hipY: 0.40,\n    limbDarken: 0.1,\n    headBrighten: 0.05,\n    extras: ['shoulders'],\n  },\n};\n\n// Default silhouette for unknown types\nconst DEFAULT_SILHOUETTE: SilhouetteConfig = {\n  headScale: 0.9,\n  torsoW: 0.50, torsoH: 0.35, torsoD: 0.45,\n  armW: 0.25, armLen: 0.35,\n  legW: 0.28, legLen: 0.35,\n  legSpread: 0.25,\n  hipY: 0.40,\n  limbDarken: 0.1,\n  headBrighten: 0.1,\n  extras: [],\n};\n\n// \u2500\u2500\u2500 Color Utilities \u2500\u2500\u2500\n\nfunction darkenColor(color: number, amount: number): number {\n  const r = Math.max(0, ((color >> 16) & 0xff) * (1 - amount)) | 0;\n  const g = Math.max(0, ((color >> 8) & 0xff) * (1 - amount)) | 0;\n  const b = Math.max(0, (color & 0xff) * (1 - amount)) | 0;\n  return (r << 16) | (g << 8) | b;\n}\n\nfunction brightenColor(color: number, amount: number): number {\n  const r = Math.min(255, ((color >> 16) & 0xff) * (1 + amount)) | 0;\n  const g = Math.min(255, ((color >> 8) & 0xff) * (1 + amount)) | 0;\n  const b = Math.min(255, (color & 0xff) * (1 + amount)) | 0;\n  return (r << 16) | (g << 8) | b;\n}\n\n// \u2500\u2500\u2500 Build Enemy Model \u2500\u2500\u2500\n\nexport interface EnemyModel {\n  bodyMesh: any;       // main torso mesh (backward compat for flash)\n  headMesh: any;       // head mesh (backward compat for flash)\n  allMeshes: any[];    // every mesh part (for comprehensive effects)\n  allMaterials: any[]; // every material (for flash/transparency)\n}\n\nexport function buildEnemyModel(typeName: string, cfg: any, group: any): EnemyModel {\n  const sil = SILHOUETTES[typeName] || DEFAULT_SILHOUETTE;\n  const r = cfg.size.radius;\n  const h = cfg.size.height;\n\n  const allMeshes: any[] = [];\n  const allMaterials: any[] = [];\n\n  function addMesh(geo: any, color: number, emissive: number, emissiveI: number, parent: any, x = 0, y = 0, z = 0) {\n    const mat = new THREE.MeshStandardMaterial({\n      color, emissive, emissiveIntensity: emissiveI,\n    });\n    const mesh = new THREE.Mesh(geo, mat);\n    mesh.position.set(x, y, z);\n    mesh.castShadow = true;\n    parent.add(mesh);\n    allMeshes.push(mesh);\n    allMaterials.push(mat);\n    return mesh;\n  }\n\n  const bodyColor = cfg.color;\n  const bodyEmissive = cfg.emissive;\n  const headColor = brightenColor(bodyColor, sil.headBrighten);\n  const headEmissive = brightenColor(bodyEmissive, sil.headBrighten);\n  const limbColor = darkenColor(bodyColor, sil.limbDarken);\n  const limbEmissive = darkenColor(bodyEmissive, sil.limbDarken);\n\n  // \u2500\u2500\u2500 Core body parts \u2500\u2500\u2500\n\n  const hipY = h * sil.hipY;\n  const torsoW = r * 2 * sil.torsoW;\n  const torsoH = h * sil.torsoH;\n  const torsoD = r * 2 * sil.torsoD;\n  const torsoY = hipY + torsoH / 2 + r * 0.05;\n\n  // Torso\n  const torsoGeo = new THREE.BoxGeometry(torsoW, torsoH, torsoD);\n  const bodyMesh = addMesh(torsoGeo, bodyColor, bodyEmissive, 0.5, group, 0, torsoY, 0);\n\n  // Head\n  const headRadius = r * sil.headScale * 0.7;\n  const headY = torsoY + torsoH / 2 + headRadius * 0.8;\n  const headGeo = new THREE.SphereGeometry(headRadius, 8, 6);\n  const headMesh = addMesh(headGeo, headColor, headEmissive, 0.6, group, 0, headY, 0);\n\n  // Arms\n  const shoulderY = torsoY + torsoH * 0.3;\n  const armW = r * sil.armW;\n  const armLen = h * sil.armLen;\n  const armGeo = new THREE.BoxGeometry(armW, armLen, armW);\n\n  addMesh(armGeo, limbColor, limbEmissive, 0.4, group,\n    -(torsoW / 2 + armW / 2), shoulderY - armLen / 2, 0);\n  addMesh(armGeo, limbColor, limbEmissive, 0.4, group,\n    (torsoW / 2 + armW / 2), shoulderY - armLen / 2, 0);\n\n  // Legs\n  const legW = r * sil.legW;\n  const legLen = h * sil.legLen;\n  const legSpread = r * sil.legSpread;\n  const legGeo = new THREE.BoxGeometry(legW, legLen, legW);\n\n  addMesh(legGeo, limbColor, limbEmissive, 0.4, group,\n    -legSpread, hipY - legLen / 2, 0);\n  addMesh(legGeo, limbColor, limbEmissive, 0.4, group,\n    legSpread, hipY - legLen / 2, 0);\n\n  // \u2500\u2500\u2500 Type-specific extras \u2500\u2500\u2500\n\n  if (sil.extras.includes('snout')) {\n    const snoutGeo = new THREE.ConeGeometry(headRadius * 0.35, headRadius * 0.7, 5);\n    const snout = addMesh(snoutGeo, headColor, headEmissive, 0.5, group,\n      0, headY - headRadius * 0.15, -(headRadius + headRadius * 0.15));\n    snout.rotation.x = -Math.PI / 2;\n  }\n\n  if (sil.extras.includes('ears')) {\n    const earGeo = new THREE.ConeGeometry(headRadius * 0.25, headRadius * 0.7, 4);\n\n    const earL = addMesh(earGeo, headColor, headEmissive, 0.5, group,\n      -(headRadius + headRadius * 0.1), headY + headRadius * 0.3, 0);\n    earL.rotation.z = Math.PI / 2 + 0.4;\n\n    const earR = addMesh(earGeo, headColor, headEmissive, 0.5, group,\n      (headRadius + headRadius * 0.1), headY + headRadius * 0.3, 0);\n    earR.rotation.z = -(Math.PI / 2 + 0.4);\n  }\n\n  if (sil.extras.includes('bow')) {\n    const bowGeo = new THREE.BoxGeometry(armW * 0.4, h * 0.35, armW * 0.8);\n    addMesh(bowGeo, darkenColor(bodyColor, 0.4), darkenColor(bodyEmissive, 0.4), 0.3, group,\n      -(torsoW / 2 + armW * 1.5), shoulderY - armLen * 0.4, -r * 0.4);\n  }\n\n  if (sil.extras.includes('ribs')) {\n    const ribColor = brightenColor(bodyColor, 0.15);\n    const ribEmissive = brightenColor(bodyEmissive, 0.1);\n    for (let i = 0; i < 3; i++) {\n      const ribGeo = new THREE.BoxGeometry(torsoW * 1.15, h * 0.012, torsoD * 0.6);\n      const ribY = torsoY + torsoH * (0.25 - i * 0.25);\n      addMesh(ribGeo, ribColor, ribEmissive, 0.3, group, 0, ribY, 0);\n    }\n  }\n\n  if (sil.extras.includes('hat')) {\n    const hatGeo = new THREE.ConeGeometry(headRadius * 0.9, h * 0.28, 6);\n    const hat = addMesh(hatGeo, darkenColor(bodyColor, 0.25), darkenColor(bodyEmissive, 0.25), 0.4, group,\n      0, headY + headRadius * 0.6 + h * 0.1, 0);\n    hat.rotation.z = 0.15; // jaunty tilt\n  }\n\n  if (sil.extras.includes('shoulders')) {\n    const shW = torsoW * 0.4;\n    const shH = torsoH * 0.25;\n    const shGeo = new THREE.BoxGeometry(shW, shH, shW);\n\n    addMesh(shGeo, darkenColor(bodyColor, 0.1), darkenColor(bodyEmissive, 0.1), 0.35, group,\n      -(torsoW / 2 + shW * 0.1), shoulderY + shH * 0.5, 0);\n    addMesh(shGeo, darkenColor(bodyColor, 0.1), darkenColor(bodyEmissive, 0.1), 0.35, group,\n      (torsoW / 2 + shW * 0.1), shoulderY + shH * 0.5, 0);\n  }\n\n  return { bodyMesh, headMesh, allMeshes, allMaterials };\n}\n\n// \u2500\u2500\u2500 Hit Reaction \u2500\u2500\u2500\n// Shared squash/bounce on damage \u2014 applied to any enemy mesh group.\n// Call triggerHitReaction on damage, updateHitReaction each frame.\n\nexport interface HitReactionState {\n  active: boolean;\n  timer: number;      // seconds elapsed\n  duration: number;   // total duration (seconds)\n}\n\nexport function createHitReaction(): HitReactionState {\n  return { active: false, timer: 0, duration: 0.12 };\n}\n\nexport function triggerHitReaction(state: HitReactionState) {\n  state.active = true;\n  state.timer = 0;\n}\n\nexport function updateHitReaction(state: HitReactionState, meshGroup: any, dt: number) {\n  if (!state.active) return;\n\n  state.timer += dt;\n  const t = Math.min(state.timer / state.duration, 1);\n\n  if (t < 0.3) {\n    // Squash phase \u2014 compress vertically, widen\n    const squashT = t / 0.3;\n    meshGroup.scale.set(1 + 0.12 * squashT, 1 - 0.15 * squashT, 1 + 0.12 * squashT);\n  } else {\n    // Bounce back \u2014 overshoot slightly then settle\n    const bounceT = (t - 0.3) / 0.7;\n    const ease = 1 - Math.pow(1 - bounceT, 3); // ease out cubic\n    const overshoot = bounceT < 0.5 ? 1.06 : 1 + 0.06 * (1 - (bounceT - 0.5) * 2);\n    const scaleY = (1 - 0.15) + (overshoot - (1 - 0.15)) * ease;\n    const scaleXZ = (1 + 0.12) + (1 - (1 + 0.12)) * ease;\n    meshGroup.scale.set(scaleXZ, scaleY, scaleXZ);\n  }\n\n  if (t >= 1) {\n    state.active = false;\n    meshGroup.scale.set(1, 1, 1);\n  }\n}\n", "// Event Bus \u2014 lightweight pub/sub for game events\n// Systems emit events at key moments (damage, death, dash, etc.)\n// Other systems subscribe to react (audio, particles, screen effects)\n// Existing side effects (damage numbers, screen shake) are NOT migrated \u2014\n// the bus is additive. New systems subscribe; old ones stay as-is.\n\n// \u2500\u2500\u2500 Event Types \u2500\u2500\u2500\n\nexport type GameEvent =\n  | { type: 'enemyHit'; enemy: any; damage: number; position: { x: number; z: number }; wasShielded: boolean }\n  | { type: 'enemyDied'; enemy: any; position: { x: number; z: number } }\n  | { type: 'playerHit'; damage: number; position: { x: number; z: number } }\n  | { type: 'playerDash'; direction: { x: number; z: number }; position: { x: number; z: number } }\n  | { type: 'playerDashEnd' }\n  | { type: 'waveCleared'; waveIndex: number }\n  | { type: 'waveBegan'; waveIndex: number }\n  | { type: 'shieldBreak'; enemy: any; position: { x: number; z: number } }\n  | { type: 'chargeFired'; chargeT: number; direction: { x: number; z: number }; position: { x: number; z: number } }\n  | { type: 'enemyPushed'; enemy: any; position: { x: number; z: number } }\n  | { type: 'pitFall'; position: { x: number; z: number }; isPlayer: boolean }\n  | { type: 'meleeSwing'; position: { x: number; z: number }; direction: { x: number; z: number } }\n  | { type: 'meleeHit'; enemy: any; damage: number; position: { x: number; z: number } }\n  | { type: 'roomCleared'; roomIndex: number }\n  | { type: 'roomClearComplete'; roomIndex: number }\n  | { type: 'doorUnlocked'; roomIndex: number }\n  | { type: 'doorEntered'; roomIndex: number }\n  | { type: 'spawnPackTelegraph'; packIndex: number; roomIndex: number }\n  | { type: 'spawnPackSpawned'; packIndex: number; roomIndex: number }\n  | { type: 'restRoomEntered'; roomIndex: number }\n  | { type: 'playerHealed'; amount: number; position: { x: number; z: number } }\n  | { type: 'enemyMeleeTelegraph'; position: { x: number; z: number }; facingAngle: number; hitArc: number; hitRange: number; duration: number }\n  | { type: 'wallSlam'; enemy: any; speed: number; damage: number; position: { x: number; z: number } }\n  | { type: 'enemyImpact'; enemyA: any; enemyB: any; speed: number; damage: number; position: { x: number; z: number } }\n  | { type: 'enemyAggroed'; enemy: any; position: { x: number; z: number } }\n  | { type: 'detectionStarted'; enemy: any; position: { x: number; z: number } }\n  | { type: 'detectionCleared'; enemy: any; position: { x: number; z: number } }\n  | { type: 'bulletTimeActivated' }\n  | { type: 'bulletTimeDeactivated' }\n  | { type: 'playerJump'; position: { x: number; z: number } }\n  | { type: 'playerLand'; position: { x: number; z: number }; fallSpeed: number }\n  | { type: 'enemyLaunched'; enemy: any; position: { x: number; z: number }; velocity: number }\n  | { type: 'aerialStrike'; enemy: any; damage: number; position: { x: number; z: number } }\n  | { type: 'playerSlam'; position: { x: number; z: number }; fallSpeed: number }\n  | { type: 'dunkGrab'; enemy: any; position: { x: number; z: number } }\n  | { type: 'dunkImpact'; enemy: any; damage: number; position: { x: number; z: number } }\n  | { type: 'spikeStrike'; enemy: any; damage: number; position: { x: number; z: number } }\n  | { type: 'spikeThrough'; enemy: any; damage: number; position: { x: number; z: number } }\n  | { type: 'spikeImpact'; position: { x: number; z: number }; damage: number; radius: number }\n  | { type: 'bendModeActivated' }\n  | { type: 'bendModeDeactivated' }\n  | { type: 'bendApplied'; bendId: string; targetType: string; targetId: number; position: { x: number; z: number } }\n  | { type: 'bendFailed'; bendId: string; reason: string }\n  | { type: 'objectPitFall'; object: any; position: { x: number; z: number } }\n  | { type: 'objectWallSlam'; object: any; speed: number; damage: number; position: { x: number; z: number } }\n  | { type: 'objectDestroyed'; object: any; position: { x: number; z: number } }\n  | { type: 'objectImpact'; objectA: any; objectB: any; speed: number; damage: number; position: { x: number; z: number } }\n  | { type: 'objectPushed'; object: any; position: { x: number; z: number } }\n  | { type: 'pressurePlateActivated'; position: { x: number; z: number } }\n  | { type: 'objectDropped'; position: { x: number; z: number } };\n\n// \u2500\u2500\u2500 Bus Implementation \u2500\u2500\u2500\n\ntype EventType = GameEvent['type'];\ntype ListenerFn = (event: GameEvent) => void;\n\nconst listeners: Map<EventType, Set<ListenerFn>> = new Map();\n\nexport function emit(event: GameEvent): void {\n  const set = listeners.get(event.type);\n  if (!set) return;\n  for (const fn of set) {\n    fn(event);\n  }\n}\n\nexport function on(type: EventType, callback: ListenerFn): void {\n  let set = listeners.get(type);\n  if (!set) {\n    set = new Set();\n    listeners.set(type, set);\n  }\n  set.add(callback);\n}\n\nexport function off(type: EventType, callback: ListenerFn): void {\n  const set = listeners.get(type);\n  if (set) {\n    set.delete(callback);\n  }\n}\n\n// Clear all listeners \u2014 call on game reset if needed\nexport function clearAllListeners(): void {\n  listeners.clear();\n}\n", "// Gameplay Tag System \u2014 lightweight hierarchical labels for state management.\n// Inspired by Unreal GAS Gameplay Tags. Any system can add/remove tags on any\n// owner (player, enemy, zone). Other systems query tags for activation conditions,\n// blocking rules, and state differentiation.\n//\n// Tags are dot-separated strings: \"State.Aerial.Float\"\n// Hierarchical matching: hasTag(owner, \"State.Aerial\") returns true if owner has\n// \"State.Aerial\" OR any child like \"State.Aerial.Float\".\n\n// \u2500\u2500\u2500 Per-Owner Storage \u2500\u2500\u2500\n\nconst tagSets = new Map<any, Set<string>>();\n\nfunction ensureSet(owner: any): Set<string> {\n  let set = tagSets.get(owner);\n  if (!set) {\n    set = new Set();\n    tagSets.set(owner, set);\n  }\n  return set;\n}\n\n// \u2500\u2500\u2500 Core API \u2500\u2500\u2500\n\nexport function addTag(owner: any, tag: string): void {\n  ensureSet(owner).add(tag);\n}\n\nexport function removeTag(owner: any, tag: string): void {\n  const set = tagSets.get(owner);\n  if (set) set.delete(tag);\n}\n\n/** Exact match only \u2014 \"State.Aerial\" does NOT match \"State.Aerial.Float\" */\nexport function hasExactTag(owner: any, tag: string): boolean {\n  const set = tagSets.get(owner);\n  return set ? set.has(tag) : false;\n}\n\n/** Hierarchical match \u2014 hasTag(o, \"State.Aerial\") matches \"State.Aerial\"\n *  or any child like \"State.Aerial.Float\", \"State.Aerial.Dunk\", etc. */\nexport function hasTag(owner: any, tag: string): boolean {\n  const set = tagSets.get(owner);\n  if (!set) return false;\n  if (set.has(tag)) return true;\n  const prefix = tag + '.';\n  for (const t of set) {\n    if (t.startsWith(prefix)) return true;\n  }\n  return false;\n}\n\n/** True if owner has ANY of the given tags (hierarchical match) */\nexport function hasAnyTag(owner: any, tags: string[]): boolean {\n  return tags.some(t => hasTag(owner, t));\n}\n\n/** True if owner has ALL of the given tags (hierarchical match) */\nexport function hasAllTags(owner: any, tags: string[]): boolean {\n  return tags.every(t => hasTag(owner, t));\n}\n\n/** Remove exact tag + all children matching prefix */\nexport function removeTagsMatching(owner: any, prefix: string): void {\n  const set = tagSets.get(owner);\n  if (!set) return;\n  const dotPrefix = prefix + '.';\n  for (const tag of [...set]) {\n    if (tag === prefix || tag.startsWith(dotPrefix)) {\n      set.delete(tag);\n    }\n  }\n}\n\n/** Get all tags on an owner (debugging / tuning panel) */\nexport function getTags(owner: any): string[] {\n  const set = tagSets.get(owner);\n  return set ? [...set] : [];\n}\n\n/** Remove all tags from an owner */\nexport function clearTags(owner: any): void {\n  tagSets.delete(owner);\n}\n\n/** Remove all tags from all owners (game reset) */\nexport function clearAllTags(): void {\n  tagSets.clear();\n}\n\n// \u2500\u2500\u2500 Player Convenience API \u2500\u2500\u2500\n// Single-player game \u2014 avoid passing owner for every player tag query.\n\nconst PLAYER_OWNER = Symbol('player');\n\nexport function addPlayerTag(tag: string): void {\n  addTag(PLAYER_OWNER, tag);\n}\n\nexport function removePlayerTag(tag: string): void {\n  removeTag(PLAYER_OWNER, tag);\n}\n\nexport function playerHasTag(tag: string): boolean {\n  return hasTag(PLAYER_OWNER, tag);\n}\n\nexport function removePlayerTagsMatching(prefix: string): void {\n  removeTagsMatching(PLAYER_OWNER, prefix);\n}\n\nexport function clearPlayerTags(): void {\n  clearTags(PLAYER_OWNER);\n}\n\nexport function getPlayerTags(): string[] {\n  return getTags(PLAYER_OWNER);\n}\n\n// \u2500\u2500\u2500 Well-Known Tag Constants \u2500\u2500\u2500\n// Centralized to prevent typos. Add new tags here as systems grow.\n\nexport const TAG = {\n  // Aerial verb states (added/removed by aerial verb framework)\n  AERIAL:         'State.Aerial',\n  AERIAL_RISING:  'State.Aerial.Rising',\n  AERIAL_FLOAT:   'State.Aerial.Float',\n  AERIAL_DUNK:    'State.Aerial.Dunk',\n  AERIAL_SPIKE:   'State.Aerial.Spike',\n\n  // General player states (future \u2014 wire these as needed)\n  AIRBORNE:       'State.Airborne',\n\n  // Shared states (applicable to any entity)\n  STUNNED:        'State.Stunned',\n} as const;\n", "// Profile Manager \u2014 switches active profile between rooms\n// Each profile represents a different prototype branch's mechanics.\n// Cleanup/setup hooks let future phases register branch-specific teardown.\n\nimport type { PlayerProfile } from '../types/index';\n\nexport type ProfileCleanupFn = () => void;\nexport type ProfileSetupFn = () => void;\n\nexport interface ProfileHooks {\n  cleanup: ProfileCleanupFn;\n  setup: ProfileSetupFn;\n}\n\nlet activeProfile: PlayerProfile = 'base';\nlet currentHooks: ProfileHooks | null = null;\n\nexport function getActiveProfile(): PlayerProfile {\n  return activeProfile;\n}\n\nexport function setProfile(profile: PlayerProfile, hooks?: ProfileHooks): void {\n  // Cleanup old profile\n  if (currentHooks) {\n    currentHooks.cleanup();\n  }\n\n  activeProfile = profile;\n  currentHooks = hooks ?? null;\n\n  // Setup new profile\n  if (currentHooks) {\n    currentHooks.setup();\n  }\n}\n\nexport function resetProfile(): void {\n  if (currentHooks) {\n    currentHooks.cleanup();\n  }\n  activeProfile = 'base';\n  currentHooks = null;\n}\n", "// Vision Cone Overlay \u2014 flat transparent wedge on ground showing enemy detection cone\n// Aggro is directional: enemies only detect the player inside their facing cone + LOS\n// Color: green (idle) \u2192 yellow/orange/red (detecting) \u2192 red flash (aggroed) \u2192 fade out\n// Visual occlusion: cone vertices are pulled inward when walls block line of sight\n\n// Raycast function injected at init time to avoid pulling in enemy.ts (and THREE)\n// at module-level \u2014 that breaks tests that import VISION_CONE_CONFIG without THREE.\ntype RaycastFn = (ox: number, oz: number, dx: number, dz: number, maxDist: number) => number;\nlet raycastFn: RaycastFn | null = null;\n\nexport const VISION_CONE_CONFIG = {\n  angle: Math.PI / 3 * 0.8,   // ~48\u00B0 cone (20% narrower than 60\u00B0)\n  segments: 16,                 // geometry resolution\n  opacity: 0.08,                // idle cone opacity\n  idleColor: 0x44ff88,          // green\n  detectColor1: 0xffee44,       // yellow (detection start)\n  detectColor2: 0xff8800,       // orange (detection mid)\n  aggroColor: 0xff4444,         // red (detection full / aggroed)\n  fadeAfterAggro: 1000,         // ms \u2014 fade duration after aggro flash\n  aggroHoldDuration: 250,       // ms \u2014 red flash holds at full before fading\n  detectionThreshold: 350,      // ms \u2014 player must be in cone this long to trigger aggro\n  idleTurnRate: 0.4,            // rad/s \u2014 how fast idle enemies scan back and forth\n  idleScanArc: Math.PI / 3,    // \u00B160\u00B0 sweep from initial facing while idle\n  turnSpeed: 3.0,               // rad/s \u2014 how fast enemies rotate toward their target facing (all states)\n};\n\nlet sceneRef: any = null;\n\n// Per-enemy cone data\ninterface ConeData {\n  mesh: any;\n  basePositions: Float32Array;  // original unclipped vertex positions (for resetting each frame)\n  geoAngle: number;             // angle when geometry was created (to detect tuning changes)\n  aggroTimer: number;   // ms remaining for aggro flash fade\n  holdTimer: number;    // ms remaining for aggro hold before fade\n  wasAggroed: boolean;  // track when aggro state changes\n}\n\nconst coneMap = new Map<any, ConeData>();\n\n// Cache geometry keyed by angle (so tuning panel changes rebuild it)\nlet cachedGeo: any = null;\nlet cachedGeoAngle = 0;\n\nexport function initVisionCones(scene: any, raycast?: RaycastFn) {\n  sceneRef = scene;\n  if (raycast) raycastFn = raycast;\n}\n\nfunction getConeGeo(): any {\n  const angle = VISION_CONE_CONFIG.angle;\n  if (cachedGeo && Math.abs(cachedGeoAngle - angle) < 0.001) {\n    return cachedGeo;\n  }\n  if (cachedGeo) cachedGeo.dispose();\n\n  // Arc centered at PI/2 in XY plane \u2192 points +Z after rotateX(-PI/2).\n  // Model faces -Z, but cone copies mesh.rotation.y directly, so the rotation\n  // naturally aligns them (rotation.y rotates both by the same amount).\n  cachedGeo = new THREE.CircleGeometry(\n    1,\n    VISION_CONE_CONFIG.segments,\n    Math.PI / 2 - angle / 2,\n    angle\n  );\n  cachedGeo.rotateX(-Math.PI / 2);\n  cachedGeoAngle = angle;\n  return cachedGeo;\n}\n\n/** Clone the cached geometry and snapshot its base positions for occlusion resets. */\nfunction cloneConeGeo(): { geo: any; basePositions: Float32Array } {\n  const geo = getConeGeo().clone();\n  const basePositions = new Float32Array(geo.attributes.position.array);\n  return { geo, basePositions };\n}\n\n/**\n * Check if a point is inside an enemy's vision cone (distance + angle only, no LOS).\n * rotationY is the enemy's mesh.rotation.y (single source of truth for facing).\n */\nexport function isInsideVisionCone(\n  enemyX: number, enemyZ: number,\n  rotationY: number,\n  targetX: number, targetZ: number,\n  radius: number\n): boolean {\n  const dx = targetX - enemyX;\n  const dz = targetZ - enemyZ;\n  const distSq = dx * dx + dz * dz;\n\n  if (distSq > radius * radius) return false;\n\n  // atan2(-dx, -dz) converts a direction vector to rotation.y space\n  const angleToTarget = Math.atan2(-dx, -dz);\n  let angleDiff = angleToTarget - rotationY;\n  while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;\n  while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;\n\n  const halfAngle = VISION_CONE_CONFIG.angle / 2;\n  return Math.abs(angleDiff) <= halfAngle;\n}\n\n/**\n * Update cone color based on detection timer progress (0\u21921).\n * Green \u2192 yellow \u2192 orange \u2192 red as detection builds.\n */\nfunction updateDetectionColor(data: ConeData, detectionT: number) {\n  if (detectionT <= 0) {\n    // Idle \u2014 green\n    data.mesh.material.color.setHex(VISION_CONE_CONFIG.idleColor);\n    data.mesh.material.opacity = VISION_CONE_CONFIG.opacity;\n  } else if (detectionT < 0.5) {\n    // First half: green \u2192 yellow \u2192 orange\n    const t = detectionT * 2; // 0\u21921 over first half\n    lerpColor(data.mesh.material.color, VISION_CONE_CONFIG.detectColor1, VISION_CONE_CONFIG.detectColor2, t);\n    data.mesh.material.opacity = VISION_CONE_CONFIG.opacity + t * 0.12; // brighten\n  } else {\n    // Second half: orange \u2192 red\n    const t = (detectionT - 0.5) * 2; // 0\u21921 over second half\n    lerpColor(data.mesh.material.color, VISION_CONE_CONFIG.detectColor2, VISION_CONE_CONFIG.aggroColor, t);\n    data.mesh.material.opacity = VISION_CONE_CONFIG.opacity + 0.12 + t * 0.05;\n  }\n}\n\n// Helper: lerp between two hex colors\nconst _c1 = { r: 0, g: 0, b: 0 };\nconst _c2 = { r: 0, g: 0, b: 0 };\n\nfunction lerpColor(target: any, hex1: number, hex2: number, t: number) {\n  _c1.r = (hex1 >> 16) & 0xff;\n  _c1.g = (hex1 >> 8) & 0xff;\n  _c1.b = hex1 & 0xff;\n  _c2.r = (hex2 >> 16) & 0xff;\n  _c2.g = (hex2 >> 8) & 0xff;\n  _c2.b = hex2 & 0xff;\n\n  const r = Math.round(_c1.r + (_c2.r - _c1.r) * t);\n  const g = Math.round(_c1.g + (_c2.g - _c1.g) * t);\n  const b = Math.round(_c1.b + (_c2.b - _c1.b) * t);\n\n  target.setRGB(r / 255, g / 255, b / 255);\n}\n\nexport function addVisionCone(enemy: any) {\n  if (!sceneRef) return;\n  if (coneMap.has(enemy)) return;\n\n  const aggroRadius = enemy.config.aggroRadius;\n  if (!aggroRadius || aggroRadius <= 0) return;\n\n  // Initialize facing if not already set by spawnEnemy\n  if (!enemy._facingInitialized) {\n    enemy.mesh.rotation.y = (Math.random() - 0.5) * Math.PI * 2;\n    enemy.idleBaseRotY = enemy.mesh.rotation.y;\n    enemy.idleScanPhase = Math.random() * Math.PI * 2;\n    enemy._facingInitialized = true;\n  }\n\n  // Each enemy gets its own geometry clone so vertices can be independently\n  // modified for LOS occlusion (pulling vertices inward at wall hits).\n  const { geo, basePositions } = cloneConeGeo();\n  const mat = new THREE.MeshBasicMaterial({\n    color: VISION_CONE_CONFIG.idleColor,\n    transparent: true,\n    opacity: VISION_CONE_CONFIG.opacity,\n    side: THREE.DoubleSide,\n    depthWrite: false,\n  });\n\n  const mesh = new THREE.Mesh(geo, mat);\n  mesh.scale.set(aggroRadius, 1, aggroRadius);\n  mesh.position.set(enemy.pos.x, 0.02, enemy.pos.z);\n  mesh.renderOrder = -1;\n\n  sceneRef.add(mesh);\n  coneMap.set(enemy, {\n    mesh,\n    basePositions,\n    geoAngle: cachedGeoAngle,\n    aggroTimer: 0,\n    holdTimer: 0,\n    wasAggroed: false,\n  });\n}\n\n/**\n * Update idle scan facing for non-aggroed, non-patrolling enemies.\n * Must be called BEFORE aggro checks so mesh.rotation.y matches the visual cone.\n */\nexport function updateIdleFacing(enemies: any[], dt: number) {\n  for (const enemy of enemies) {\n    if (!enemy.aggroed && enemy.idleBaseRotY != null && !enemy.config.patrol) {\n      enemy.idleScanPhase = (enemy.idleScanPhase || 0) + dt * VISION_CONE_CONFIG.idleTurnRate;\n      enemy.mesh.rotation.y = enemy.idleBaseRotY + Math.sin(enemy.idleScanPhase) * VISION_CONE_CONFIG.idleScanArc;\n    }\n  }\n}\n\n/**\n * Clip cone vertices to terrain \u2014 pull perimeter vertices inward where walls block LOS.\n * Raycasts from enemy center toward each vertex direction; if a wall is closer than\n * the cone radius, the vertex is scaled inward to the hit distance.\n */\nfunction updateConeOcclusion(data: ConeData, enemy: any) {\n  if (!raycastFn) return; // no raycast function injected yet\n  const positions = data.mesh.geometry.attributes.position.array as Float32Array;\n  const base = data.basePositions;\n  const aggroRadius = enemy.config.aggroRadius;\n  const rotY = enemy.mesh.rotation.y;\n  const cosR = Math.cos(rotY);\n  const sinR = Math.sin(rotY);\n  const segments = VISION_CONE_CONFIG.segments;\n\n  // Vertex 0 is the center (always at origin in local space) \u2014 skip it.\n  // Vertices 1..segments+1 are the perimeter points.\n  for (let i = 1; i <= segments + 1; i++) {\n    const bx = base[i * 3 + 0]; // unit-radius local X\n    const bz = base[i * 3 + 2]; // unit-radius local Z\n\n    // Rotate local direction by mesh.rotation.y to get world direction\n    const worldDirX = bx * cosR + bz * sinR;\n    const worldDirZ = -bx * sinR + bz * cosR;\n\n    // Normalize (vertices are at unit radius, but rotateX may have shifted things slightly)\n    const len = Math.sqrt(worldDirX * worldDirX + worldDirZ * worldDirZ);\n    if (len < 0.001) continue; // degenerate vertex, skip\n\n    const ndx = worldDirX / len;\n    const ndz = worldDirZ / len;\n\n    // Raycast from enemy center in this direction\n    const hitDist = raycastFn!(enemy.pos.x, enemy.pos.z, ndx, ndz, aggroRadius);\n\n    // Scale vertex: hitDist / aggroRadius gives the fraction of full reach\n    // (mesh.scale already multiplies local coords by aggroRadius)\n    const scale = Math.min(hitDist / aggroRadius, 1.0);\n    positions[i * 3 + 0] = bx * scale;\n    positions[i * 3 + 2] = bz * scale;\n  }\n\n  data.mesh.geometry.attributes.position.needsUpdate = true;\n}\n\nexport function updateVisionCones(enemies: any[], dt: number) {\n  // Check if cone angle changed via tuning panel \u2014 rebuild base geometry if needed\n  getConeGeo(); // ensures cachedGeoAngle is current\n\n  for (const enemy of enemies) {\n    const data = coneMap.get(enemy);\n    if (!data) continue;\n\n    // If cone angle changed via tuning panel, re-clone geometry\n    if (Math.abs(data.geoAngle - cachedGeoAngle) > 0.001) {\n      data.mesh.geometry.dispose();\n      const { geo, basePositions } = cloneConeGeo();\n      data.mesh.geometry = geo;\n      data.basePositions = basePositions;\n      data.geoAngle = cachedGeoAngle;\n    }\n\n    // Update position\n    data.mesh.position.set(enemy.pos.x, 0.02, enemy.pos.z);\n\n    // Update scale if aggro radius changed via tuning panel\n    const aggroRadius = enemy.config.aggroRadius;\n    if (aggroRadius && aggroRadius > 0) {\n      data.mesh.scale.set(aggroRadius, 1, aggroRadius);\n    }\n\n    // Rotate cone to match enemy model \u2014 just copy the model's rotation directly.\n    // This guarantees cone and model always point the same direction.\n    data.mesh.rotation.y = enemy.mesh.rotation.y;\n\n    // Visual LOS occlusion \u2014 clip cone at walls (skip for aggroed cones that are fading)\n    if (!data.wasAggroed && aggroRadius > 0) {\n      updateConeOcclusion(data, enemy);\n    }\n\n    // Detection timer color transition (while not yet aggroed)\n    if (!enemy.aggroed && !data.wasAggroed) {\n      const threshold = VISION_CONE_CONFIG.detectionThreshold;\n      const detectionT = threshold > 0\n        ? Math.min((enemy.detectionTimer || 0) / threshold, 1)\n        : 0;\n      updateDetectionColor(data, detectionT);\n    }\n\n    // Handle aggro state change\n    if (enemy.aggroed && !data.wasAggroed) {\n      data.wasAggroed = true;\n      data.holdTimer = VISION_CONE_CONFIG.aggroHoldDuration;\n      data.aggroTimer = VISION_CONE_CONFIG.fadeAfterAggro;\n      data.mesh.material.color.setHex(VISION_CONE_CONFIG.aggroColor);\n      data.mesh.material.opacity = 0.25;\n    }\n\n    // Aggro flash: hold \u2192 fade \u2192 hide\n    if (data.wasAggroed) {\n      if (data.holdTimer > 0) {\n        // Hold at full red\n        data.holdTimer -= dt * 1000;\n      } else if (data.aggroTimer > 0) {\n        // Fade out\n        data.aggroTimer -= dt * 1000;\n        const fadeT = Math.max(0, data.aggroTimer / VISION_CONE_CONFIG.fadeAfterAggro);\n        data.mesh.material.opacity = 0.25 * fadeT;\n\n        if (data.aggroTimer <= 0) {\n          data.mesh.visible = false;\n        }\n      }\n    }\n  }\n}\n\nexport function removeVisionCone(enemy: any) {\n  const data = coneMap.get(enemy);\n  if (!data) return;\n\n  if (sceneRef) {\n    sceneRef.remove(data.mesh);\n  }\n  data.mesh.geometry.dispose();\n  data.mesh.material.dispose();\n  coneMap.delete(enemy);\n}\n\nexport function clearVisionCones() {\n  for (const [enemy, data] of coneMap) {\n    if (sceneRef) {\n      sceneRef.remove(data.mesh);\n    }\n    data.mesh.geometry.dispose();\n    data.mesh.material.dispose();\n  }\n  coneMap.clear();\n}\n", "import { ENEMY_TYPES, MOB_GLOBAL } from '../config/enemies';\nimport { getCollisionBounds, getPitBounds } from '../config/arena';\nimport { getGroundHeight } from '../config/terrain';\nimport { applyAoeEffect } from '../engine/aoeTelegraph';\nimport { getPlayerPos, isPlayerInvincible } from './player';\nimport { screenShake } from '../engine/renderer';\nimport { spawnDamageNumber } from '../ui/damageNumbers';\nimport { fireMortarProjectile, getIceEffects } from './mortarProjectile';\nimport { fireProjectile } from './projectile';\nimport { buildEnemyModel, createHitReaction, triggerHitReaction, updateHitReaction } from './enemyRig';\nimport { emit, on } from '../engine/events';\nimport { hasTag, TAG } from '../engine/tags';\nimport { getActiveProfile } from '../engine/profileManager';\nimport {\n  initVisionCones, addVisionCone, updateVisionCones,\n  updateIdleFacing, removeVisionCone, clearVisionCones,\n  isInsideVisionCone, VISION_CONE_CONFIG\n} from '../engine/visionCone';\nimport { ARENA_HALF_X, ARENA_HALF_Z } from '../config/arena';\n\nlet sceneRef: any;\n\n// Shared shield geometry (created once)\nlet shieldGeo: any;\n\n// Shared mortar fill circle geometry\nlet _mortarFillGeoShared: any = null;\n\n// Shared death telegraph fill geometry\nlet _deathFillGeoShared: any = null;\n\n// \u2500\u2500\u2500 Aggro Indicator (\"!\" pop above enemy on detection) \u2500\u2500\u2500\n\nconst AGGRO_IND = {\n  heightAbove: 2.2,\n  popDuration: 120,\n  holdDuration: 600,\n  fadeDuration: 400,\n  bobSpeed: 6,\n  bobAmp: 0.08,\n};\n\ninterface AggroIndicator {\n  mesh: any;\n  phase: 'pop' | 'hold' | 'fade';\n  timer: number;\n  enemy: any;\n}\n\nconst aggroIndicators: AggroIndicator[] = [];\n\nfunction showAggroIndicator(enemy: any) {\n  if (!sceneRef) return;\n\n  const group = new THREE.Group();\n  const coneGeo = new THREE.ConeGeometry(0.12, 0.5, 6);\n  const mat = new THREE.MeshStandardMaterial({\n    color: 0xff4444, emissive: 0xff2222, emissiveIntensity: 0.8,\n    transparent: true, opacity: 1,\n  });\n  const cone = new THREE.Mesh(coneGeo, mat);\n  cone.position.y = 0.15;\n  group.add(cone);\n\n  const dotGeo = new THREE.SphereGeometry(0.08, 6, 6);\n  const dot = new THREE.Mesh(dotGeo, mat.clone());\n  dot.position.y = -0.2;\n  group.add(dot);\n\n  group.position.set(enemy.pos.x, enemy.config.size.height + AGGRO_IND.heightAbove, enemy.pos.z);\n  group.scale.set(0, 0, 0);\n  sceneRef.add(group);\n\n  aggroIndicators.push({ mesh: group, phase: 'pop', timer: AGGRO_IND.popDuration, enemy });\n}\n\nfunction updateAggroIndicators(dt: number) {\n  for (let i = aggroIndicators.length - 1; i >= 0; i--) {\n    const ind = aggroIndicators[i];\n    ind.timer -= dt * 1000;\n    ind.mesh.position.x = ind.enemy.pos.x;\n    ind.mesh.position.z = ind.enemy.pos.z;\n\n    if (ind.phase === 'pop') {\n      const t = 1 - ind.timer / AGGRO_IND.popDuration;\n      const s = t < 0.7 ? (t / 0.7) * 1.4 : 1.4 - (t - 0.7) / 0.3 * 0.4;\n      ind.mesh.scale.set(s, s, s);\n      if (ind.timer <= 0) { ind.phase = 'hold'; ind.timer = AGGRO_IND.holdDuration; ind.mesh.scale.set(1, 1, 1); }\n    } else if (ind.phase === 'hold') {\n      const bob = Math.sin(Date.now() * 0.001 * AGGRO_IND.bobSpeed) * AGGRO_IND.bobAmp;\n      ind.mesh.position.y = ind.enemy.config.size.height + AGGRO_IND.heightAbove + bob;\n      if (ind.timer <= 0) { ind.phase = 'fade'; ind.timer = AGGRO_IND.fadeDuration; }\n    } else {\n      const fadeT = Math.max(0, ind.timer / AGGRO_IND.fadeDuration);\n      ind.mesh.scale.set(fadeT, fadeT, fadeT);\n      ind.mesh.children.forEach((c: any) => { if (c.material) c.material.opacity = fadeT; });\n      if (ind.timer <= 0) {\n        sceneRef.remove(ind.mesh);\n        aggroIndicators.splice(i, 1);\n      }\n    }\n  }\n}\n\nfunction clearAggroIndicators() {\n  for (const ind of aggroIndicators) {\n    if (sceneRef) sceneRef.remove(ind.mesh);\n  }\n  aggroIndicators.length = 0;\n}\n\nconst PUSH_AGGRO_DELAY = 250; // ms after being pushed before goblin aggros\n\nexport function initEnemySystem(scene: any) {\n  sceneRef = scene;\n\n  // Delayed aggro when pushed \u2014 assassin goblins aggro 250ms after force push\n  on('enemyPushed', (e) => {\n    if (e.type !== 'enemyPushed') return;\n    const enemy = e.enemy;\n    if (!enemy.aggroed && enemy.config.aggroRadius && getActiveProfile() === 'assassin') {\n      enemy.pushAggroTimer = PUSH_AGGRO_DELAY;\n    }\n  });\n}\n\nfunction createShieldMesh(cfg: any) {\n  const shieldCfg = cfg.shield;\n  const radius = cfg.size.radius * 1.8;\n  if (!shieldGeo) shieldGeo = new THREE.SphereGeometry(1, 16, 12); // unit sphere, scaled per enemy\n  const mat = new THREE.MeshStandardMaterial({\n    color: shieldCfg.color || 0x88eeff,\n    emissive: shieldCfg.emissive || 0x44ccff,\n    emissiveIntensity: 0.4,\n    transparent: true,\n    opacity: shieldCfg.opacity || 0.35,\n    side: THREE.DoubleSide,\n    depthWrite: false,\n  });\n  const mesh = new THREE.Mesh(shieldGeo, mat);\n  mesh.scale.set(radius, radius, radius);\n  return mesh;\n}\n\nexport function spawnEnemy(typeName: string, position: any, gameState: any, patrolWaypoints?: { x: number; z: number }[]) {\n  const cfg = ENEMY_TYPES[typeName];\n  if (!cfg) return null;\n\n  const group = new THREE.Group();\n\n  // Build distinctive silhouette from primitives\n  const model = buildEnemyModel(typeName, cfg, group);\n  const bodyMesh = model.bodyMesh;\n  const headMesh = model.headMesh;\n\n  group.position.copy(position);\n  sceneRef.add(group);\n\n  const enemy: any = {\n    mesh: group,\n    bodyMesh,\n    headMesh,\n    type: typeName,\n    config: cfg,\n    health: cfg.health,\n    pos: position.clone(),\n    behavior: cfg.behavior,\n    lastAttackTime: 0,\n    flashTimer: 0,\n    stunTimer: 0,\n    // Tank-specific\n    chargeTimer: 0,\n    chargeCooldown: 4000,\n    isCharging: false,\n    chargeDir: new THREE.Vector3(),\n    // Shield\n    shieldHealth: 0,\n    shieldActive: false,\n    shieldMesh: null as any,\n    // Slow debuff\n    slowTimer: 0,\n    slowMult: 1,               // speed multiplier while slowed (e.g., 0.5 = half speed)\n    // Sniper (kite behavior)\n    sniperPhase: 'idle',       // 'idle' | 'telegraphing' | 'cooldown'\n    sniperTimer: 0,\n    sniperAimAngle: 0,         // locked aim direction (radians)\n    sniperAimCenter: { x: 0, z: 0 }, // center of the damage rect\n    // Mortar\n    mortarPhase: 'idle',       // 'idle' | 'aiming' | 'cooldown'\n    mortarTimer: 0,\n    mortarTarget: { x: 0, z: 0 }, // aimed landing position\n    mortarArcLine: null as any,       // THREE.Line for aim arc preview\n    mortarGroundCircle: null as any,  // THREE.Mesh for persistent ground circle\n    // Physics velocity (knockback system)\n    vel: { x: 0, y: 0, z: 0 },      // knockback velocity \u2014 integrated by applyVelocities()\n    // Pit / edge-slide\n    wasDeflected: false,       // true when movement was deflected by collision (edge-sliding)\n    fellInPit: false,          // true when killed by falling into a pit\n    // Pit leap (goblins)\n    pitEdgeTimer: 0,           // ms spent hugging a pit edge (wasDeflected near pit)\n    isLeaping: false,          // true during arc leap over pit\n    leapElapsed: 0,            // time into leap\n    leapDuration: 0,           // total flight time\n    leapStartX: 0,\n    leapStartZ: 0,\n    leapTargetX: 0,\n    leapTargetZ: 0,\n    leapArcHeight: 0,\n    leapCooldown: 0,           // ms until next leap allowed\n    // Melee attack state machine (for enemies with config.melee)\n    meleePhase: 'idle' as 'idle' | 'telegraph' | 'attacking' | 'recovery',\n    meleeTimer: 0,\n    meleeHasHit: false,       // prevent double-hit per attack cycle\n    // Hit reaction (squash/bounce)\n    hitReaction: createHitReaction(),\n    allMaterials: model.allMaterials,\n    // Assassin profile state\n    aggroed: true,  // default true \u2014 non-assassin rooms skip detection\n    detecting: false, // true while player is in cone + LOS (detection building)\n    detectionTimer: 0,\n    pushAggroTimer: 0, // ms remaining until push-triggered aggro (0 = inactive)\n    patrolOriginX: position.x,\n    patrolOriginZ: position.z,\n    patrolDir: 1,\n    patrolPauseTimer: 0,\n    patrolTargetAngle: null as number | null,\n    // Waypoint patrol (assassin rooms with fixed patrol circuits)\n    patrolWaypoints: patrolWaypoints || null,\n    patrolWaypointIdx: 0,\n  };\n\n  // Initialize shield if config has one\n  if (cfg.shield && cfg.shield.maxHealth > 0) {\n    enemy.shieldHealth = cfg.shield.maxHealth;\n    enemy.shieldActive = true;\n    enemy.shieldMesh = createShieldMesh(cfg);\n    enemy.shieldMesh.position.y = cfg.size.height * 0.5;\n    group.add(enemy.shieldMesh);\n  }\n\n  gameState.enemies.push(enemy);\n\n  // Assassin profile: initialize facing + vision cone\n  if (getActiveProfile() === 'assassin' && cfg.aggroRadius) {\n    enemy.aggroed = false;  // override \u2014 assassin enemies start unaware\n    // Face toward first waypoint if available, otherwise random\n    if (patrolWaypoints && patrolWaypoints.length > 1) {\n      const wp = patrolWaypoints[1]; // face toward second waypoint (first is spawn pos)\n      const dx = wp.x - position.x;\n      const dz = wp.z - position.z;\n      enemy.mesh.rotation.y = rotationToFace(dx, dz);\n    } else {\n      enemy.mesh.rotation.y = (Math.random() - 0.5) * Math.PI * 2;\n    }\n    enemy.idleBaseRotY = enemy.mesh.rotation.y;\n    enemy.idleScanPhase = Math.random() * Math.PI * 2;\n    enemy._facingInitialized = true;\n    addVisionCone(enemy);\n  }\n\n  return enemy;\n}\n\nexport function spawnTestGroup(gameState: any) {\n  // Larger group for longer sessions\n  const spawns = [\n    // Goblins \u2014 scattered around arena\n    { type: 'goblin', x: 10, z: 5 },\n    { type: 'goblin', x: -8, z: 7 },\n    { type: 'goblin', x: 5, z: -10 },\n    { type: 'goblin', x: -12, z: -3 },\n    { type: 'goblin', x: 15, z: 0 },\n    { type: 'goblin', x: -5, z: 12 },\n    { type: 'goblin', x: -15, z: 8 },\n    { type: 'goblin', x: 8, z: -15 },\n    { type: 'goblin', x: -3, z: -14 },\n    { type: 'goblin', x: 14, z: 10 },\n    { type: 'goblin', x: -10, z: -10 },\n    { type: 'goblin', x: 16, z: -8 },\n    // Archers \u2014 positioned at range\n    { type: 'skeletonArcher', x: 12, z: 12 },\n    { type: 'skeletonArcher', x: -12, z: -12 },\n    { type: 'skeletonArcher', x: -14, z: 10 },\n    { type: 'skeletonArcher', x: 14, z: -10 },\n    { type: 'skeletonArcher', x: 0, z: -16 },\n    // Mortar Imps \u2014 lobbed AoE\n    { type: 'iceMortarImp', x: 10, z: -14 },\n    { type: 'iceMortarImp', x: -10, z: 14 },\n    { type: 'iceMortarImp', x: -16, z: -10 },\n    // Golems \u2014 fewer but threatening\n    { type: 'stoneGolem', x: 0, z: 15 },\n    { type: 'stoneGolem', x: -15, z: -5 },\n    { type: 'stoneGolem', x: 15, z: -5 },\n  ];\n\n  for (const s of spawns) {\n    spawnEnemy(s.type, new THREE.Vector3(s.x, 0, s.z), gameState);\n  }\n}\n\n// Reusable vector for calculations\nconst _toPlayer = new THREE.Vector3();\n\n// Cached collision bounds (loaded once)\nlet _collisionBounds: any = null;\nlet _pitBoundsCache: any = null;\n\n/**\n * Check if position (x,z) is inside any pit (with margin).\n * Returns the pit AABB if inside, or null.\n */\nfunction pitAt(x: number, z: number, margin: number) {\n  if (!_pitBoundsCache) _pitBoundsCache = getPitBounds();\n  for (const pit of _pitBoundsCache) {\n    if (x > pit.minX - margin && x < pit.maxX + margin &&\n        z > pit.minZ - margin && z < pit.maxZ + margin) {\n      return pit;\n    }\n  }\n  return null;\n}\n\n/**\n * Pit-aware movement: given a desired movement direction (dx, dz \u2014 normalized),\n * check if a lookahead step would enter a pit. If so, deflect the direction\n * sideways (perpendicular to the original direction, choosing the side away\n * from the pit center). Returns adjusted { dx, dz }.\n */\nfunction pitAwareDir(x: number, z: number, dx: number, dz: number, lookahead: number) {\n  const ahead = pitAt(x + dx * lookahead, z + dz * lookahead, 0.5);\n  if (!ahead) return { dx, dz }; // no pit ahead \u2014 go straight\n\n  // Pit center\n  const pcx = (ahead.minX + ahead.maxX) / 2;\n  const pcz = (ahead.minZ + ahead.maxZ) / 2;\n\n  // Two perpendicular options: rotate +/-90deg\n  // Option A: (dz, -dx)   Option B: (-dz, dx)\n  // Pick the one whose lookahead is further from pit center\n  const ax = x + dz * lookahead, az = z + (-dx) * lookahead;\n  const bx = x + (-dz) * lookahead, bz = z + dx * lookahead;\n  const distA = (ax - pcx) * (ax - pcx) + (az - pcz) * (az - pcz);\n  const distB = (bx - pcx) * (bx - pcx) + (bz - pcz) * (bz - pcz);\n\n  // Also verify the chosen strafe doesn't land in another pit\n  if (distA >= distB) {\n    if (!pitAt(ax, az, 0.5)) return { dx: dz, dz: -dx };\n    if (!pitAt(bx, bz, 0.5)) return { dx: -dz, dz: dx };\n  } else {\n    if (!pitAt(bx, bz, 0.5)) return { dx: -dz, dz: dx };\n    if (!pitAt(ax, az, 0.5)) return { dx: dz, dz: -dx };\n  }\n\n  // Both sides blocked \u2014 stop moving (better than walking into a pit)\n  return { dx: 0, dz: 0 };\n}\n\n/**\n * Raycast from (ox, oz) in direction (dx, dz) and find distance to first AABB hit.\n * Returns the distance, or maxDist if nothing is hit.\n * Uses slab method for ray-AABB intersection on the XZ plane.\n */\nexport function raycastTerrainDist(ox: number, oz: number, dx: number, dz: number, maxDist: number) {\n  if (!_collisionBounds) _collisionBounds = getCollisionBounds();\n\n  let closest = maxDist;\n\n  for (const box of _collisionBounds) {\n    // Slab method on X axis\n    let tmin: number, tmax: number;\n    if (Math.abs(dx) < 1e-8) {\n      // Ray parallel to X \u2014 check if origin is within X slab\n      if (ox < box.minX || ox > box.maxX) continue;\n      tmin = -Infinity;\n      tmax = Infinity;\n    } else {\n      const invDx = 1 / dx;\n      let t1 = (box.minX - ox) * invDx;\n      let t2 = (box.maxX - ox) * invDx;\n      if (t1 > t2) { const tmp = t1; t1 = t2; t2 = tmp; }\n      tmin = t1;\n      tmax = t2;\n    }\n\n    // Slab method on Z axis\n    if (Math.abs(dz) < 1e-8) {\n      if (oz < box.minZ || oz > box.maxZ) continue;\n      // tmin/tmax unchanged\n    } else {\n      const invDz = 1 / dz;\n      let t1 = (box.minZ - oz) * invDz;\n      let t2 = (box.maxZ - oz) * invDz;\n      if (t1 > t2) { const tmp = t1; t1 = t2; t2 = tmp; }\n      tmin = Math.max(tmin, t1);\n      tmax = Math.min(tmax, t2);\n    }\n\n    // Check valid intersection\n    if (tmax < 0 || tmin > tmax) continue; // behind ray or no intersection\n    const t = tmin > 0 ? tmin : tmax; // entry point (or exit if starting inside)\n    if (t > 0 && t < closest) {\n      closest = t;\n    }\n  }\n\n  return closest;\n}\n\n// \u2500\u2500\u2500 Facing Helpers (assassin profile \u2014 smooth turning) \u2500\u2500\u2500\n\nfunction getForward(rotY: number): { x: number; z: number } {\n  return { x: -Math.sin(rotY), z: -Math.cos(rotY) };\n}\n\nfunction rotationToFace(dx: number, dz: number): number {\n  return Math.atan2(-dx, -dz);\n}\n\nfunction turnToward(enemy: any, targetRotY: number, dt: number): void {\n  let diff = targetRotY - enemy.mesh.rotation.y;\n  while (diff > Math.PI) diff -= Math.PI * 2;\n  while (diff < -Math.PI) diff += Math.PI * 2;\n\n  const maxStep = VISION_CONE_CONFIG.turnSpeed * dt;\n  if (Math.abs(diff) <= maxStep) {\n    enemy.mesh.rotation.y = targetRotY;\n  } else {\n    enemy.mesh.rotation.y += Math.sign(diff) * maxStep;\n  }\n}\n\n// \u2500\u2500\u2500 Patrol Behavior (assassin profile) \u2500\u2500\u2500\n\nconst WAYPOINT_TURN_SPEED = 1.2; // rad/s \u2014 slow turns at corners for readable vision cone sweeps\nconst WAYPOINT_ARRIVAL_DIST = 0.5; // units \u2014 snap to next waypoint when this close\n\nfunction updateWaypointPatrol(enemy: any, dt: number) {\n  const wps = enemy.patrolWaypoints;\n  const target = wps[enemy.patrolWaypointIdx];\n  const dx = target.x - enemy.pos.x;\n  const dz = target.z - enemy.pos.z;\n  const dist = Math.sqrt(dx * dx + dz * dz);\n\n  // Arrived at waypoint \u2014 advance to next\n  if (dist < WAYPOINT_ARRIVAL_DIST) {\n    enemy.patrolWaypointIdx = (enemy.patrolWaypointIdx + 1) % wps.length;\n    return;\n  }\n\n  // Turn toward waypoint (slow, readable rotation)\n  const targetRot = rotationToFace(dx, dz);\n  let diff = targetRot - enemy.mesh.rotation.y;\n  while (diff > Math.PI) diff -= Math.PI * 2;\n  while (diff < -Math.PI) diff += Math.PI * 2;\n  const maxStep = WAYPOINT_TURN_SPEED * dt;\n  if (Math.abs(diff) <= maxStep) {\n    enemy.mesh.rotation.y = targetRot;\n  } else {\n    enemy.mesh.rotation.y += Math.sign(diff) * maxStep;\n  }\n\n  // Only walk when roughly facing the waypoint (within ~45\u00B0)\n  if (Math.abs(diff) < Math.PI / 4) {\n    const speed = (enemy.config.patrol?.speed || 1.2) * (enemy.slowMult || 1);\n    const fwd = getForward(enemy.mesh.rotation.y);\n    enemy.pos.x += fwd.x * speed * dt;\n    enemy.pos.z += fwd.z * speed * dt;\n    enemy.pos.x = Math.max(-ARENA_HALF_X + 1, Math.min(ARENA_HALF_X - 1, enemy.pos.x));\n    enemy.pos.z = Math.max(-ARENA_HALF_Z + 1, Math.min(ARENA_HALF_Z - 1, enemy.pos.z));\n  }\n}\n\nfunction updatePatrol(enemy: any, dt: number) {\n  // Waypoint circuit patrol (fixed routes around pits)\n  if (enemy.patrolWaypoints && enemy.patrolWaypoints.length > 0) {\n    return updateWaypointPatrol(enemy, dt);\n  }\n\n  // Fallback: linear back-and-forth patrol\n  const cfg = enemy.config.patrol;\n  if (!cfg) return;\n\n  if (enemy.patrolPauseTimer > 0) {\n    enemy.patrolPauseTimer -= dt * 1000;\n    if (enemy.patrolTargetAngle != null) {\n      turnToward(enemy, enemy.patrolTargetAngle, dt);\n    }\n    return;\n  }\n\n  const fwd = getForward(enemy.mesh.rotation.y);\n  const speed = cfg.speed * (enemy.slowMult || 1);\n\n  const hitDist = raycastTerrainDist(enemy.pos.x, enemy.pos.z, fwd.x, fwd.z, 1.5);\n  const hitWall = hitDist < 1.0;\n\n  const dFromOriginX = enemy.pos.x - enemy.patrolOriginX;\n  const dFromOriginZ = enemy.pos.z - enemy.patrolOriginZ;\n  const distFromOrigin = Math.sqrt(dFromOriginX * dFromOriginX + dFromOriginZ * dFromOriginZ);\n  const reachedEnd = distFromOrigin >= cfg.distance;\n\n  if (hitWall || reachedEnd) {\n    enemy.patrolDir *= -1;\n    enemy.patrolTargetAngle = enemy.mesh.rotation.y + Math.PI;\n    while (enemy.patrolTargetAngle > Math.PI) enemy.patrolTargetAngle -= Math.PI * 2;\n    while (enemy.patrolTargetAngle < -Math.PI) enemy.patrolTargetAngle += Math.PI * 2;\n    enemy.patrolPauseTimer = cfg.pauseMin + Math.random() * (cfg.pauseMax - cfg.pauseMin);\n    return;\n  }\n\n  enemy.pos.x += fwd.x * speed * dt;\n  enemy.pos.z += fwd.z * speed * dt;\n  enemy.pos.x = Math.max(-ARENA_HALF_X + 1, Math.min(ARENA_HALF_X - 1, enemy.pos.x));\n  enemy.pos.z = Math.max(-ARENA_HALF_Z + 1, Math.min(ARENA_HALF_Z - 1, enemy.pos.z));\n}\n\nexport function updateEnemies(dt: number, playerPos: any, gameState: any) {\n  const isAssassin = getActiveProfile() === 'assassin';\n  if (isAssassin) {\n    updateIdleFacing(gameState.enemies, dt);\n  }\n\n  for (let i = gameState.enemies.length - 1; i >= 0; i--) {\n    const enemy = gameState.enemies[i];\n\n    // Skip enemies that are carrier payloads (being spiked as projectiles)\n    if ((enemy as any).isCarrierPayload) continue;\n\n    // \u2500\u2500\u2500 Assassin Profile: Detection + Patrol \u2500\u2500\u2500\n    if (isAssassin && !enemy.aggroed && enemy.config.aggroRadius) {\n      // Push aggro timer \u2014 delayed aggro after being force-pushed\n      if (enemy.pushAggroTimer > 0) {\n        enemy.pushAggroTimer -= dt * 1000;\n        if (enemy.pushAggroTimer <= 0) {\n          enemy.pushAggroTimer = 0;\n          enemy.aggroed = true;\n          emit({ type: 'enemyAggroed', enemy, position: { x: enemy.pos.x, z: enemy.pos.z } });\n          showAggroIndicator(enemy);\n          if (playerPos) {\n            const toDx = playerPos.x - enemy.pos.x;\n            const toDz = playerPos.z - enemy.pos.z;\n            enemy.mesh.rotation.y = rotationToFace(toDx, toDz);\n          }\n          // Fall through to normal behavior\n        }\n      }\n\n      // Aggro lock: taking any damage immediately triggers aggro\n      if (!enemy.aggroed && enemy.health < enemy.config.health) {\n        enemy.aggroed = true;\n        emit({ type: 'enemyAggroed', enemy, position: { x: enemy.pos.x, z: enemy.pos.z } });\n        showAggroIndicator(enemy);\n        if (playerPos) {\n          const toDx = playerPos.x - enemy.pos.x;\n          const toDz = playerPos.z - enemy.pos.z;\n          enemy.mesh.rotation.y = rotationToFace(toDx, toDz);\n        }\n        // Fall through to normal behavior (don't continue)\n      }\n\n      // If still not aggroed, run patrol + detection\n      if (!enemy.aggroed) {\n      if (enemy.config.patrol && !enemy.isLeaping) {\n        updatePatrol(enemy, dt);\n      }\n\n      if (playerPos) {\n        const inCone = isInsideVisionCone(\n          enemy.pos.x, enemy.pos.z,\n          enemy.mesh.rotation.y,\n          playerPos.x, playerPos.z,\n          enemy.config.aggroRadius\n        );\n\n        let inLOS = true;\n        if (inCone) {\n          const ddx = playerPos.x - enemy.pos.x;\n          const ddz = playerPos.z - enemy.pos.z;\n          const dist = Math.sqrt(ddx * ddx + ddz * ddz);\n          if (dist > 0.1) {\n            const hitDist = raycastTerrainDist(enemy.pos.x, enemy.pos.z, ddx / dist, ddz / dist, dist);\n            inLOS = hitDist >= dist - 0.5;\n          }\n        }\n\n        if (inCone && inLOS) {\n          // Transition: not detecting \u2192 detecting (player just entered cone)\n          if (!enemy.detecting) {\n            enemy.detecting = true;\n            emit({ type: 'detectionStarted', enemy, position: { x: enemy.pos.x, z: enemy.pos.z } });\n          }\n          enemy.detectionTimer += dt * 1000;\n          if (enemy.detectionTimer >= VISION_CONE_CONFIG.detectionThreshold) {\n            // Transition: detecting \u2192 aggroed (skip detectionCleared to avoid BT flicker)\n            enemy.detecting = false;\n            enemy.aggroed = true;\n            emit({ type: 'enemyAggroed', enemy, position: { x: enemy.pos.x, z: enemy.pos.z } });\n            showAggroIndicator(enemy);\n            const toDx = playerPos.x - enemy.pos.x;\n            const toDz = playerPos.z - enemy.pos.z;\n            enemy.mesh.rotation.y = rotationToFace(toDx, toDz);\n          }\n        } else {\n          enemy.detectionTimer = Math.max(0, enemy.detectionTimer - dt * 1500);\n          // Transition: detecting \u2192 clear (player escaped cone, timer decayed to 0)\n          if (enemy.detecting && enemy.detectionTimer === 0) {\n            enemy.detecting = false;\n            emit({ type: 'detectionCleared', enemy, position: { x: enemy.pos.x, z: enemy.pos.z } });\n          }\n        }\n      }\n\n      // Death check \u2014 damage/pit kills still apply to non-aggroed enemies\n      if (enemy.health <= 0) {\n        if (enemy.detecting) {\n          enemy.detecting = false;\n          emit({ type: 'detectionCleared', enemy, position: { x: enemy.pos.x, z: enemy.pos.z } });\n        }\n        emit({ type: 'enemyDied', enemy, position: { x: enemy.pos.x, z: enemy.pos.z } });\n        removeVisionCone(enemy);\n        sceneRef.remove(enemy.mesh);\n        gameState.enemies.splice(i, 1);\n        const drops = enemy.config.drops;\n        gameState.currency += Math.floor(\n          drops.currency.min + Math.random() * (drops.currency.max - drops.currency.min + 1)\n        );\n        continue;\n      }\n\n      // Non-aggroed: sync mesh position but skip normal behavior\n      enemy.pos.x = Math.max(-ARENA_HALF_X, Math.min(ARENA_HALF_X, enemy.pos.x));\n      enemy.pos.z = Math.max(-ARENA_HALF_Z, Math.min(ARENA_HALF_Z, enemy.pos.z));\n      enemy.mesh.position.copy(enemy.pos);\n      continue;\n      } // close if (!enemy.aggroed) \u2014 patrol + detect + continue\n    }\n\n    // Pit leap update \u2014 runs independently of stun (can't stun mid-air)\n    if (enemy.isLeaping) {\n      updateLeap(enemy, dt);\n      // Skip normal behavior/movement but still check death below\n    } else if (enemy.stunTimer > 0 || hasTag(enemy, TAG.STUNNED)) {\n      // Stun check \u2014 stunned enemies cannot move or attack\n      // Sources: stunTimer (legacy timed stun), State.Stunned tag (aerial verb grab, effects)\n      if (enemy.stunTimer > 0) enemy.stunTimer -= dt * 1000;\n    } else {\n      // Behavior dispatch (only when not stunned)\n      switch (enemy.behavior) {\n        case 'rush': behaviorRush(enemy, playerPos, dt, gameState); break;\n        case 'kite': behaviorKite(enemy, playerPos, dt, gameState); break;\n        case 'tank': behaviorTank(enemy, playerPos, dt, gameState); break;\n        case 'mortar': behaviorMortar(enemy, playerPos, dt, gameState); break;\n      }\n    }\n\n    // Arena clamp\n    enemy.pos.x = Math.max(-19, Math.min(19, enemy.pos.x));\n    enemy.pos.z = Math.max(-19, Math.min(19, enemy.pos.z));\n\n    // Ledge fall \u2014 if grounded enemy walks off platform edge, start falling\n    if (!enemy.isLeaping) {\n      const groundBelow = getGroundHeight(enemy.pos.x, enemy.pos.z);\n      if (enemy.pos.y > groundBelow + 0.05) {\n        // Ground dropped out \u2014 gravity will pull them down in applyVelocities\n        const vel = (enemy as any).vel;\n        if (vel && vel.y === 0) vel.y = 0; // ensure Y vel exists, gravity handles the rest\n      }\n    }\n\n    if (enemy.isLeaping) {\n      // Sync clamped XZ but preserve arc Y set by updateLeap\n      enemy.mesh.position.x = enemy.pos.x;\n      enemy.mesh.position.z = enemy.pos.z;\n    } else {\n      enemy.mesh.position.copy(enemy.pos);\n    }\n\n    // Airborne visual \u2014 tumble rotation when launched/falling\n    const groundBelowEnemy = getGroundHeight(enemy.pos.x, enemy.pos.z);\n    const enemyAirborne = enemy.pos.y > groundBelowEnemy + 0.15 && !enemy.isLeaping;\n    if (enemyAirborne) {\n      // Accumulate tumble rotation \u2014 fast spin that looks like they were popped up\n      if (!(enemy as any)._tumbleAngle) (enemy as any)._tumbleAngle = 0;\n      (enemy as any)._tumbleAngle += dt * 8;\n      enemy.mesh.rotation.x = Math.sin((enemy as any)._tumbleAngle) * 0.5;\n      enemy.mesh.rotation.z = Math.cos((enemy as any)._tumbleAngle * 0.7) * 0.3;\n      // Squash/stretch based on Y velocity\n      const vy = (enemy.vel as any).y || 0;\n      const stretch = 1 + Math.abs(vy) * 0.02;\n      const squash = 1 / Math.sqrt(stretch);\n      enemy.mesh.scale.set(squash, stretch, squash);\n    } else {\n      enemy.mesh.rotation.x = 0;\n      enemy.mesh.rotation.z = 0;\n      enemy.mesh.scale.set(1, 1, 1);\n      (enemy as any)._tumbleAngle = 0;\n    }\n\n    // Flash timer (hit feedback)\n    if (enemy.flashTimer > 0) {\n      enemy.flashTimer -= dt * 1000;\n      if (enemy.flashTimer <= 0) {\n        enemy.bodyMesh.material.emissive.setHex(enemy.config.emissive);\n        if (enemy.headMesh) enemy.headMesh.material.emissive.setHex(enemy.config.emissive);\n      }\n    }\n\n    // Hit reaction (squash/bounce)\n    if (enemy.hitReaction && enemy.hitReaction.active) {\n      updateHitReaction(enemy.hitReaction, enemy.mesh, dt);\n    }\n\n    // Slow debuff timer\n    if (enemy.slowTimer > 0) {\n      enemy.slowTimer -= dt * 1000;\n      if (enemy.slowTimer <= 0) {\n        enemy.slowTimer = 0;\n        enemy.slowMult = 1;\n      }\n    }\n\n    // Shield durability visual feedback\n    if (enemy.shieldActive && enemy.shieldMesh) {\n      const shieldCfg = enemy.config.shield;\n      const ratio = enemy.shieldHealth / shieldCfg.maxHealth; // 1.0 = full, 0.0 = broken\n\n      const baseOpacity = shieldCfg.opacity || 0.35;\n\n      // Opacity fades as shield depletes\n      let opacity = baseOpacity * (0.3 + 0.7 * ratio); // never fully invisible while active\n\n      // Color shifts cyan -> red as shield weakens\n      const r = Math.round(0x44 + (0xff - 0x44) * (1 - ratio));\n      const g = Math.round(0xcc * ratio);\n      const b = Math.round(0xff * ratio);\n      enemy.shieldMesh.material.emissive.setRGB(r / 255, g / 255, b / 255);\n\n      // Flicker when below 25%\n      if (ratio < 0.25) {\n        const flicker = 0.5 + 0.5 * Math.sin(performance.now() * 0.06); // ~10Hz\n        opacity *= (0.5 + 0.5 * flicker);\n      } else {\n        // Gentle pulse when healthy\n        opacity += 0.05 * Math.sin(performance.now() * 0.003);\n      }\n\n      enemy.shieldMesh.material.opacity = Math.max(0.05, opacity);\n    }\n\n    // Death telegraph countdown (golem detonation delay)\n    if (enemy.deathTimer > 0) {\n      enemy.deathTimer -= dt * 1000;\n      updateDeathTelegraph(enemy, dt);\n\n      // Sync mesh position (enemy can be pushed by Force Push during telegraph)\n      enemy.mesh.position.copy(enemy.pos);\n\n      // If pushed into a pit during telegraph, cancel explosion and remove immediately\n      if (enemy.fellInPit) {\n        removeDeathTelegraph(enemy);\n        if (enemy.shieldMesh) {\n          enemy.shieldMesh.geometry.dispose();\n          enemy.shieldMesh.material.dispose();\n        }\n        removeMortarArcLine(enemy);\n        removeMortarGroundCircle(enemy);\n        removeVisionCone(enemy);\n        sceneRef.remove(enemy.mesh);\n        gameState.enemies.splice(i, 1);\n        const drops = enemy.config.drops;\n        gameState.currency += Math.floor(\n          drops.currency.min + Math.random() * (drops.currency.max - drops.currency.min + 1)\n        );\n        continue;\n      }\n\n      if (enemy.deathTimer <= 0) {\n        // Telegraph expired \u2014 detonate at CURRENT position (may have been pushed)\n        if (enemy.config.deathExplosion && !enemy.fellInPit) {\n          onDeathExplosion(enemy, gameState);\n        }\n        removeDeathTelegraph(enemy);\n\n        // Clean up shield mesh\n        if (enemy.shieldMesh) {\n          enemy.shieldMesh.geometry.dispose();\n          enemy.shieldMesh.material.dispose();\n        }\n        removeMortarArcLine(enemy);\n        removeMortarGroundCircle(enemy);\n        removeVisionCone(enemy);\n        sceneRef.remove(enemy.mesh);\n        gameState.enemies.splice(i, 1);\n        const drops = enemy.config.drops;\n        gameState.currency += Math.floor(\n          drops.currency.min + Math.random() * (drops.currency.max - drops.currency.min + 1)\n        );\n      }\n      continue; // Skip normal death check while telegraph is active\n    }\n\n    // Death\n    if (enemy.health <= 0) {\n      const deathCfg = enemy.config.deathExplosion;\n\n      // If this enemy has a telegraph duration, defer the explosion\n      if (deathCfg && deathCfg.telegraphDuration && !enemy.fellInPit) {\n        enemy.deathTimer = deathCfg.telegraphDuration;\n        enemy.stunTimer = deathCfg.telegraphDuration + 100; // keep stunned through telegraph\n        createDeathTelegraph(enemy);\n        continue;\n      }\n\n      // Immediate death (no telegraph) \u2014 AoE damage to nearby units (skip if fell in pit)\n      if (deathCfg && !enemy.fellInPit) {\n        onDeathExplosion(enemy, gameState);\n      }\n\n      emit({ type: 'enemyDied', enemy, position: { x: enemy.pos.x, z: enemy.pos.z } });\n\n      // Clean up shield mesh\n      if (enemy.shieldMesh) {\n        enemy.shieldMesh.geometry.dispose();\n        enemy.shieldMesh.material.dispose();\n      }\n      // Clean up mortar visuals\n      removeMortarArcLine(enemy);\n      removeMortarGroundCircle(enemy);\n      removeVisionCone(enemy);\n      sceneRef.remove(enemy.mesh);\n      gameState.enemies.splice(i, 1);\n      // Currency drop\n      const drops = enemy.config.drops;\n      gameState.currency += Math.floor(\n        drops.currency.min + Math.random() * (drops.currency.max - drops.currency.min + 1)\n      );\n    }\n  }\n\n  if (isAssassin) {\n    updateVisionCones(gameState.enemies, dt);\n    updateAggroIndicators(dt);\n  }\n}\n\n// \u2500\u2500\u2500 Enemy Melee State Machine \u2500\u2500\u2500\n// Shared telegraph \u2192 attack \u2192 recovery flow for enemies with config.melee\n\nfunction startEnemyMelee(enemy: any) {\n  const meleeCfg = enemy.config.melee;\n  if (!meleeCfg) return;\n  const telegraphDur = meleeCfg.telegraphDuration * MOB_GLOBAL.telegraphMult;\n  enemy.meleePhase = 'telegraph';\n  enemy.meleeTimer = telegraphDur;\n  enemy.meleeHasHit = false;\n  // Flash emissive to signal telegraph\n  enemy.flashTimer = telegraphDur;\n  enemy.bodyMesh.material.emissive.setHex(0xffaa00);\n  if (enemy.headMesh) enemy.headMesh.material.emissive.setHex(0xffaa00);\n\n  // Emit telegraph event for ground arc decal\n  emit({\n    type: 'enemyMeleeTelegraph',\n    position: { x: enemy.pos.x, z: enemy.pos.z },\n    facingAngle: enemy.mesh.rotation.y,\n    hitArc: meleeCfg.hitArc,\n    hitRange: meleeCfg.hitRange,\n    duration: telegraphDur + meleeCfg.attackDuration,  // visible through telegraph + attack\n  });\n}\n\nfunction updateEnemyMelee(enemy: any, dt: number, playerPos: any, gameState: any) {\n  const meleeCfg = enemy.config.melee;\n  if (!meleeCfg || enemy.meleePhase === 'idle') return;\n\n  enemy.meleeTimer -= dt * 1000;\n\n  if (enemy.meleePhase === 'telegraph') {\n    // Pulsing emissive during telegraph\n    const pulse = 0.5 + 0.5 * Math.sin(performance.now() * 0.015);\n    const r = Math.floor(0xff * pulse);\n    const g = Math.floor(0xaa * pulse);\n    enemy.bodyMesh.material.emissive.setRGB(r / 255, g / 255, 0);\n    if (enemy.headMesh) enemy.headMesh.material.emissive.setRGB(r / 255, g / 255, 0);\n\n    if (enemy.meleeTimer <= 0) {\n      // Transition to attacking\n      enemy.meleePhase = 'attacking';\n      enemy.meleeTimer = meleeCfg.attackDuration;\n\n      // Lunge toward player if configured\n      if (meleeCfg.lungeDistance) {\n        _toPlayer.subVectors(playerPos, enemy.pos);\n        _toPlayer.y = 0;\n        const dist = _toPlayer.length();\n        if (dist > 0.1) {\n          _toPlayer.normalize();\n          enemy.pos.x += _toPlayer.x * meleeCfg.lungeDistance;\n          enemy.pos.z += _toPlayer.z * meleeCfg.lungeDistance;\n        }\n      }\n\n      // Bright flash on attack\n      enemy.bodyMesh.material.emissive.setHex(0xff4400);\n      if (enemy.headMesh) enemy.headMesh.material.emissive.setHex(0xff4400);\n    }\n  } else if (enemy.meleePhase === 'attacking') {\n    // Check if player is in hit arc/range (once per attack)\n    if (!enemy.meleeHasHit) {\n      const dx = playerPos.x - enemy.pos.x;\n      const dz = playerPos.z - enemy.pos.z;\n      const dist = Math.sqrt(dx * dx + dz * dz);\n\n      if (dist < meleeCfg.hitRange && !isPlayerInvincible()) {\n        // Check arc\n        const angleToPlayer = Math.atan2(-dx, -dz);\n        const facingAngle = enemy.mesh.rotation.y;\n        let angleDiff = angleToPlayer - facingAngle;\n        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;\n        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;\n\n        if (Math.abs(angleDiff) <= meleeCfg.hitArc / 2) {\n          // Hit the player!\n          const dmg = meleeCfg.damage * MOB_GLOBAL.damageMult;\n          gameState.playerHealth -= dmg;\n          enemy.meleeHasHit = true;\n          screenShake(3, 120);\n          emit({ type: 'playerHit', damage: dmg, position: { x: playerPos.x, z: playerPos.z } });\n          spawnDamageNumber(playerPos.x, playerPos.z, Math.round(dmg), '#ff4466');\n\n          if (gameState.playerHealth <= 0) {\n            gameState.playerHealth = 0;\n            gameState.phase = 'gameOver';\n          }\n        }\n      }\n    }\n\n    if (enemy.meleeTimer <= 0) {\n      // Transition to recovery\n      enemy.meleePhase = 'recovery';\n      enemy.meleeTimer = meleeCfg.recoveryDuration * MOB_GLOBAL.recoveryMult;\n      // Dim emissive during recovery \u2014 punish window\n      enemy.bodyMesh.material.emissive.setHex(0x222222);\n      if (enemy.headMesh) enemy.headMesh.material.emissive.setHex(0x222222);\n    }\n  } else if (enemy.meleePhase === 'recovery') {\n    if (enemy.meleeTimer <= 0) {\n      // Back to idle\n      enemy.meleePhase = 'idle';\n      enemy.lastAttackTime = performance.now();\n      // Restore normal emissive\n      enemy.bodyMesh.material.emissive.setHex(enemy.config.emissive);\n      if (enemy.headMesh) enemy.headMesh.material.emissive.setHex(enemy.config.emissive);\n    }\n  }\n}\n\nfunction behaviorRush(enemy: any, playerPos: any, dt: number, gameState: any) {\n  // Skip normal movement during leap (handled by updateLeap)\n  if (enemy.isLeaping) return;\n\n  // If in melee attack cycle, update that and skip movement\n  if (enemy.meleePhase !== 'idle') {\n    updateEnemyMelee(enemy, dt, playerPos, gameState);\n    return;\n  }\n\n  _toPlayer.subVectors(playerPos, enemy.pos);\n  _toPlayer.y = 0;\n  const dist = _toPlayer.length();\n\n  const stopDist = (enemy.config.rush && enemy.config.rush.stopDistance) || 0.5;\n\n  // Check if close enough to start a melee attack\n  const meleeCfg = enemy.config.melee;\n  if (meleeCfg && dist <= meleeCfg.hitRange) {\n    const now = performance.now();\n    if (now - enemy.lastAttackTime > enemy.config.attackRate) {\n      startEnemyMelee(enemy);\n      return;\n    }\n  }\n\n  if (dist > stopDist) {\n    _toPlayer.normalize();\n    const slideBoost = enemy.wasDeflected ? 1.175 : 1.0;\n    const iceEffects = getIceEffects(enemy.pos.x, enemy.pos.z, false);\n    const speed = enemy.config.speed * MOB_GLOBAL.speedMult * (enemy.slowTimer > 0 ? enemy.slowMult : 1) * slideBoost * iceEffects.speedMult;\n    enemy.pos.x += _toPlayer.x * speed * dt;\n    enemy.pos.z += _toPlayer.z * speed * dt;\n  }\n\n  // Face player\n  if (dist > 0.1) {\n    enemy.mesh.rotation.y = Math.atan2(-_toPlayer.x, -_toPlayer.z);\n  }\n\n  // --- Pit leap detection ---\n  const leapCfg = enemy.config.pitLeap;\n  if (!leapCfg) return;\n\n  // Tick cooldown\n  if (enemy.leapCooldown > 0) {\n    enemy.leapCooldown -= dt * 1000;\n    enemy.pitEdgeTimer = 0;\n    return;\n  }\n\n  // Track time spent hugging a pit edge\n  if (enemy.wasDeflected && pitAt(enemy.pos.x, enemy.pos.z, 1.0)) {\n    enemy.pitEdgeTimer += dt * 1000;\n  } else {\n    enemy.pitEdgeTimer = 0;\n  }\n\n  // Trigger leap after hugging long enough\n  if (enemy.pitEdgeTimer >= leapCfg.edgeTimeRequired) {\n    startPitLeap(enemy, playerPos, leapCfg);\n  }\n}\n\n// --- Pit Leap (goblin arc jump over pits) ---\n\nfunction startPitLeap(enemy: any, playerPos: any, leapCfg: any) {\n  // Direction toward player\n  const dx = playerPos.x - enemy.pos.x;\n  const dz = playerPos.z - enemy.pos.z;\n  const dist = Math.sqrt(dx * dx + dz * dz);\n  if (dist < 0.1) return; // too close, skip\n\n  const dirX = dx / dist;\n  const dirZ = dz / dist;\n\n  // Find how far we need to leap to clear the pit ahead\n  // Scan forward in small steps to find where the pit ends\n  let leapDist = 3; // minimum leap distance\n  for (let probe = 1; probe <= 15; probe += 0.5) {\n    const px = enemy.pos.x + dirX * probe;\n    const pz = enemy.pos.z + dirZ * probe;\n    if (!pitAt(px, pz, 0.3)) {\n      leapDist = probe + 1; // overshoot by 1 unit to land clear\n      break;\n    }\n    leapDist = probe + 1;\n  }\n\n  // Cap the leap distance\n  leapDist = Math.min(leapDist, 12);\n\n  enemy.isLeaping = true;\n  enemy.leapStartX = enemy.pos.x;\n  enemy.leapStartZ = enemy.pos.z;\n  enemy.leapTargetX = enemy.pos.x + dirX * leapDist;\n  enemy.leapTargetZ = enemy.pos.z + dirZ * leapDist;\n  enemy.leapArcHeight = leapCfg.arcHeight || 3;\n  enemy.leapElapsed = 0;\n  enemy.pitEdgeTimer = 0;\n\n  // Flight time based on distance and speed\n  const flightDist = leapDist + 2 * enemy.leapArcHeight * enemy.leapArcHeight / Math.max(leapDist, 0.1);\n  enemy.leapDuration = flightDist / (leapCfg.leapSpeed || 12);\n\n}\n\nfunction updateLeap(enemy: any, dt: number) {\n  enemy.leapElapsed += dt;\n  const t = Math.min(enemy.leapElapsed / enemy.leapDuration, 1);\n\n  // Interpolate XZ position linearly\n  enemy.pos.x = enemy.leapStartX + (enemy.leapTargetX - enemy.leapStartX) * t;\n  enemy.pos.z = enemy.leapStartZ + (enemy.leapTargetZ - enemy.leapStartZ) * t;\n\n  // Parabolic arc for Y (visual only)\n  const arcY = 4 * enemy.leapArcHeight * t * (1 - t);\n  enemy.mesh.position.set(enemy.pos.x, arcY, enemy.pos.z);\n\n  // Face direction of travel\n  const dx = enemy.leapTargetX - enemy.leapStartX;\n  const dz = enemy.leapTargetZ - enemy.leapStartZ;\n  if (dx * dx + dz * dz > 0.01) {\n    enemy.mesh.rotation.y = Math.atan2(-dx, -dz);\n  }\n\n  // Landing\n  if (t >= 1) {\n    enemy.isLeaping = false;\n    enemy.leapCooldown = (enemy.config.pitLeap && enemy.config.pitLeap.cooldown) || 4000;\n    // Snap mesh back to ground\n    enemy.mesh.position.set(enemy.pos.x, 0, enemy.pos.z);\n  }\n}\n\nfunction behaviorKite(enemy: any, playerPos: any, dt: number, gameState: any) {\n  _toPlayer.subVectors(playerPos, enemy.pos);\n  _toPlayer.y = 0;\n  const dist = _toPlayer.length();\n  const kite = enemy.config.kite || {};\n  const sniper = enemy.config.sniper || {};\n  const preferredRange = enemy.config.attackRange * (kite.preferredRangeMult || 0.7);\n\n  const isTelegraphing = enemy.sniperPhase === 'telegraphing';\n\n  // Movement: maintain preferred range (freeze during telegraph \u2014 lining up the shot)\n  if (!isTelegraphing) {\n    const slideBoost = enemy.wasDeflected ? 1.175 : 1.0;\n    const iceEffects = getIceEffects(enemy.pos.x, enemy.pos.z, false);\n    const speed = enemy.config.speed * MOB_GLOBAL.speedMult * (enemy.slowTimer > 0 ? enemy.slowMult : 1) * slideBoost * iceEffects.speedMult;\n    if (dist < preferredRange - (kite.retreatBuffer || 1)) {\n      // Too close \u2014 retreat (pit-aware)\n      _toPlayer.normalize();\n      const retreat = pitAwareDir(enemy.pos.x, enemy.pos.z, -_toPlayer.x, -_toPlayer.z, 2.5);\n      enemy.pos.x += retreat.dx * speed * dt;\n      enemy.pos.z += retreat.dz * speed * dt;\n    } else if (dist > preferredRange + (kite.advanceBuffer || 3)) {\n      // Too far \u2014 approach (pit-aware)\n      _toPlayer.normalize();\n      const advance = pitAwareDir(enemy.pos.x, enemy.pos.z, _toPlayer.x, _toPlayer.z, 2.5);\n      enemy.pos.x += advance.dx * speed * dt;\n      enemy.pos.z += advance.dz * speed * dt;\n    }\n  }\n\n  // Always face player (or locked aim direction during telegraph)\n  if (isTelegraphing) {\n    enemy.mesh.rotation.y = enemy.sniperAimAngle + Math.PI;\n  } else if (dist > 0.1) {\n    const nx = _toPlayer.x / dist;\n    const nz = _toPlayer.z / dist;\n    enemy.mesh.rotation.y = Math.atan2(-nx, -nz);\n  }\n\n  // Sniper attack logic\n  const now = performance.now();\n\n  if (enemy.sniperPhase === 'idle') {\n    // Check if ready to fire\n    if (dist < enemy.config.attackRange && now - enemy.lastAttackTime > enemy.config.attackRate) {\n      // Lock aim and begin telegraph\n      enemy.sniperPhase = 'telegraphing';\n      enemy.sniperTimer = (sniper.telegraphDuration || 800) * MOB_GLOBAL.telegraphMult;\n\n      // Calculate aim direction\n      const aimAngle = Math.atan2(playerPos.x - enemy.pos.x, playerPos.z - enemy.pos.z);\n      enemy.sniperAimAngle = aimAngle;\n\n      // Flash emissive to signal telegraph start\n      enemy.flashTimer = enemy.sniperTimer;\n      enemy.bodyMesh.material.emissive.setHex(sniper.color || 0xaa44ff);\n      if (enemy.headMesh) enemy.headMesh.material.emissive.setHex(sniper.color || 0xaa44ff);\n    }\n  } else if (enemy.sniperPhase === 'telegraphing') {\n    // Count down telegraph timer\n    enemy.sniperTimer -= dt * 1000;\n\n    // Pulsing emissive during telegraph\n    const pulse = 0.5 + 0.5 * Math.sin(performance.now() * 0.012);\n    const c = sniper.color || 0xaa44ff;\n    const r = ((c >> 16) & 0xff) / 255;\n    const g = ((c >> 8) & 0xff) / 255;\n    const b = (c & 0xff) / 255;\n    enemy.bodyMesh.material.emissive.setRGB(r * pulse, g * pulse, b * pulse);\n    if (enemy.headMesh) enemy.headMesh.material.emissive.setRGB(r * pulse, g * pulse, b * pulse);\n\n    if (enemy.sniperTimer <= 0) {\n      // Fire a real projectile in the locked aim direction\n      enemy.sniperPhase = 'idle';\n      enemy.lastAttackTime = now;\n\n      const dirX = Math.sin(enemy.sniperAimAngle);\n      const dirZ = Math.cos(enemy.sniperAimAngle);\n      const origin = { x: enemy.pos.x, y: 0.5, z: enemy.pos.z };\n      const direction = { x: dirX, y: 0, z: dirZ };\n      const projConfig = {\n        speed: 12,\n        damage: (sniper.damage || 15) * MOB_GLOBAL.damageMult,\n        color: sniper.color || 0xaa44ff,\n      };\n      fireProjectile(origin, direction, projConfig, true);\n\n      // Restore emissive\n      enemy.bodyMesh.material.emissive.setHex(enemy.config.emissive);\n      if (enemy.headMesh) enemy.headMesh.material.emissive.setHex(enemy.config.emissive);\n    }\n  }\n}\n\n\nfunction behaviorMortar(enemy: any, playerPos: any, dt: number, gameState: any) {\n  _toPlayer.subVectors(playerPos, enemy.pos);\n  _toPlayer.y = 0;\n  const dist = _toPlayer.length();\n  const kite = enemy.config.kite || {};\n  const mortar = enemy.config.mortar || {};\n  const preferredRange = enemy.config.attackRange * (kite.preferredRangeMult || 0.65);\n\n  const isAiming = enemy.mortarPhase === 'aiming';\n\n  // Movement: kite like an archer (freeze during aim to line up the shot, pit-aware)\n  if (!isAiming) {\n    const slideBoost = enemy.wasDeflected ? 1.175 : 1.0;\n    const iceEffects = getIceEffects(enemy.pos.x, enemy.pos.z, false);\n    const speed = enemy.config.speed * MOB_GLOBAL.speedMult * (enemy.slowTimer > 0 ? enemy.slowMult : 1) * slideBoost * iceEffects.speedMult;\n    if (dist < preferredRange - (kite.retreatBuffer || 1.5)) {\n      _toPlayer.normalize();\n      const retreat = pitAwareDir(enemy.pos.x, enemy.pos.z, -_toPlayer.x, -_toPlayer.z, 2.5);\n      enemy.pos.x += retreat.dx * speed * dt;\n      enemy.pos.z += retreat.dz * speed * dt;\n    } else if (dist > preferredRange + (kite.advanceBuffer || 3)) {\n      _toPlayer.normalize();\n      const advance = pitAwareDir(enemy.pos.x, enemy.pos.z, _toPlayer.x, _toPlayer.z, 2.5);\n      enemy.pos.x += advance.dx * speed * dt;\n      enemy.pos.z += advance.dz * speed * dt;\n    }\n  }\n\n  // Face player (or target during aim)\n  if (isAiming) {\n    const dx = enemy.mortarTarget.x - enemy.pos.x;\n    const dz = enemy.mortarTarget.z - enemy.pos.z;\n    if (Math.abs(dx) > 0.01 || Math.abs(dz) > 0.01) {\n      enemy.mesh.rotation.y = Math.atan2(-dx, -dz);\n    }\n  } else if (dist > 0.1) {\n    const nx = _toPlayer.x / dist;\n    const nz = _toPlayer.z / dist;\n    enemy.mesh.rotation.y = Math.atan2(-nx, -nz);\n  }\n\n  // Mortar attack logic\n  const now = performance.now();\n\n  if (enemy.mortarPhase === 'idle') {\n    if (dist < enemy.config.attackRange && now - enemy.lastAttackTime > enemy.config.attackRate) {\n      // Start aim phase \u2014 pick a target near the player\n      enemy.mortarPhase = 'aiming';\n      enemy.mortarTimer = mortar.aimDuration || 1200;\n\n      // Target = player position + random inaccuracy offset\n      const inaccuracy = mortar.inaccuracy || 1.5;\n      const angle = Math.random() * Math.PI * 2;\n      enemy.mortarTarget.x = playerPos.x + Math.cos(angle) * Math.random() * inaccuracy;\n      enemy.mortarTarget.z = playerPos.z + Math.sin(angle) * Math.random() * inaccuracy;\n\n      // Clamp target to arena\n      enemy.mortarTarget.x = Math.max(-19, Math.min(19, enemy.mortarTarget.x));\n      enemy.mortarTarget.z = Math.max(-19, Math.min(19, enemy.mortarTarget.z));\n\n      // Flash emissive to signal aim start\n      enemy.flashTimer = mortar.aimDuration || 1200;\n      enemy.bodyMesh.material.emissive.setHex(mortar.color || 0xff6622);\n      if (enemy.headMesh) enemy.headMesh.material.emissive.setHex(mortar.color || 0xff6622);\n\n      // Create aim arc line preview\n      createMortarArcLine(enemy);\n\n      // Create persistent ground circle at landing point (stays through aim + flight)\n      createMortarGroundCircle(enemy);\n    }\n  } else if (enemy.mortarPhase === 'aiming') {\n    enemy.mortarTimer -= dt * 1000;\n\n    // Update arc line visual each frame\n    updateMortarArcLine(enemy);\n\n    // Pulse the ground circle during aim phase (stays at or above 0.3 opacity)\n    if (enemy.mortarGroundCircle) {\n      const gc = enemy.mortarGroundCircle;\n      const aimDuration = mortar.aimDuration || 1200;\n      const aimProgress = 1 - (enemy.mortarTimer / aimDuration); // 0->1 over aim phase\n\n      // Scale-in animation: circleStartScale -> 1.0 over circleScaleTime (easeOutQuad)\n      gc.scaleElapsed += dt;\n      const scaleT = Math.min(gc.scaleElapsed / gc.scaleDuration, 1);\n      const eased = 1 - (1 - scaleT) * (1 - scaleT); // easeOutQuad\n      const startS = gc.circleStartScale;\n      const s = gc.targetRadius * (startS + (1 - startS) * eased);\n      gc.group.scale.set(s, s, s);\n\n      // Ring: pulse between 0.3 and 0.5, accelerating pulse rate as aim progresses\n      const freq = 0.004 + 0.008 * aimProgress; // pulse speeds up\n      const pulse = 0.85 + 0.15 * Math.sin(performance.now() * freq);\n      gc.ringMat.opacity = (0.3 + 0.15 * aimProgress) * pulse;\n      gc.fillMat.opacity = 0.08 + 0.04 * aimProgress;\n    }\n\n    if (enemy.mortarTimer <= 0) {\n      // Fire the mortar projectile!\n      enemy.mortarPhase = 'idle';\n      enemy.lastAttackTime = now;\n\n      // Remove aim arc line\n      removeMortarArcLine(enemy);\n\n      // Hand the ground circle to the projectile (it persists during flight)\n      const groundCircle = enemy.mortarGroundCircle;\n      enemy.mortarGroundCircle = null;\n\n      // Launch the projectile along the arc\n      fireMortarProjectile({\n        startX: enemy.pos.x,\n        startZ: enemy.pos.z,\n        targetX: enemy.mortarTarget.x,\n        targetZ: enemy.mortarTarget.z,\n        arcHeight: mortar.arcHeight || 6,\n        speed: mortar.projectileSpeed || 8,\n        color: mortar.color || 0xff6622,\n        blastRadius: mortar.blastRadius || 2.5,\n        damage: mortar.damage || 18,\n        slowDuration: mortar.slowDuration || 800,\n        slowMult: mortar.slowMult || 0.6,\n        explosionDuration: mortar.explosionDuration || 300,\n        icePatch: mortar.icePatch || null,\n        gameState,\n        sourceEnemy: enemy,\n        groundCircle,\n      });\n    }\n  }\n}\n\n// --- Mortar arc line helpers ---\n\nconst ARC_SEGMENTS = 20;\nlet _arcLineGeo: any = null;\n\nfunction createMortarArcLine(enemy: any) {\n  if (!_arcLineGeo) {\n    const positions = new Float32Array((ARC_SEGMENTS + 1) * 3);\n    _arcLineGeo = new THREE.BufferGeometry();\n    _arcLineGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n  }\n\n  // Clone geometry so each enemy gets its own buffer\n  const geo = _arcLineGeo.clone();\n  geo.setAttribute('position', new THREE.BufferAttribute(\n    new Float32Array((ARC_SEGMENTS + 1) * 3), 3\n  ));\n\n  const mat = new THREE.LineBasicMaterial({\n    color: enemy.config.mortar?.color || 0xff6622,\n    transparent: true,\n    opacity: 0.6,\n    depthWrite: false,\n  });\n\n  const line = new THREE.Line(geo, mat);\n  sceneRef.add(line);\n  enemy.mortarArcLine = line;\n\n  updateMortarArcLine(enemy);\n}\n\nfunction updateMortarArcLine(enemy: any) {\n  if (!enemy.mortarArcLine) return;\n  const mortar = enemy.config.mortar || {};\n  const sx = enemy.pos.x;\n  const sz = enemy.pos.z;\n  const tx = enemy.mortarTarget.x;\n  const tz = enemy.mortarTarget.z;\n  const arcH = mortar.arcHeight || 6;\n  const startY = 0.8; // launch from body height\n\n  const positions = enemy.mortarArcLine.geometry.attributes.position.array;\n  for (let i = 0; i <= ARC_SEGMENTS; i++) {\n    const t = i / ARC_SEGMENTS;\n    const x = sx + (tx - sx) * t;\n    const z = sz + (tz - sz) * t;\n    // Parabolic arc: y = startY + 4*arcH*t*(1-t) gives a nice arc peaking at arcH\n    const y = startY + 4 * arcH * t * (1 - t);\n    positions[i * 3] = x;\n    positions[i * 3 + 1] = y;\n    positions[i * 3 + 2] = z;\n  }\n  enemy.mortarArcLine.geometry.attributes.position.needsUpdate = true;\n\n  // Pulse opacity for telegraph effect\n  const pulse = 0.3 + 0.3 * Math.sin(performance.now() * 0.008);\n  enemy.mortarArcLine.material.opacity = pulse;\n}\n\nfunction removeMortarArcLine(enemy: any) {\n  if (enemy.mortarArcLine) {\n    enemy.mortarArcLine.geometry.dispose();\n    enemy.mortarArcLine.material.dispose();\n    sceneRef.remove(enemy.mortarArcLine);\n    enemy.mortarArcLine = null;\n  }\n}\n\n// --- Mortar ground circle (persistent through aim + flight) ---\n\nlet _circleGeo: any = null;\n\nfunction createMortarGroundCircle(enemy: any) {\n  const mortar = enemy.config.mortar || {};\n  const radius = mortar.blastRadius || 2.5;\n  const color = mortar.color || 0xff6622;\n\n  // Shared ring geometry (unit scale, scaled per instance)\n  if (!_circleGeo) {\n    _circleGeo = new THREE.RingGeometry(0.85, 1.0, 32);\n    _circleGeo.rotateX(-Math.PI / 2);\n  }\n\n  // Ring outline\n  const ringMat = new THREE.MeshBasicMaterial({\n    color: color,\n    transparent: true,\n    opacity: 0.3,\n    side: THREE.DoubleSide,\n    depthWrite: false,\n  });\n  const ringMesh = new THREE.Mesh(_circleGeo, ringMat);\n\n  // Filled disc for area indication (shared geometry)\n  if (!_mortarFillGeoShared) {\n    _mortarFillGeoShared = new THREE.CircleGeometry(1, 32);\n    _mortarFillGeoShared.rotateX(-Math.PI / 2);\n  }\n  const fillMat = new THREE.MeshBasicMaterial({\n    color: color,\n    transparent: true,\n    opacity: 0.08,\n    side: THREE.DoubleSide,\n    depthWrite: false,\n  });\n  const fillMesh = new THREE.Mesh(_mortarFillGeoShared, fillMat);\n\n  const group = new THREE.Group();\n  group.add(ringMesh);\n  group.add(fillMesh);\n  group.position.set(enemy.mortarTarget.x, 0.05, enemy.mortarTarget.z);\n  const circleStartScale = mortar.circleStartScale || 0.25;\n  const startScale = radius * circleStartScale;\n  group.scale.set(startScale, startScale, startScale);\n  sceneRef.add(group);\n\n  enemy.mortarGroundCircle = {\n    group,\n    ringMat,\n    fillMat,\n    color,\n    targetRadius: radius,\n    circleStartScale,\n    scaleElapsed: 0,                              // tracks time for scale-in animation\n    scaleDuration: (mortar.circleScaleTime || 200) / 1000, // convert ms -> seconds\n  };\n}\n\nfunction removeMortarGroundCircle(enemy: any) {\n  if (enemy.mortarGroundCircle) {\n    const gc = enemy.mortarGroundCircle;\n    gc.ringMat.dispose();\n    gc.fillMat.dispose();\n    // geometry is shared \u2014 don't dispose\n    sceneRef.remove(gc.group);\n    enemy.mortarGroundCircle = null;\n  }\n}\n\n// --- Death telegraph circle (expanding ring before golem explosion) ---\n\nlet _deathCircleGeo: any = null;\n\nfunction createDeathTelegraph(enemy: any) {\n  const cfg = enemy.config.deathExplosion;\n  const radius = cfg.radius;\n  const color = cfg.color;\n\n  // Shared ring geometry (unit scale)\n  if (!_deathCircleGeo) {\n    _deathCircleGeo = new THREE.RingGeometry(0.85, 1.0, 32);\n    _deathCircleGeo.rotateX(-Math.PI / 2);\n  }\n\n  // Ring outline\n  const ringMat = new THREE.MeshBasicMaterial({\n    color: color,\n    transparent: true,\n    opacity: 0.5,\n    side: THREE.DoubleSide,\n    depthWrite: false,\n  });\n  const ringMesh = new THREE.Mesh(_deathCircleGeo, ringMat);\n\n  // Filled disc (shared geometry)\n  if (!_deathFillGeoShared) {\n    _deathFillGeoShared = new THREE.CircleGeometry(1, 32);\n    _deathFillGeoShared.rotateX(-Math.PI / 2);\n  }\n  const fillMat = new THREE.MeshBasicMaterial({\n    color: color,\n    transparent: true,\n    opacity: 0.12,\n    side: THREE.DoubleSide,\n    depthWrite: false,\n  });\n  const fillMesh = new THREE.Mesh(_deathFillGeoShared, fillMat);\n\n  const group = new THREE.Group();\n  group.add(ringMesh);\n  group.add(fillMesh);\n  group.position.set(enemy.pos.x, 0.05, enemy.pos.z);\n  // Start tiny, will scale up\n  group.scale.set(0.1, 0.1, 0.1);\n  sceneRef.add(group);\n\n  enemy.deathTelegraph = {\n    group,\n    ringMat,\n    fillMat,\n    targetRadius: radius,\n  };\n}\n\nfunction updateDeathTelegraph(enemy: any, _dt: number) {\n  const tg = enemy.deathTelegraph;\n  if (!tg) return;\n\n  const cfg = enemy.config.deathExplosion;\n  const duration = (cfg.telegraphDuration || 200) / 1000;\n  const elapsed = (cfg.telegraphDuration - enemy.deathTimer) / 1000;\n  const t = Math.min(elapsed / duration, 1);\n\n  // Scale from tiny to target radius\n  const scale = tg.targetRadius * t;\n  tg.group.scale.set(scale, scale, scale);\n\n  // Follow the enemy position (can be pushed)\n  tg.group.position.set(enemy.pos.x, 0.05, enemy.pos.z);\n\n  // Pulsing opacity on ring\n  const pulse = 0.5 + 0.3 * Math.sin(performance.now() * 0.02);\n  tg.ringMat.opacity = pulse;\n  tg.fillMat.opacity = 0.12 + 0.08 * t;\n}\n\nfunction removeDeathTelegraph(enemy: any) {\n  const tg = enemy.deathTelegraph;\n  if (!tg) return;\n  tg.ringMat.dispose();\n  tg.fillMat.dispose();\n  // geometry is shared \u2014 don't dispose\n  sceneRef.remove(tg.group);\n  enemy.deathTelegraph = null;\n}\n\n// --- Death explosion (crystal golem etc.) ---\n\nfunction onDeathExplosion(enemy: any, gameState: any) {\n  const cfg = enemy.config.deathExplosion;\n  const x = enemy.pos.x;\n  const z = enemy.pos.z;\n\n  // Screen shake\n  screenShake(5, 250);\n\n  // Show \"BOOM\" text on dying enemy\n  const colorStr = '#' + cfg.color.toString(16).padStart(6, '0');\n  spawnDamageNumber(x, z, 'BOOM', colorStr);\n\n  // AoE effect \u2014 damages nearby enemies with cascade visual\n  applyAoeEffect({\n    x,\n    z,\n    radius: cfg.radius,\n    durationMs: cfg.ringDuration || 400,\n    color: cfg.color,\n    label: cfg.damage + '',\n    effectFn: (e: any) => {\n      e.health -= cfg.damage;\n      if (cfg.stunDuration > 0) {\n        stunEnemy(e, cfg.stunDuration);\n      }\n    },\n    gameState,\n    excludeEnemy: enemy, // exclude the dying enemy itself\n  });\n\n  // Check player damage\n  const pp = getPlayerPos();\n  const pdx = pp.x - x;\n  const pdz = pp.z - z;\n  const playerDist = Math.sqrt(pdx * pdx + pdz * pdz);\n  if (playerDist < cfg.radius && !isPlayerInvincible()) {\n    gameState.playerHealth -= cfg.damage;\n    screenShake(4, 200);\n    spawnDamageNumber(pp.x, pp.z, cfg.damage, '#ff4466');\n    if (gameState.playerHealth <= 0) {\n      gameState.playerHealth = 0;\n      gameState.phase = 'gameOver';\n    }\n  }\n}\n\nfunction behaviorTank(enemy: any, playerPos: any, dt: number, gameState: any) {\n  const tank = enemy.config.tank || {};\n  _toPlayer.subVectors(playerPos, enemy.pos);\n  _toPlayer.y = 0;\n  const dist = _toPlayer.length();\n\n  // If in melee attack cycle, update that and skip movement\n  if (enemy.meleePhase !== 'idle') {\n    updateEnemyMelee(enemy, dt, playerPos, gameState);\n    return;\n  }\n\n  const slowFactor = enemy.slowTimer > 0 ? enemy.slowMult : 1;\n  const slideBoost = enemy.wasDeflected ? 1.175 : 1.0;\n  const iceEffects = getIceEffects(enemy.pos.x, enemy.pos.z, false);\n  const baseSpeed = enemy.config.speed * MOB_GLOBAL.speedMult;\n\n  if (enemy.isCharging) {\n    // Charge forward at multiplied speed\n    const speedMult = tank.chargeSpeedMult || 3;\n    enemy.pos.x += enemy.chargeDir.x * baseSpeed * speedMult * slowFactor * slideBoost * iceEffects.speedMult * dt;\n    enemy.pos.z += enemy.chargeDir.z * baseSpeed * speedMult * slowFactor * slideBoost * iceEffects.speedMult * dt;\n    enemy.chargeTimer -= dt * 1000;\n\n    if (enemy.chargeTimer <= 0) {\n      enemy.isCharging = false;\n      const cdMin = tank.chargeCooldownMin || 3000;\n      const cdMax = tank.chargeCooldownMax || 5000;\n      enemy.chargeCooldown = cdMin + Math.random() * (cdMax - cdMin);\n    }\n  } else {\n    // Check if close enough for melee swing (when charge is on cooldown or too close)\n    const meleeCfg = enemy.config.melee;\n    if (meleeCfg && dist <= meleeCfg.hitRange) {\n      const now = performance.now();\n      if (now - enemy.lastAttackTime > enemy.config.attackRate) {\n        startEnemyMelee(enemy);\n        return;\n      }\n    }\n\n    // Normal slow movement toward player\n    if (dist > 1) {\n      _toPlayer.normalize();\n      enemy.pos.x += _toPlayer.x * baseSpeed * slowFactor * slideBoost * iceEffects.speedMult * dt;\n      enemy.pos.z += _toPlayer.z * baseSpeed * slowFactor * slideBoost * iceEffects.speedMult * dt;\n    }\n\n    // Charge cooldown\n    enemy.chargeCooldown -= dt * 1000;\n    const minD = tank.chargeMinDist || 2;\n    const maxD = tank.chargeMaxDist || 10;\n    if (enemy.chargeCooldown <= 0 && dist < maxD && dist > minD) {\n      // Start charge \u2014 telegraph with flash\n      enemy.isCharging = true;\n      enemy.chargeTimer = tank.chargeDuration || 500;\n      _toPlayer.subVectors(playerPos, enemy.pos).normalize();\n      enemy.chargeDir.copy(_toPlayer);\n\n      // Telegraph flash\n      const telegraphMs = tank.telegraphDuration || 300;\n      enemy.flashTimer = telegraphMs;\n      enemy.bodyMesh.material.emissive.setHex(0xffffff);\n      if (enemy.headMesh) enemy.headMesh.material.emissive.setHex(0xffffff);\n    }\n  }\n\n  // Face movement direction\n  if (dist > 0.1) {\n    const nx = (playerPos.x - enemy.pos.x);\n    const nz = (playerPos.z - enemy.pos.z);\n    const l = Math.sqrt(nx * nx + nz * nz);\n    if (l > 0) {\n      enemy.mesh.rotation.y = Math.atan2(-nx / l, -nz / l);\n    }\n  }\n}\n\nexport function slowEnemy(enemy: any, durationMs: number, mult: number) {\n  enemy.slowTimer = durationMs;\n  enemy.slowMult = mult;\n}\n\nexport function stunEnemy(enemy: any, durationMs: number) {\n  enemy.stunTimer = durationMs;\n  // Cancel any active charge\n  enemy.isCharging = false;\n  // Cancel melee attack\n  if (enemy.meleePhase !== 'idle') {\n    enemy.meleePhase = 'idle';\n    enemy.bodyMesh.material.emissive.setHex(enemy.config.emissive);\n    if (enemy.headMesh) enemy.headMesh.material.emissive.setHex(enemy.config.emissive);\n  }\n  // Cancel sniper telegraph (shot will still fire visually but enemy resets state)\n  if (enemy.sniperPhase === 'telegraphing') {\n    enemy.sniperPhase = 'idle';\n  }\n  // Cancel mortar aim\n  if (enemy.mortarPhase === 'aiming') {\n    enemy.mortarPhase = 'idle';\n    removeMortarArcLine(enemy);\n    removeMortarGroundCircle(enemy);\n  }\n}\n\nexport function stunEnemiesInRadius(centerPos: any, radius: number, durationMs: number, gameState: any) {\n  const r2 = radius * radius;\n  for (const enemy of gameState.enemies) {\n    const dx = enemy.pos.x - centerPos.x;\n    const dz = enemy.pos.z - centerPos.z;\n    if (dx * dx + dz * dz < r2) {\n      stunEnemy(enemy, durationMs);\n    }\n  }\n}\n\nexport function clearEnemies(gameState: any) {\n  clearVisionCones();\n  clearAggroIndicators();\n  for (const enemy of gameState.enemies) {\n    // Clean up shield mesh if present\n    if (enemy.shieldMesh) {\n      enemy.shieldMesh.geometry.dispose();\n      enemy.shieldMesh.material.dispose();\n    }\n    // Clean up mortar visuals\n    removeMortarArcLine(enemy);\n    removeMortarGroundCircle(enemy);\n    // Clean up death telegraph if active\n    removeDeathTelegraph(enemy);\n    sceneRef.remove(enemy.mesh);\n  }\n  gameState.enemies.length = 0;\n\n  // Invalidate cached bounds (level editor may have changed arena)\n  _collisionBounds = null;\n  _pitBoundsCache = null;\n}\n", "// Mortar projectile system \u2014 lobbed arc projectiles with AoE impact\n// Each projectile travels along a parabolic arc, then explodes on landing.\n// Ice Mortar Imps leave behind ice patches that affect movement and knockback.\n\nimport { applyAoeEffect } from '../engine/aoeTelegraph';\nimport { getPlayerPos, isPlayerInvincible } from './player';\nimport { slowEnemy } from './enemy';\nimport { screenShake } from '../engine/renderer';\nimport { spawnDamageNumber } from '../ui/damageNumbers';\n\nlet sceneRef: any;\n\n// Active mortar projectiles in flight\nconst activeMortars: any[] = [];\n\n// Active ice patches on the ground\nconst activeIcePatches: any[] = [];\n\n// Shared geometry (created once)\nlet shellGeo: any;\n\nexport function initMortarSystem(scene: any) {\n  sceneRef = scene;\n}\n\n/**\n * Fire a mortar projectile along a parabolic arc.\n */\nexport function fireMortarProjectile(opts: any) {\n  if (!shellGeo) {\n    shellGeo = new THREE.SphereGeometry(0.15, 6, 4);\n  }\n\n  const mat = new THREE.MeshStandardMaterial({\n    color: opts.color,\n    emissive: opts.color,\n    emissiveIntensity: 0.8,\n  });\n\n  const mesh = new THREE.Mesh(shellGeo, mat);\n  mesh.position.set(opts.startX, 0.8, opts.startZ);\n  sceneRef.add(mesh);\n\n  // Create a glowing trail line behind the projectile\n  const trailPositions = new Float32Array(30 * 3); // 30-point trail\n  const trailGeo = new THREE.BufferGeometry();\n  trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));\n  const trailMat = new THREE.LineBasicMaterial({\n    color: opts.color,\n    transparent: true,\n    opacity: 0.5,\n    depthWrite: false,\n  });\n  const trail = new THREE.Line(trailGeo, trailMat);\n  sceneRef.add(trail);\n\n  // Calculate arc distance and total flight time\n  const dx = opts.targetX - opts.startX;\n  const dz = opts.targetZ - opts.startZ;\n  const groundDist = Math.sqrt(dx * dx + dz * dz);\n\n  // Approximate arc length (parabolic arc is longer than ground distance)\n  // Using a simple approximation: arcLen ~ groundDist + 2*arcHeight^2/groundDist\n  const arcLen = groundDist > 0.1\n    ? groundDist + 2 * opts.arcHeight * opts.arcHeight / groundDist\n    : opts.arcHeight * 2;\n  const flightTime = arcLen / opts.speed;\n\n  const mortar: any = {\n    mesh,\n    trail,\n    trailGeo,\n    trailMat,\n    mat,\n    startX: opts.startX,\n    startZ: opts.startZ,\n    targetX: opts.targetX,\n    targetZ: opts.targetZ,\n    arcHeight: opts.arcHeight,\n    flightTime,\n    elapsed: 0,\n    color: opts.color,\n    blastRadius: opts.blastRadius,\n    damage: opts.damage,\n    slowDuration: opts.slowDuration,\n    slowMult: opts.slowMult,\n    explosionDuration: opts.explosionDuration,\n    icePatch: opts.icePatch || null,\n    gameState: opts.gameState,\n    sourceEnemy: opts.sourceEnemy,\n    trailHistory: [], // past positions for trail\n    groundCircle: opts.groundCircle || null, // persistent ground circle from aim phase\n  };\n\n  activeMortars.push(mortar);\n  return mortar;\n}\n\n/**\n * Update all in-flight mortar projectiles.\n * Call this every frame from the game loop.\n */\nexport function updateMortarProjectiles(dt: number) {\n  for (let i = activeMortars.length - 1; i >= 0; i--) {\n    const m = activeMortars[i];\n    m.elapsed += dt;\n    const t = Math.min(m.elapsed / m.flightTime, 1);\n\n    // Interpolate position along parabolic arc\n    const x = m.startX + (m.targetX - m.startX) * t;\n    const z = m.startZ + (m.targetZ - m.startZ) * t;\n    const y = 0.8 + 4 * m.arcHeight * t * (1 - t); // parabolic arc\n\n    m.mesh.position.set(x, y, z);\n\n    // Pulse glow\n    const pulse = 0.6 + 0.4 * Math.sin(performance.now() * 0.01);\n    m.mat.emissiveIntensity = pulse;\n\n    // Update trail\n    m.trailHistory.push({ x, y, z });\n    if (m.trailHistory.length > 30) m.trailHistory.shift();\n\n    const positions = m.trailGeo.attributes.position.array;\n    for (let j = 0; j < 30; j++) {\n      const idx = j < m.trailHistory.length ? j : m.trailHistory.length - 1;\n      const p = m.trailHistory[idx];\n      positions[j * 3] = p.x;\n      positions[j * 3 + 1] = p.y;\n      positions[j * 3 + 2] = p.z;\n    }\n    m.trailGeo.attributes.position.needsUpdate = true;\n    m.trailGeo.setDrawRange(0, m.trailHistory.length);\n\n    // Trail fades as projectile progresses\n    m.trailMat.opacity = 0.5 * (1 - t * 0.5);\n\n    // Update ground circle opacity \u2014 ramps from 0.3 -> 0.9 as projectile approaches\n    if (m.groundCircle) {\n      const gc = m.groundCircle;\n      // Ring: 0.3 at launch -> 0.9 at impact (never below 0.3)\n      const ringOpacity = 0.3 + 0.6 * t;\n      // Fill: 0.08 at launch -> 0.35 at impact\n      const fillOpacity = 0.08 + 0.27 * t;\n      // Pulse border for urgency\n      const gcPulse = 0.85 + 0.15 * Math.sin(performance.now() * (0.006 + 0.012 * t));\n      gc.ringMat.opacity = ringOpacity * gcPulse;\n      gc.fillMat.opacity = fillOpacity;\n    }\n\n    // Impact \u2014 projectile has landed\n    if (t >= 1) {\n      onMortarImpact(m);\n      removeMortar(m);\n      activeMortars.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Handle mortar impact \u2014 AoE damage + slow + visual.\n */\nfunction onMortarImpact(m: any) {\n  const tx = m.targetX;\n  const tz = m.targetZ;\n\n  // Screen shake on impact\n  screenShake(3, 150);\n\n  // AoE effect \u2014 damages and slows all enemies in blast radius\n  applyAoeEffect({\n    x: tx,\n    z: tz,\n    radius: m.blastRadius,\n    durationMs: m.explosionDuration,\n    color: m.color,\n    label: 'SLOWED',\n    effectFn: (e: any) => {\n      e.health -= m.damage;\n      slowEnemy(e, m.slowDuration, m.slowMult);\n    },\n    gameState: m.gameState,\n    excludeEnemy: m.sourceEnemy,\n  });\n\n  // Check player damage\n  const pp = getPlayerPos();\n  const pdx = pp.x - tx;\n  const pdz = pp.z - tz;\n  const playerDist = Math.sqrt(pdx * pdx + pdz * pdz);\n  if (playerDist < m.blastRadius && !isPlayerInvincible()) {\n    m.gameState.playerHealth -= m.damage;\n    screenShake(4, 200);\n    spawnDamageNumber(pp.x, pp.z, m.damage, '#ff4466');\n    if (m.gameState.playerHealth <= 0) {\n      m.gameState.playerHealth = 0;\n      m.gameState.phase = 'gameOver';\n    }\n  }\n\n  // Create ice patch if enabled\n  if (m.icePatch && m.icePatch.enabled) {\n    createIcePatch(tx, tz, m.blastRadius, m.icePatch);\n  }\n}\n\n/**\n * Create a persistent ice patch on the ground.\n */\nfunction createIcePatch(x: number, z: number, radius: number, config: any) {\n  // Create visual ice patch (flat circle on ground)\n  const geo = new THREE.CircleGeometry(radius, 32);\n  geo.rotateX(-Math.PI / 2); // lay flat\n\n  const mat = new THREE.MeshBasicMaterial({\n    color: config.color || 0x80E0FF,\n    transparent: true,\n    opacity: 0.5,\n    side: THREE.DoubleSide,\n    depthWrite: false,\n  });\n\n  const mesh = new THREE.Mesh(geo, mat);\n  mesh.position.set(x, 0.02, z); // slightly above ground to avoid z-fighting\n  sceneRef.add(mesh);\n\n  const patch = {\n    x,\n    z,\n    radius,\n    mesh,\n    mat,\n    geo,\n    duration: config.duration,\n    elapsed: 0,\n    speedMult: config.speedMult,\n    knockbackMult: config.knockbackMult,\n    affectsPlayer: config.affectsPlayer,\n    affectsEnemies: config.affectsEnemies,\n  };\n\n  activeIcePatches.push(patch);\n  return patch;\n}\n\n/**\n * Update all ice patches \u2014 handle duration and fading.\n */\nexport function updateIcePatches(dt: number) {\n  for (let i = activeIcePatches.length - 1; i >= 0; i--) {\n    const patch = activeIcePatches[i];\n    patch.elapsed += dt * 1000;\n\n    // Fade out in last 500ms\n    const remaining = patch.duration - patch.elapsed;\n    if (remaining < 500) {\n      patch.mat.opacity = 0.5 * (remaining / 500);\n    }\n\n    // Remove when expired\n    if (patch.elapsed >= patch.duration) {\n      patch.geo.dispose();\n      patch.mat.dispose();\n      sceneRef.remove(patch.mesh);\n      activeIcePatches.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Check if a position is on any ice patch.\n * Returns the ice patch config if on ice, null otherwise.\n */\nexport function getIcePatchAt(x: number, z: number) {\n  for (const patch of activeIcePatches) {\n    const dx = x - patch.x;\n    const dz = z - patch.z;\n    const dist = Math.sqrt(dx * dx + dz * dz);\n    if (dist <= patch.radius) {\n      return patch;\n    }\n  }\n  return null;\n}\n\n/**\n * Get ice effect multipliers for an entity at position.\n */\nexport function getIceEffects(x: number, z: number, isPlayer: boolean) {\n  const patch = getIcePatchAt(x, z);\n  if (!patch) {\n    return { speedMult: 1.0, knockbackMult: 1.0 };\n  }\n\n  // Check if this entity type is affected\n  if (isPlayer && !patch.affectsPlayer) {\n    return { speedMult: 1.0, knockbackMult: 1.0 };\n  }\n  if (!isPlayer && !patch.affectsEnemies) {\n    return { speedMult: 1.0, knockbackMult: 1.0 };\n  }\n\n  return {\n    speedMult: patch.speedMult,\n    knockbackMult: patch.knockbackMult,\n  };\n}\n\n/**\n * Clean up a mortar projectile's visual resources.\n */\nfunction removeMortar(m: any) {\n  m.mat.dispose();\n  sceneRef.remove(m.mesh);\n  m.trailGeo.dispose();\n  m.trailMat.dispose();\n  sceneRef.remove(m.trail);\n  // Clean up ground circle (geometry is shared \u2014 don't dispose)\n  if (m.groundCircle) {\n    const gc = m.groundCircle;\n    gc.ringMat.dispose();\n    gc.fillMat.dispose();\n    sceneRef.remove(gc.group);\n    m.groundCircle = null;\n  }\n}\n\n/**\n * Clear all in-flight mortar projectiles (on restart/cleanup).\n */\nexport function clearMortarProjectiles() {\n  for (const m of activeMortars) {\n    removeMortar(m);\n  }\n  activeMortars.length = 0;\n}\n\n/**\n * Clear all ice patches (on restart/cleanup).\n */\nexport function clearIcePatches() {\n  for (const patch of activeIcePatches) {\n    patch.geo.dispose();\n    patch.mat.dispose();\n    sceneRef.remove(patch.mesh);\n  }\n  activeIcePatches.length = 0;\n}\n", "// PlayerRig \u2014 Procedural bipedal mannequin built from box/sphere primitives.\n// Constructs a joint hierarchy suitable for procedural animation.\n// No external assets \u2014 everything is THREE.js primitives.\n\nimport { PLAYER } from '../config/player';\n\n// \u2500\u2500\u2500 Exported Types \u2500\u2500\u2500\n\nexport interface PlayerJoints {\n  rigRoot: any;    // whole-body transforms (squash/stretch, lean)\n  hip: any;        // pivot for legs, rotates to face movement direction\n  torso: any;      // upper body, inherits aim rotation from playerGroup\n  head: any;\n  shoulderL: any;\n  upperArmL: any;\n  lowerArmL: any;\n  shoulderR: any;\n  upperArmR: any;\n  lowerArmR: any;\n  thighL: any;\n  shinL: any;\n  thighR: any;\n  shinR: any;\n}\n\nexport interface PlayerRig {\n  joints: PlayerJoints;\n  meshes: any[];           // all Mesh objects (for world-position sampling)\n  materials: any[];        // all MeshStandardMaterial instances (for glow)\n}\n\n// \u2500\u2500\u2500 Proportions \u2500\u2500\u2500\n// Tuned for readability at isometric distance. Slightly exaggerated (big head, wide torso).\n\nconst P = {\n  // Overall scale reference\n  scale: 0.9,  // global multiplier if everything feels too big/small\n\n  // Hip (root of legs + torso)\n  hipY: 0.5,\n\n  // Torso\n  torsoWidth: 0.28,\n  torsoHeight: 0.32,\n  torsoDepth: 0.18,\n  torsoY: 0.22,  // above hip\n\n  // Head\n  headRadius: 0.16,\n  headY: 0.30,  // above torso\n\n  // Arms\n  shoulderOffsetX: 0.19,\n  shoulderY: 0.22,        // relative to torso (near top of torso)\n  upperArmWidth: 0.08,\n  upperArmHeight: 0.20,\n  upperArmDepth: 0.08,\n  upperArmY: -0.12,       // hangs down from shoulder\n  elbowY: -0.20,          // relative to upper arm\n  lowerArmWidth: 0.07,\n  lowerArmHeight: 0.18,\n  lowerArmDepth: 0.07,\n  lowerArmY: -0.10,       // hangs down from elbow\n\n  // Legs\n  legOffsetX: 0.09,\n  thighWidth: 0.10,\n  thighHeight: 0.24,\n  thighDepth: 0.10,\n  thighY: -0.14,          // hangs down from hip\n  kneeY: -0.24,           // relative to thigh\n  shinWidth: 0.08,\n  shinHeight: 0.22,\n  shinDepth: 0.08,\n  shinY: -0.12,           // hangs down from knee\n};\n\n// \u2500\u2500\u2500 Color Palette \u2500\u2500\u2500\n// Green family matching current player. Limbs slightly darker for depth.\n\nconst COLORS = {\n  torso:    { color: 0x44cc88, emissive: 0x22aa66, emissiveIntensity: 0.4 },\n  head:     { color: 0x55ddaa, emissive: 0x33bb88, emissiveIntensity: 0.5 },\n  arm:      { color: 0x3ab87a, emissive: 0x1e9960, emissiveIntensity: 0.35 },\n  leg:      { color: 0x38b575, emissive: 0x1c9658, emissiveIntensity: 0.35 },\n  fist:     { color: 0x55ddaa, emissive: 0x33bb88, emissiveIntensity: 0.5 },\n};\n\n// \u2500\u2500\u2500 Shared Geometry Cache (created once) \u2500\u2500\u2500\n\nlet _torsoGeo: any = null;\nlet _headGeo: any = null;\nlet _upperArmGeo: any = null;\nlet _lowerArmGeo: any = null;\nlet _thighGeo: any = null;\nlet _shinGeo: any = null;\nlet _fistGeo: any = null;\n\nfunction ensureGeometry() {\n  if (_torsoGeo) return;\n  _torsoGeo    = new THREE.BoxGeometry(P.torsoWidth, P.torsoHeight, P.torsoDepth);\n  _headGeo     = new THREE.SphereGeometry(P.headRadius, 8, 6);\n  _upperArmGeo = new THREE.BoxGeometry(P.upperArmWidth, P.upperArmHeight, P.upperArmDepth);\n  _lowerArmGeo = new THREE.BoxGeometry(P.lowerArmWidth, P.lowerArmHeight, P.lowerArmDepth);\n  _thighGeo    = new THREE.BoxGeometry(P.thighWidth, P.thighHeight, P.thighDepth);\n  _shinGeo     = new THREE.BoxGeometry(P.shinWidth, P.shinHeight, P.shinDepth);\n  _fistGeo = new THREE.BoxGeometry(0.10, 0.08, 0.10);  // chunky fist \u2014 wider than forearm for readability\n}\n\nfunction makeMat(palette: { color: number; emissive: number; emissiveIntensity: number }) {\n  return new THREE.MeshStandardMaterial({\n    color: palette.color,\n    emissive: palette.emissive,\n    emissiveIntensity: palette.emissiveIntensity,\n  });\n}\n\n// \u2500\u2500\u2500 Rig Construction \u2500\u2500\u2500\n\nexport function createPlayerRig(parentGroup: any): PlayerRig {\n  ensureGeometry();\n\n  const meshes: any[] = [];\n  const materials: any[] = [];\n\n  function addMesh(geo: any, palette: any, parent: any, x = 0, y = 0, z = 0) {\n    const mat = makeMat(palette);\n    const mesh = new THREE.Mesh(geo, mat);\n    mesh.position.set(x, y, z);\n    parent.add(mesh);\n    meshes.push(mesh);\n    materials.push(mat);\n    return mesh;\n  }\n\n  // rigRoot \u2014 whole-body transforms (squash/stretch, forward lean)\n  const rigRoot = new THREE.Group();\n  rigRoot.scale.setScalar(P.scale);\n  parentGroup.add(rigRoot);\n\n  // Hip \u2014 root of legs + torso\n  const hip = new THREE.Group();\n  hip.position.y = P.hipY;\n  rigRoot.add(hip);\n\n  // Torso \u2014 upper body pivot (inherits aim from playerGroup via hierarchy)\n  const torso = new THREE.Group();\n  torso.position.y = P.torsoY;\n  hip.add(torso);\n\n  // Torso mesh\n  addMesh(_torsoGeo, COLORS.torso, torso, 0, P.torsoHeight / 2, 0);\n\n  // Head\n  const head = new THREE.Group();\n  head.position.y = P.torsoHeight + P.headY * 0.5;\n  torso.add(head);\n  addMesh(_headGeo, COLORS.head, head, 0, 0, 0);\n\n  // \u2500\u2500\u2500 Arms \u2500\u2500\u2500\n\n  // Left shoulder pivot (attached to torso)\n  const shoulderL = new THREE.Group();\n  shoulderL.position.set(-P.shoulderOffsetX, P.shoulderY, 0);\n  torso.add(shoulderL);\n\n  // Left upper arm pivot\n  const upperArmL = new THREE.Group();\n  shoulderL.add(upperArmL);\n  addMesh(_upperArmGeo, COLORS.arm, upperArmL, 0, P.upperArmY, 0);\n\n  // Left elbow \u2192 lower arm\n  const lowerArmL = new THREE.Group();\n  lowerArmL.position.y = P.elbowY;\n  upperArmL.add(lowerArmL);\n  addMesh(_lowerArmGeo, COLORS.arm, lowerArmL, 0, P.lowerArmY, 0);\n  addMesh(_fistGeo, COLORS.fist, lowerArmL, 0, P.lowerArmY - P.lowerArmHeight / 2 - 0.02, 0);  // fist at end of forearm\n\n  // Right shoulder pivot\n  const shoulderR = new THREE.Group();\n  shoulderR.position.set(P.shoulderOffsetX, P.shoulderY, 0);\n  torso.add(shoulderR);\n\n  // Right upper arm pivot\n  const upperArmR = new THREE.Group();\n  shoulderR.add(upperArmR);\n  addMesh(_upperArmGeo, COLORS.arm, upperArmR, 0, P.upperArmY, 0);\n\n  // Right elbow \u2192 lower arm\n  const lowerArmR = new THREE.Group();\n  lowerArmR.position.y = P.elbowY;\n  upperArmR.add(lowerArmR);\n  addMesh(_lowerArmGeo, COLORS.arm, lowerArmR, 0, P.lowerArmY, 0);\n  addMesh(_fistGeo, COLORS.fist, lowerArmR, 0, P.lowerArmY - P.lowerArmHeight / 2 - 0.02, 0);  // fist at end of forearm\n\n  // \u2500\u2500\u2500 Legs \u2500\u2500\u2500\n\n  // Left thigh pivot (attached to hip)\n  const thighL = new THREE.Group();\n  thighL.position.set(-P.legOffsetX, 0, 0);\n  hip.add(thighL);\n  addMesh(_thighGeo, COLORS.leg, thighL, 0, P.thighY, 0);\n\n  // Left knee \u2192 shin\n  const shinL = new THREE.Group();\n  shinL.position.y = P.kneeY;\n  thighL.add(shinL);\n  addMesh(_shinGeo, COLORS.leg, shinL, 0, P.shinY, 0);\n\n  // Right thigh pivot\n  const thighR = new THREE.Group();\n  thighR.position.set(P.legOffsetX, 0, 0);\n  hip.add(thighR);\n  addMesh(_thighGeo, COLORS.leg, thighR, 0, P.thighY, 0);\n\n  // Right knee \u2192 shin\n  const shinR = new THREE.Group();\n  shinR.position.y = P.kneeY;\n  thighR.add(shinR);\n  addMesh(_shinGeo, COLORS.leg, shinR, 0, P.shinY, 0);\n\n  return {\n    joints: {\n      rigRoot,\n      hip,\n      torso,\n      head,\n      shoulderL,\n      upperArmL,\n      lowerArmL,\n      shoulderR,\n      upperArmR,\n      lowerArmR,\n      thighL,\n      shinL,\n      thighR,\n      shinR,\n    },\n    meshes,\n    materials,\n  };\n}\n\n// \u2500\u2500\u2500 Afterimage Helpers \u2500\u2500\u2500\n\n// Shared ghost geometries (simplified \u2014 just torso + head for performance)\nlet _ghostTorsoGeo: any = null;\nlet _ghostHeadGeo: any = null;\n\nexport function getGhostGeometries() {\n  if (!_ghostTorsoGeo) {\n    _ghostTorsoGeo = new THREE.BoxGeometry(P.torsoWidth * P.scale, P.torsoHeight * P.scale, P.torsoDepth * P.scale);\n    _ghostHeadGeo  = new THREE.SphereGeometry(P.headRadius * P.scale, 6, 4);\n  }\n  return { torso: _ghostTorsoGeo, head: _ghostHeadGeo };\n}\n", "// PlayerAnimator \u2014 Procedural animation state machine for the bipedal rig.\n// Drives joint rotations for idle, run, dash, and end lag.\n// Designed for snappy, commitment-based combat feel (Hades/HLD/Ys).\n//\n// Key concept: upper/lower body separation.\n// - playerGroup.rotation.y = aim direction (set by player.ts, torso inherits this)\n// - hip.rotation.y = offset from aim to movement direction (legs face where you're going)\n\nimport type { PlayerJoints } from './playerRig';\n\n// \u2500\u2500\u2500 Tuning Config \u2500\u2500\u2500\n// All timing/amplitude constants in one place for easy iteration.\n\nexport const C = {\n  // Run cycle\n  runCycleRate: 0.4,           // full leg cycles per world unit traveled\n  strideAngle: 0.6,           // radians (~35\u00B0) thigh swing amplitude\n  kneeBendMax: 0.8,           // radians (~45\u00B0) maximum forward knee bend\n  armSwingRatio: 0.6,         // arm swing as fraction of leg amplitude\n  forearmLag: 0.3,            // phase offset for forearm (secondary motion)\n  bodyBounceHeight: 0.03,     // world units of vertical bounce per step\n  forwardLean: 0.09,          // radians (~5\u00B0) lean into movement\n  forwardLeanSpeed: 8,        // how fast lean blends in/out (per second)\n\n  // Idle\n  breathRate: 2,              // Hz\n  breathAmplitude: 0.02,      // world units\n  weightShiftRate: 0.8,       // Hz\n  weightShiftAngle: 0.04,     // radians (~2.3\u00B0)\n  headDriftRate: 0.5,         // Hz\n  headDriftAngle: 0.02,       // radians (~1\u00B0)\n  idleArmDroop: 0.15,         // radians \u2014 slight outward droop\n\n  // Dash squash/stretch\n  squashScaleY: 0.75,\n  squashScaleXZ: 1.15,\n  stretchScaleY: 1.12,\n  stretchScaleXZ: 0.92,\n  dashLeanAngle: 0.26,        // radians (~15\u00B0) aggressive forward lean\n  dashArmSweep: -0.8,         // radians \u2014 arms swept back\n  dashLegLunge: 0.7,          // radians \u2014 front leg forward\n  dashLegTrail: -0.5,         // radians \u2014 back leg behind\n\n  // Airborne\n  jumpTuckAngle: 0.7,         // radians \u2014 thigh tuck during jump rise\n  jumpKneeBend: 0.9,          // radians \u2014 knee bend during tuck\n  jumpArmRaise: -0.4,         // radians \u2014 arms rise slightly\n  fallSpreadAngle: 0.35,      // radians \u2014 legs spread slightly during fall\n  fallArmRaise: -0.6,         // radians \u2014 arms rise higher in freefall\n  slamTuckAngle: 1.0,         // radians \u2014 tight tuck during slam\n  slamArmAngle: 0.8,          // radians \u2014 arms up overhead during slam\n  airSquashY: 1.1,            // stretch on jump rise\n  airSquashXZ: 0.92,          // compress X/Z on jump rise\n  slamStretchY: 0.8,          // compress on slam descent\n  slamStretchXZ: 1.15,        // widen on slam descent\n\n  // Transitions (ms)\n  idleToRunBlend: 80,\n  runToIdleBlend: 120,\n  endLagToNormalBlend: 60,\n\n  // Upper/lower body\n  hipTurnSpeed: 15,           // radians/sec \u2014 how fast legs reorient to movement direction\n};\n\n// \u2500\u2500\u2500 Animation State \u2500\u2500\u2500\n\nexport type AnimState = 'idle' | 'run' | 'dash' | 'endLag' | 'swing' | 'jump' | 'fall' | 'slam' | 'charge' | 'chargeRelease';\n\nexport interface AnimatorState {\n  currentState: AnimState;\n  prevState: AnimState;\n  stateTimer: number;          // seconds in current state\n  blendTimer: number;          // seconds remaining in transition blend\n  blendDuration: number;       // total blend duration in seconds\n  runCyclePhase: number;       // 0\u20131 oscillator for run cycle\n  moveDir: number;             // world-space angle of movement direction (radians)\n  moveDirSmoothed: number;     // lerped version for smooth leg turning\n  currentLean: number;         // current forward lean (smoothed)\n  dashDir: number;             // direction of dash (for squash orientation)\n  dashT: number;               // 0\u20131 progress through dash\n  time: number;                // accumulated time for idle oscillations\n  punchSide: number;           // 0 = right (cross), 1 = left (jab) \u2014 alternates\n  chargeT: number;             // 0\u20131 charge progress (mirrors gameState)\n  chargeReleaseTimer: number;  // counts up during release animation\n}\n\nexport function createAnimatorState(): AnimatorState {\n  return {\n    currentState: 'idle',\n    prevState: 'idle',\n    stateTimer: 0,\n    blendTimer: 0,\n    blendDuration: 0,\n    runCyclePhase: 0,\n    moveDir: 0,\n    moveDirSmoothed: 0,\n    currentLean: 0,\n    dashDir: 0,\n    dashT: 0,\n    time: 0,\n    punchSide: 0,\n    chargeT: 0,\n    chargeReleaseTimer: 0,\n  };\n}\n\nexport function resetAnimatorState(anim: AnimatorState) {\n  anim.currentState = 'idle';\n  anim.prevState = 'idle';\n  anim.stateTimer = 0;\n  anim.blendTimer = 0;\n  anim.blendDuration = 0;\n  anim.runCyclePhase = 0;\n  anim.currentLean = 0;\n  anim.dashT = 0;\n  anim.time = 0;\n}\n\n// \u2500\u2500\u2500 Easing Functions \u2500\u2500\u2500\n\nfunction easeOutBack(t: number): number {\n  const c1 = 1.70158;\n  const c3 = c1 + 1;\n  return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);\n}\n\nfunction easeOutQuad(t: number): number {\n  return 1 - (1 - t) * (1 - t);\n}\n\nfunction easeInOutQuad(t: number): number {\n  return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;\n}\n\nfunction clamp(v: number, min: number, max: number): number {\n  return v < min ? min : v > max ? max : v;\n}\n\nfunction lerpAngle(from: number, to: number, t: number): number {\n  // Shortest-path angle lerp\n  let diff = to - from;\n  while (diff > Math.PI) diff -= Math.PI * 2;\n  while (diff < -Math.PI) diff += Math.PI * 2;\n  return from + diff * t;\n}\n\n// \u2500\u2500\u2500 Main Update \u2500\u2500\u2500\n\nexport function updateAnimation(\n  joints: PlayerJoints,\n  anim: AnimatorState,\n  dt: number,\n  inputState: { moveX: number; moveZ: number },\n  aimAngle: number,\n  isDashing: boolean,\n  isInEndLag: boolean,\n  dashProgress: number,\n  isSwinging: boolean = false,\n  swingProgress: number = 0,\n  isAirborne: boolean = false,\n  velY: number = 0,\n  isSlamming: boolean = false,\n  isCharging: boolean = false,\n  chargeT: number = 0\n): void {\n  anim.time += dt;\n\n  // \u2500\u2500\u2500 State Transitions \u2500\u2500\u2500\n  const isMoving = Math.abs(inputState.moveX) > 0.01 || Math.abs(inputState.moveZ) > 0.01;\n  const prevState = anim.currentState;\n\n  if (isDashing) {\n    if (anim.currentState !== 'dash') {\n      transitionTo(anim, 'dash', 0);\n    }\n    anim.dashT = dashProgress;\n  } else if (isInEndLag) {\n    if (anim.currentState !== 'endLag') {\n      transitionTo(anim, 'endLag', 0);\n    }\n  } else if (isCharging) {\n    if (anim.currentState !== 'charge') {\n      transitionTo(anim, 'charge', 0);\n    }\n    anim.chargeT = chargeT;\n  } else if (anim.currentState === 'charge' && !isCharging) {\n    transitionTo(anim, 'chargeRelease', 0);\n    anim.chargeReleaseTimer = 0;\n  } else if (anim.currentState === 'chargeRelease') {\n    anim.chargeReleaseTimer += dt;\n    if (anim.chargeReleaseTimer >= 0.25) {\n      if (isMoving) {\n        transitionTo(anim, 'run', C.endLagToNormalBlend / 1000);\n      } else {\n        transitionTo(anim, 'idle', C.endLagToNormalBlend / 1000);\n      }\n    }\n  } else if (isSwinging) {\n    if (anim.currentState !== 'swing') {\n      transitionTo(anim, 'swing', 0);\n      anim.punchSide = 1 - anim.punchSide;\n    }\n    anim.dashT = swingProgress;\n  } else if (isAirborne && isSlamming) {\n    if (anim.currentState !== 'slam') {\n      transitionTo(anim, 'slam', 0);\n    }\n  } else if (isAirborne && velY > 0) {\n    if (anim.currentState !== 'jump') {\n      transitionTo(anim, 'jump', 0);\n    }\n  } else if (isAirborne) {\n    if (anim.currentState !== 'fall') {\n      transitionTo(anim, 'fall', 0);\n    }\n  } else if (isMoving) {\n    if (anim.currentState !== 'run') {\n      const blend = anim.currentState === 'endLag' || anim.currentState === 'swing'\n        ? C.endLagToNormalBlend : C.idleToRunBlend;\n      transitionTo(anim, 'run', blend / 1000);\n    }\n  } else {\n    if (anim.currentState !== 'idle') {\n      const blend = anim.currentState === 'endLag' || anim.currentState === 'swing'\n        ? C.endLagToNormalBlend : C.runToIdleBlend;\n      transitionTo(anim, 'idle', blend / 1000);\n    }\n  }\n\n  anim.stateTimer += dt;\n  if (anim.blendTimer > 0) {\n    anim.blendTimer = Math.max(0, anim.blendTimer - dt);\n  }\n\n  // \u2500\u2500\u2500 Movement Direction (for hip rotation) \u2500\u2500\u2500\n  if (isMoving) {\n    anim.moveDir = Math.atan2(-inputState.moveX, -inputState.moveZ);\n  }\n  // Smooth hip rotation toward movement direction\n  anim.moveDirSmoothed = lerpAngle(\n    anim.moveDirSmoothed,\n    anim.moveDir,\n    Math.min(1, C.hipTurnSpeed * dt)\n  );\n\n  // \u2500\u2500\u2500 Apply Pose \u2500\u2500\u2500\n  // Reset all joints to neutral first\n  resetJointsToNeutral(joints);\n\n  // Apply current state's pose\n  switch (anim.currentState) {\n    case 'idle':  applyIdle(joints, anim); break;\n    case 'run':   applyRun(joints, anim, dt, inputState); break;\n    case 'dash':  applyDash(joints, anim); break;\n    case 'endLag': applyEndLag(joints, anim); break;\n    case 'swing': applySwing(joints, anim); break;\n    case 'charge': applyCharge(joints, anim); break;\n    case 'chargeRelease': applyChargeRelease(joints, anim); break;\n    case 'jump': applyJump(joints, anim); break;\n    case 'fall': applyFall(joints, anim); break;\n    case 'slam': applySlam(joints, anim); break;\n  }\n\n  // \u2500\u2500\u2500 Upper/Lower Body Separation \u2500\u2500\u2500\n  // Hip rotates to face movement direction, offset from aim\n  // playerGroup.rotation.y = aimAngle (set externally)\n  // hip.rotation.y = moveDirSmoothed - aimAngle \u2192 legs face movement in world space\n  const hipOffset = anim.moveDirSmoothed - aimAngle;\n  joints.hip.rotation.y = hipOffset;\n\n  // \u2500\u2500\u2500 Forward Lean (smoothed) \u2500\u2500\u2500\n  const targetLean = (anim.currentState === 'run') ? C.forwardLean : 0;\n  anim.currentLean += (targetLean - anim.currentLean) * Math.min(1, C.forwardLeanSpeed * dt);\n  joints.rigRoot.rotation.x = anim.currentLean;\n\n  // During dash, override lean\n  if (anim.currentState === 'dash') {\n    joints.rigRoot.rotation.x = getDashLean(anim.dashT);\n  }\n}\n\n// \u2500\u2500\u2500 State Transition \u2500\u2500\u2500\n\nfunction transitionTo(anim: AnimatorState, newState: AnimState, blendDuration: number) {\n  anim.prevState = anim.currentState;\n  anim.currentState = newState;\n  anim.stateTimer = 0;\n  anim.blendDuration = blendDuration;\n  anim.blendTimer = blendDuration;\n\n  // Capture dash direction from movement direction when entering dash\n  if (newState === 'dash') {\n    anim.dashDir = anim.moveDir;\n    anim.dashT = 0;\n  }\n}\n\n// \u2500\u2500\u2500 Reset Joints \u2500\u2500\u2500\n\nfunction resetJointsToNeutral(joints: PlayerJoints) {\n  // Reset rotations\n  joints.rigRoot.rotation.set(0, 0, 0);\n  joints.rigRoot.scale.set(1, 1, 1);\n  joints.torso.rotation.set(0, 0, 0);\n  joints.head.rotation.set(0, 0, 0);\n  joints.upperArmL.rotation.set(0, 0, 0);\n  joints.lowerArmL.rotation.set(0, 0, 0);\n  joints.upperArmR.rotation.set(0, 0, 0);\n  joints.lowerArmR.rotation.set(0, 0, 0);\n  joints.thighL.rotation.set(0, 0, 0);\n  joints.shinL.rotation.set(0, 0, 0);\n  joints.thighR.rotation.set(0, 0, 0);\n  joints.shinR.rotation.set(0, 0, 0);\n  // Don't reset hip.rotation.y \u2014 set separately for upper/lower body split\n  joints.hip.rotation.x = 0;\n  joints.hip.rotation.z = 0;\n\n  // Reset positions to rig defaults (prevents cumulative drift from += animations)\n  joints.hip.position.y = 0.5;       // P.hipY from playerRig.ts\n  joints.torso.position.y = 0.22;    // P.torsoY from playerRig.ts\n}\n\n// \u2500\u2500\u2500 Idle Pose \u2500\u2500\u2500\n\nfunction applyIdle(joints: PlayerJoints, anim: AnimatorState) {\n  const t = anim.time;\n\n  // Breathing bob \u2014 torso rises and falls gently\n  joints.torso.position.y += Math.sin(t * C.breathRate * Math.PI * 2) * C.breathAmplitude;\n\n  // Weight shift \u2014 hip tilts side to side\n  joints.hip.rotation.z = Math.sin(t * C.weightShiftRate * Math.PI * 2) * C.weightShiftAngle;\n\n  // Head micro-drift \u2014 alive feel\n  joints.head.rotation.y = Math.sin(t * C.headDriftRate * Math.PI * 2) * C.headDriftAngle;\n\n  // Arms relaxed at sides \u2014 slight outward droop\n  joints.upperArmL.rotation.z = C.idleArmDroop;\n  joints.upperArmR.rotation.z = -C.idleArmDroop;\n\n  // Slight forearm bend (not ramrod straight)\n  joints.lowerArmL.rotation.x = -0.1;\n  joints.lowerArmR.rotation.x = -0.1;\n}\n\n// \u2500\u2500\u2500 Run Pose \u2500\u2500\u2500\n\nfunction applyRun(joints: PlayerJoints, anim: AnimatorState, dt: number, input: { moveX: number; moveZ: number }) {\n  // Advance run cycle based on distance traveled (not time)\n  const speed = Math.sqrt(input.moveX * input.moveX + input.moveZ * input.moveZ);\n  const distThisFrame = speed * 5 * dt; // speed normalized to ~0-1, times PLAYER.speed\n  anim.runCyclePhase = (anim.runCyclePhase + distThisFrame * C.runCycleRate) % 1;\n\n  const phase = anim.runCyclePhase * Math.PI * 2;\n\n  // \u2500\u2500\u2500 Legs \u2500\u2500\u2500\n  // Thigh swings forward/back\n  const thighSwing = Math.sin(phase) * C.strideAngle;\n  joints.thighL.rotation.x = thighSwing;\n  joints.thighR.rotation.x = -thighSwing;\n\n  // Knee bends forward only (anatomically correct)\n  // Offset phase so knee bends as leg swings back (follow-through)\n  const kneeL = Math.max(0, Math.sin(phase - 0.6)) * C.kneeBendMax;\n  const kneeR = Math.max(0, Math.sin(phase - 0.6 + Math.PI)) * C.kneeBendMax;\n  joints.shinL.rotation.x = -kneeL;  // negative = bend forward (flex)\n  joints.shinR.rotation.x = -kneeR;\n\n  // \u2500\u2500\u2500 Arms (counter-swing) \u2500\u2500\u2500\n  const armSwing = Math.sin(phase) * C.strideAngle * C.armSwingRatio;\n  joints.upperArmL.rotation.x = -armSwing;  // opposite to same-side leg\n  joints.upperArmR.rotation.x = armSwing;\n\n  // Forearm secondary motion (delayed, more swing)\n  const forearmSwing = Math.sin(phase - C.forearmLag) * C.strideAngle * C.armSwingRatio * 0.5;\n  joints.lowerArmL.rotation.x = -Math.abs(forearmSwing) - 0.15; // always slightly bent\n  joints.lowerArmR.rotation.x = -Math.abs(forearmSwing) - 0.15;\n\n  // \u2500\u2500\u2500 Body Bounce \u2500\u2500\u2500\n  // Hip bobs at 2\u00D7 leg frequency (bounces with each step)\n  const bounce = Math.abs(Math.sin(phase * 2)) * C.bodyBounceHeight;\n  joints.hip.position.y = 0.5 + bounce; // base hip Y from rig + bounce\n\n  // \u2500\u2500\u2500 Torso Twist \u2500\u2500\u2500\n  // Slight counter-rotation to arm swing (natural gait)\n  joints.torso.rotation.y = Math.sin(phase) * 0.06;\n}\n\n// \u2500\u2500\u2500 Dash Pose \u2500\u2500\u2500\n\nfunction applyDash(joints: PlayerJoints, anim: AnimatorState) {\n  const t = anim.dashT; // 0\u20131 through dash\n\n  // Three sub-phases: squash (0-0.15), stretch (0.15-0.85), settle (0.85-1.0)\n  if (t < 0.15) {\n    // SQUASH \u2014 compress on dash start\n    const subT = t / 0.15;\n    const ease = easeOutQuad(subT);\n\n    joints.rigRoot.scale.set(\n      1 + (C.squashScaleXZ - 1) * ease,\n      1 + (C.squashScaleY - 1) * ease,\n      1 + (C.squashScaleXZ - 1) * ease\n    );\n\n    // Legs snap to wide lunge\n    joints.thighL.rotation.x = C.dashLegLunge * ease;\n    joints.thighR.rotation.x = C.dashLegTrail * ease;\n    joints.shinL.rotation.x = -0.3 * ease;\n    joints.shinR.rotation.x = -0.4 * ease;\n\n    // Arms start sweeping back\n    joints.upperArmL.rotation.x = C.dashArmSweep * ease * 0.5;\n    joints.upperArmR.rotation.x = C.dashArmSweep * ease * 0.5;\n\n  } else if (t < 0.85) {\n    // STRETCH \u2014 elongate during travel\n    const subT = (t - 0.15) / 0.7;\n    const ease = easeOutQuad(subT);\n\n    joints.rigRoot.scale.set(\n      C.stretchScaleXZ,\n      C.stretchScaleY,\n      C.stretchScaleXZ\n    );\n\n    // Legs in mid-stride\n    joints.thighL.rotation.x = 0.4;\n    joints.thighR.rotation.x = -0.3;\n    joints.shinL.rotation.x = -0.5;\n    joints.shinR.rotation.x = -0.2;\n\n    // Arms swept fully back\n    joints.upperArmL.rotation.x = C.dashArmSweep;\n    joints.upperArmR.rotation.x = C.dashArmSweep;\n    joints.lowerArmL.rotation.x = C.dashArmSweep * 0.4;\n    joints.lowerArmR.rotation.x = C.dashArmSweep * 0.4;\n\n  } else {\n    // SETTLE \u2014 snap back with slight overshoot\n    const subT = (t - 0.85) / 0.15;\n    const ease = easeOutBack(Math.min(subT, 1));\n\n    // Scale returns to 1.0 with Y overshoot\n    const yScale = C.stretchScaleY + (1.0 - C.stretchScaleY) * ease;\n    const xzScale = C.stretchScaleXZ + (1.0 - C.stretchScaleXZ) * ease;\n    joints.rigRoot.scale.set(xzScale, yScale, xzScale);\n\n    // Legs plant into wide stance\n    const legSettle = 1 - ease;\n    joints.thighL.rotation.x = 0.3 * legSettle;\n    joints.thighR.rotation.x = -0.2 * legSettle;\n    joints.shinL.rotation.x = -0.3 * legSettle;\n    joints.shinR.rotation.x = -0.1 * legSettle;\n\n    // Arms relax\n    joints.upperArmL.rotation.x = C.dashArmSweep * (1 - ease);\n    joints.upperArmR.rotation.x = C.dashArmSweep * (1 - ease);\n  }\n}\n\nfunction getDashLean(t: number): number {\n  // Aggressive lean that eases in and settles out\n  if (t < 0.15) {\n    return C.dashLeanAngle * easeOutQuad(t / 0.15);\n  } else if (t < 0.85) {\n    return C.dashLeanAngle;\n  } else {\n    const subT = (t - 0.85) / 0.15;\n    return C.dashLeanAngle * (1 - easeOutQuad(subT));\n  }\n}\n\n// \u2500\u2500\u2500 End Lag Pose \u2500\u2500\u2500\n\nfunction applyEndLag(joints: PlayerJoints, anim: AnimatorState) {\n  // Short recovery \u2014 body settling from dash\n  const t = Math.min(anim.stateTimer / 0.05, 1); // 50ms end lag\n  const ease = easeOutQuad(t);\n\n  // Scale settles to neutral\n  const scaleY = 1 + (1.05 - 1) * (1 - ease); // slight overshoot settling down\n  joints.rigRoot.scale.set(1, scaleY, 1);\n\n  // Slight backward lean (deceleration)\n  joints.rigRoot.rotation.x = -0.06 * (1 - ease);\n\n  // Wide braking stance that settles\n  const legSpread = 0.25 * (1 - ease);\n  joints.thighL.rotation.x = legSpread;\n  joints.thighR.rotation.x = -legSpread;\n  joints.shinL.rotation.x = -legSpread * 0.5;\n  joints.shinR.rotation.x = -legSpread * 0.5;\n\n  // Arms settle forward\n  joints.upperArmL.rotation.x = -0.2 * (1 - ease);\n  joints.upperArmR.rotation.x = -0.2 * (1 - ease);\n}\n\n// \u2500\u2500\u2500 Melee Punch Pose (alternating jab/cross) \u2500\u2500\u2500\n// Full-body punch: torso twist, aggressive forward lean, lead foot steps forward,\n// rear foot pushes off, hip drops into the punch for weight transfer.\n\nfunction applySwing(joints: PlayerJoints, anim: AnimatorState) {\n  const t = clamp(anim.dashT, 0, 1);\n  const isLeft = anim.punchSide === 1;\n\n  const punchUpper = isLeft ? joints.upperArmL : joints.upperArmR;\n  const punchLower = isLeft ? joints.lowerArmL : joints.lowerArmR;\n  const guardUpper = isLeft ? joints.upperArmR : joints.upperArmL;\n  const guardLower = isLeft ? joints.lowerArmR : joints.lowerArmL;\n  const torsoTwistSign = isLeft ? 1 : -1;\n\n  const leadThigh = isLeft ? joints.thighL : joints.thighR;\n  const leadShin  = isLeft ? joints.shinL  : joints.shinR;\n  const rearThigh = isLeft ? joints.thighR : joints.thighL;\n  const rearShin  = isLeft ? joints.shinR  : joints.shinL;\n\n  if (t < 0.25) {\n    const subT = t / 0.25;\n    const ease = easeOutQuad(subT);\n\n    punchUpper.rotation.x = 0.35 * ease;\n    punchLower.rotation.x = -0.9 * ease;\n    guardUpper.rotation.x = -0.35 * ease;\n    guardLower.rotation.x = -0.75 * ease;\n    joints.torso.rotation.y = -0.25 * torsoTwistSign * ease;\n    joints.rigRoot.rotation.x = 0.04 * ease;\n    joints.hip.position.y = 0.5 - 0.02 * ease;\n    rearThigh.rotation.x = -0.12 * ease;\n    rearShin.rotation.x = -0.2 * ease;\n    leadThigh.rotation.x = 0.08 * ease;\n    leadShin.rotation.x = -0.05 * ease;\n    joints.hip.rotation.z = -0.03 * torsoTwistSign * ease;\n  } else {\n    const subT = (t - 0.25) / 0.75;\n    const ease = easeOutQuad(subT);\n\n    punchUpper.rotation.x = 0.35 + (-1.3 - 0.35) * ease;\n    punchLower.rotation.x = -0.9 + (0.9 - 0.12) * ease;\n    guardUpper.rotation.x = -0.35;\n    guardLower.rotation.x = -0.75;\n    joints.torso.rotation.y = (-0.25 + (0.4 + 0.25) * ease) * torsoTwistSign;\n\n    const leanCurve = subT < 0.35\n      ? easeOutQuad(subT / 0.35)\n      : 1 - 0.4 * easeOutQuad((subT - 0.35) / 0.65);\n    joints.rigRoot.rotation.x = 0.04 + 0.16 * leanCurve;\n\n    const hipDrop = subT < 0.3\n      ? easeOutQuad(subT / 0.3)\n      : 1 - 0.5 * easeOutQuad((subT - 0.3) / 0.7);\n    joints.hip.position.y = 0.5 - 0.02 - 0.025 * hipDrop;\n    joints.hip.rotation.z = (-0.03 + 0.08 * ease) * torsoTwistSign;\n\n    const stepCurve = subT < 0.4\n      ? easeOutQuad(subT / 0.4)\n      : 1 - 0.3 * easeOutQuad((subT - 0.4) / 0.6);\n    leadThigh.rotation.x = 0.08 + 0.35 * stepCurve;\n    leadShin.rotation.x = -0.05 - 0.25 * stepCurve;\n\n    const pushCurve = subT < 0.5\n      ? easeOutQuad(subT / 0.5)\n      : 1 - 0.2 * easeOutQuad((subT - 0.5) / 0.5);\n    rearThigh.rotation.x = -0.12 - 0.2 * pushCurve;\n    rearShin.rotation.x = -0.2 - 0.15 * pushCurve;\n  }\n}\n\n// \u2500\u2500\u2500 Force Push Charge Pose (looping gather) \u2500\u2500\u2500\nfunction applyCharge(joints: PlayerJoints, anim: AnimatorState) {\n  const chargeT = clamp(anim.chargeT, 0, 1);\n  const blendIn = clamp(anim.stateTimer / 0.15, 0, 1);\n  const ease = easeOutQuad(blendIn);\n  const loopRate = 3.5;\n  const sway = Math.sin(anim.time * loopRate * Math.PI * 2);\n  const swaySmall = Math.sin(anim.time * loopRate * 0.7 * Math.PI * 2);\n\n  const crouch = 0.04 + 0.04 * chargeT;\n  joints.hip.position.y = 0.5 - crouch * ease;\n  joints.thighL.rotation.x = 0.15 * ease;\n  joints.thighR.rotation.x = -0.15 * ease;\n  joints.thighL.rotation.z = 0.08 * ease;\n  joints.thighR.rotation.z = -0.08 * ease;\n  joints.shinL.rotation.x = -0.2 * ease;\n  joints.shinR.rotation.x = -0.2 * ease;\n\n  const armPull = 0.5 + 0.6 * chargeT;\n  const elbowFlare = 0.2 + 0.3 * chargeT;\n  joints.upperArmL.rotation.x = armPull * ease;\n  joints.upperArmR.rotation.x = armPull * ease;\n  joints.upperArmL.rotation.z = elbowFlare * ease;\n  joints.upperArmR.rotation.z = -elbowFlare * ease;\n  joints.lowerArmL.rotation.x = (-0.6 - 0.3 * chargeT) * ease;\n  joints.lowerArmR.rotation.x = (-0.6 - 0.3 * chargeT) * ease;\n\n  const leanBack = -0.06 - 0.08 * chargeT;\n  joints.rigRoot.rotation.x = leanBack * ease;\n  joints.torso.rotation.x = -0.04 * chargeT * ease;\n\n  const swayAmp = 0.02 + 0.03 * chargeT;\n  joints.torso.rotation.y = sway * swayAmp * ease;\n  joints.hip.rotation.z = swaySmall * 0.015 * ease;\n  const armPulse = sway * 0.06 * chargeT * ease;\n  joints.upperArmL.rotation.x += armPulse;\n  joints.upperArmR.rotation.x += armPulse;\n  joints.head.rotation.x = 0.08 * chargeT * ease;\n}\n\n// \u2500\u2500\u2500 Force Push Release Pose (double-palm push) \u2500\u2500\u2500\nfunction applyChargeRelease(joints: PlayerJoints, anim: AnimatorState) {\n  const t = clamp(anim.chargeReleaseTimer / 0.25, 0, 1);\n\n  if (t < 0.35) {\n    const subT = t / 0.35;\n    const ease = easeOutQuad(subT);\n\n    joints.upperArmL.rotation.x = (0.5 + (-1.4 - 0.5) * ease);\n    joints.upperArmR.rotation.x = (0.5 + (-1.4 - 0.5) * ease);\n    joints.lowerArmL.rotation.x = (-0.6 + (0.6 - 0.1) * ease);\n    joints.lowerArmR.rotation.x = (-0.6 + (0.6 - 0.1) * ease);\n    joints.upperArmL.rotation.z = (0.3 + (-0.3 - 0.3) * ease);\n    joints.upperArmR.rotation.z = (-0.3 + (0.3 + 0.3) * ease);\n    joints.rigRoot.rotation.x = (-0.1 + (0.22 + 0.1) * ease);\n    joints.hip.position.y = 0.5 - 0.06 * ease;\n    joints.thighL.rotation.x = 0.15 + 0.35 * ease;\n    joints.shinL.rotation.x = -0.2 - 0.2 * ease;\n    joints.thighR.rotation.x = -0.15 - 0.15 * ease;\n    joints.shinR.rotation.x = -0.2 - 0.1 * ease;\n    joints.torso.rotation.x = 0.06 * ease;\n  } else {\n    const subT = (t - 0.35) / 0.65;\n    const ease = easeOutQuad(subT);\n    const armRetract = 1 - ease;\n    joints.upperArmL.rotation.x = -1.4 * armRetract;\n    joints.upperArmR.rotation.x = -1.4 * armRetract;\n    joints.lowerArmL.rotation.x = -0.1 * armRetract;\n    joints.lowerArmR.rotation.x = -0.1 * armRetract;\n    joints.upperArmL.rotation.z = 0;\n    joints.upperArmR.rotation.z = 0;\n    joints.rigRoot.rotation.x = 0.22 * armRetract;\n    joints.hip.position.y = 0.5 - 0.06 * armRetract;\n    joints.thighL.rotation.x = 0.5 * armRetract;\n    joints.shinL.rotation.x = -0.4 * armRetract;\n    joints.thighR.rotation.x = -0.3 * armRetract;\n    joints.shinR.rotation.x = -0.3 * armRetract;\n    joints.torso.rotation.x = 0.06 * armRetract;\n  }\n}\n\n// \u2500\u2500\u2500 Jump Pose (rising) \u2500\u2500\u2500\nfunction applyJump(joints: PlayerJoints, anim: AnimatorState) {\n  const t = clamp(anim.stateTimer / 0.15, 0, 1);\n  const ease = easeOutQuad(t);\n\n  joints.rigRoot.scale.set(\n    1 + (C.airSquashXZ - 1) * ease,\n    1 + (C.airSquashY - 1) * ease,\n    1 + (C.airSquashXZ - 1) * ease\n  );\n  joints.thighL.rotation.x = -C.jumpTuckAngle * ease;\n  joints.thighR.rotation.x = -C.jumpTuckAngle * ease;\n  joints.shinL.rotation.x = C.jumpKneeBend * ease;\n  joints.shinR.rotation.x = C.jumpKneeBend * ease;\n  joints.upperArmL.rotation.x = C.jumpArmRaise * ease;\n  joints.upperArmR.rotation.x = C.jumpArmRaise * ease;\n  joints.upperArmL.rotation.z = 0.2 * ease;\n  joints.upperArmR.rotation.z = -0.2 * ease;\n  joints.lowerArmL.rotation.x = -0.3 * ease;\n  joints.lowerArmR.rotation.x = -0.3 * ease;\n  joints.rigRoot.rotation.x = -0.08 * ease;\n}\n\n// \u2500\u2500\u2500 Fall Pose (descending) \u2500\u2500\u2500\nfunction applyFall(joints: PlayerJoints, anim: AnimatorState) {\n  const t = clamp(anim.stateTimer / 0.2, 0, 1);\n  const ease = easeOutQuad(t);\n\n  joints.rigRoot.scale.set(1, 1, 1);\n  joints.thighL.rotation.x = C.fallSpreadAngle * ease;\n  joints.thighR.rotation.x = -C.fallSpreadAngle * 0.5 * ease;\n  joints.shinL.rotation.x = -0.3 * ease;\n  joints.shinR.rotation.x = -0.4 * ease;\n  joints.upperArmL.rotation.x = C.fallArmRaise * ease;\n  joints.upperArmR.rotation.x = C.fallArmRaise * ease;\n  joints.upperArmL.rotation.z = 0.4 * ease;\n  joints.upperArmR.rotation.z = -0.4 * ease;\n  joints.lowerArmL.rotation.x = -0.2 * ease;\n  joints.lowerArmR.rotation.x = -0.2 * ease;\n  joints.rigRoot.rotation.x = 0.1 * ease;\n}\n\n// \u2500\u2500\u2500 Slam Pose (fast downward \u2014 self-slam or dunk) \u2500\u2500\u2500\nfunction applySlam(joints: PlayerJoints, anim: AnimatorState) {\n  const t = clamp(anim.stateTimer / 0.1, 0, 1);\n  const ease = easeOutQuad(t);\n\n  joints.rigRoot.scale.set(\n    1 + (C.slamStretchXZ - 1) * ease,\n    1 + (C.slamStretchY - 1) * ease,\n    1 + (C.slamStretchXZ - 1) * ease\n  );\n  joints.thighL.rotation.x = -C.slamTuckAngle * ease;\n  joints.thighR.rotation.x = -C.slamTuckAngle * ease;\n  joints.shinL.rotation.x = C.jumpKneeBend * ease;\n  joints.shinR.rotation.x = C.jumpKneeBend * ease;\n  joints.upperArmL.rotation.x = -C.slamArmAngle * ease;\n  joints.upperArmR.rotation.x = -C.slamArmAngle * ease;\n  joints.upperArmL.rotation.z = 0.15 * ease;\n  joints.upperArmR.rotation.z = -0.15 * ease;\n  joints.lowerArmL.rotation.x = -0.5 * ease;\n  joints.lowerArmR.rotation.x = -0.5 * ease;\n  joints.rigRoot.rotation.x = 0.2 * ease;\n}\n", "import { addPlayerTag, removePlayerTagsMatching, addTag, removeTag, TAG } from './tags';\n\nexport interface LaunchedEnemy {\n  enemy: any;\n  launchTime: number;\n  claimedBy: string | null;\n  gravityMult: number;\n}\n\nconst launched: LaunchedEnemy[] = [];\n\nexport function registerLaunch(enemy: any): void {\n  if (launched.some(e => e.enemy === enemy)) return;\n  launched.push({\n    enemy,\n    launchTime: performance.now(),\n    claimedBy: null,\n    gravityMult: 1,\n  });\n}\n\nexport function claimLaunched(enemy: any, verbName: string): boolean {\n  const entry = launched.find(e => e.enemy === enemy);\n  if (!entry || entry.claimedBy !== null) return false;\n  entry.claimedBy = verbName;\n  return true;\n}\n\nexport function releaseLaunched(enemy: any): void {\n  const idx = launched.findIndex(e => e.enemy === enemy);\n  if (idx !== -1) launched.splice(idx, 1);\n}\n\nexport function getLaunched(): readonly LaunchedEnemy[] {\n  return launched;\n}\n\nexport function getUnclaimed(): LaunchedEnemy[] {\n  return launched.filter(e => e.claimedBy === null);\n}\n\nexport function getLaunchedEntry(enemy: any): LaunchedEnemy | undefined {\n  return launched.find(e => e.enemy === enemy);\n}\n\nexport function setGravityOverride(enemy: any, mult: number): void {\n  const entry = launched.find(e => e.enemy === enemy);\n  if (entry) entry.gravityMult = mult;\n}\n\nexport function clearLaunched(): void {\n  launched.length = 0;\n}\n\n// --------------- Verb Interface + Registration ---------------\n\nexport interface AerialVerb {\n  name: string;\n  tag?: string;          // Gameplay tag added when this verb is active\n  interruptible: boolean;\n  canClaim(entry: LaunchedEnemy, playerPos: any, inputState: any): boolean;\n  onClaim(entry: LaunchedEnemy): void;\n  update(dt: number, entry: LaunchedEnemy, playerPos: any, inputState: any): 'active' | 'complete' | 'cancel';\n  onCancel(entry: LaunchedEnemy): void;\n  onComplete(entry: LaunchedEnemy): void;\n}\n\nconst verbs: Map<string, AerialVerb> = new Map();\nlet activeVerb: AerialVerb | null = null;\nlet activeEnemy: any | null = null;\n\nexport function registerVerb(verb: AerialVerb): void {\n  verbs.set(verb.name, verb);\n}\n\nexport function clearVerbs(): void {\n  verbs.clear();\n  activeVerb = null;\n  activeEnemy = null;\n}\n\nexport function getActiveVerb(): AerialVerb | null {\n  return activeVerb;\n}\n\nexport function getActiveEnemy(): any | null {\n  return activeEnemy;\n}\n\n/** Unified check: is ANY aerial verb currently active? */\nexport function isAnyAerialVerbActive(): boolean {\n  return activeVerb !== null;\n}\n\nexport function activateVerb(verbName: string, enemy: any): void {\n  const verb = verbs.get(verbName);\n  if (!verb) return;\n  const entry = launched.find(e => e.enemy === enemy);\n  if (!entry) return;\n  activeVerb = verb;\n  activeEnemy = enemy;\n\n  // Add gameplay tags \u2014 player state + enemy stunned\n  addPlayerTag(TAG.AERIAL);\n  if (verb.tag) addPlayerTag(verb.tag);\n  addTag(enemy, TAG.STUNNED);\n\n  verb.onClaim(entry);\n}\n\nexport function transferClaim(enemy: any, toVerbName: string): void {\n  const verb = verbs.get(toVerbName);\n  if (!verb) return;\n  const entry = launched.find(e => e.enemy === enemy);\n  if (!entry) return;\n\n  // Remove old verb's specific tag (keep State.Aerial \u2014 still in aerial state)\n  if (activeVerb && activeVerb.tag) {\n    // Just remove old subtag; removePlayerTagsMatching would be too aggressive\n    removePlayerTagsMatching(activeVerb.tag);\n  }\n\n  entry.claimedBy = toVerbName;\n  activeVerb = verb;\n  activeEnemy = enemy;\n\n  // Add new verb's tag\n  if (verb.tag) addPlayerTag(verb.tag);\n\n  verb.onClaim(entry);\n}\n\n/** Remove all aerial gameplay tags and enemy stun (called on verb end) */\nfunction cleanupVerbTags(enemy?: any): void {\n  removePlayerTagsMatching(TAG.AERIAL);\n  if (enemy) removeTag(enemy, TAG.STUNNED);\n}\n\nexport function updateAerialVerbs(dt: number, playerPos?: any, inputState?: any): void {\n  if (!activeVerb || !activeEnemy) return;\n\n  const entry = launched.find(e => e.enemy === activeEnemy);\n\n  // Auto-cancel on enemy death or pit fall\n  if (!entry || activeEnemy.health <= 0 || activeEnemy.fellInPit) {\n    const enemyRef = activeEnemy;\n    activeVerb.onCancel(entry ?? { enemy: activeEnemy, launchTime: 0, claimedBy: null, gravityMult: 1 });\n    if (entry) releaseLaunched(activeEnemy);\n    activeVerb = null;\n    activeEnemy = null;\n    cleanupVerbTags(enemyRef);\n    return;\n  }\n\n  // Capture verb reference before update \u2014 verb may call transferClaim during update,\n  // which changes activeVerb. We need to know if a transfer happened.\n  const verbBeforeUpdate = activeVerb;\n\n  const result = verbBeforeUpdate.update(dt, entry, playerPos, inputState);\n\n  // Did a transfer happen during the update?\n  const transferred = activeVerb !== verbBeforeUpdate;\n\n  if (result === 'complete') {\n    if (transferred) {\n      // Transfer happened \u2014 the old verb returned 'complete' to signal it's done.\n      // Call the OLD verb's onComplete for cleanup. Don't touch framework state\n      // (transferClaim already set activeVerb/activeEnemy to the new verb).\n      verbBeforeUpdate.onComplete(entry);\n    } else {\n      // Normal completion \u2014 no transfer\n      const enemyRef = activeEnemy;\n      activeVerb.onComplete(entry);\n      releaseLaunched(activeEnemy);\n      activeVerb = null;\n      activeEnemy = null;\n      cleanupVerbTags(enemyRef);\n    }\n  } else if (result === 'cancel') {\n    if (transferred) {\n      // Transfer + cancel is unusual but handle it: cancel the old verb, keep new verb\n      verbBeforeUpdate.onCancel(entry);\n    } else {\n      const enemyRef = activeEnemy;\n      activeVerb.onCancel(entry);\n      releaseLaunched(activeEnemy);\n      activeVerb = null;\n      activeEnemy = null;\n      cleanupVerbTags(enemyRef);\n    }\n  }\n}\n\nexport function initAerialVerbs(verbsToRegister?: AerialVerb[]): void {\n  if (verbsToRegister) {\n    for (const verb of verbsToRegister) {\n      registerVerb(verb);\n    }\n  }\n}\n\nexport function resetAerialVerbs(): void {\n  cancelActiveVerb();\n  clearLaunched();\n}\n\nexport function cancelActiveVerb(): void {\n  if (!activeVerb || !activeEnemy) return;\n  const enemyRef = activeEnemy;\n  const entry = launched.find(e => e.enemy === activeEnemy);\n  activeVerb.onCancel(entry ?? { enemy: activeEnemy, launchTime: 0, claimedBy: null, gravityMult: 1 });\n  if (entry) releaseLaunched(activeEnemy);\n  activeVerb = null;\n  activeEnemy = null;\n  cleanupVerbTags(enemyRef);\n}\n", "// Bullet Time \u2014 player-triggered slow-mo\n// Press Q to toggle. Resource bar drains while active, enemy kills refill it.\n// Player moves at normal speed; everything else slows down.\n\nimport { emit, on } from './events';\n\nexport const BULLET_TIME = {\n  timeScale: 0.25,          // how slow the world runs (0.25 = 25% speed)\n  maxResource: 3000,         // ms of bullet time available at full bar\n  drainRate: 1000,           // resource drained per real second while active\n  killRefill: 600,           // resource refilled per enemy kill\n  activationMinimum: 300,    // minimum resource required to activate\n  infinite: 1,               // 1 = infinite resource (skip drain), 0 = normal drain\n  exitRampDuration: 250,     // ms to ramp from BT scale \u2192 1.0 on deactivation\n};\n\nlet resource = BULLET_TIME.maxResource;\nlet active = false;\nlet initialized = false;\nlet _autoEngaged = false;  // true when BT was auto-activated by a verb or detection\nlet _detectingCount = 0;   // number of enemies currently detecting the player\n\n// Exit ramp state \u2014 smooth transition from BT scale \u2192 1.0\nlet _rampActive = false;\nlet _rampTimer = 0;        // ms elapsed since ramp started\nlet _rampFromScale = 0.25; // scale at the moment ramp began\n\nexport function initBulletTime() {\n  if (initialized) return;\n  initialized = true;\n\n  // Kill refill \u2014 subscribe to enemyDied event\n  on('enemyDied', () => {\n    refillBulletTime(BULLET_TIME.killRefill);\n  });\n\n  // Auto-activate bullet time when player enters a vision cone (detection starts)\n  // Gives the player a slow-mo reaction window to escape before aggro.\n  on('detectionStarted', () => {\n    _detectingCount++;\n    activateBulletTimeAuto();\n  });\n\n  // Deactivate when all cones are clear (player escaped all detection)\n  on('detectionCleared', () => {\n    _detectingCount = Math.max(0, _detectingCount - 1);\n    if (_detectingCount === 0) {\n      deactivateBulletTimeAuto();\n    }\n  });\n\n}\n\n/** Activate bullet time (no-op if already active). */\nexport function activateBulletTime() {\n  if (active) return;\n  if (resource >= BULLET_TIME.activationMinimum) {\n    active = true;\n    _rampActive = false; // cancel any exit ramp\n    emit({ type: 'bulletTimeActivated' });\n  }\n}\n\nexport function toggleBulletTime() {\n  if (active) {\n    startExitRamp();\n  } else {\n    activateBulletTime();\n  }\n}\n\n/** Begin the exit ramp instead of snapping to 1.0. */\nfunction startExitRamp() {\n  _rampFromScale = active ? BULLET_TIME.timeScale : getBulletTimeScale();\n  active = false;\n  _autoEngaged = false;\n  _rampActive = true;\n  _rampTimer = 0;\n  emit({ type: 'bulletTimeDeactivated' });\n}\n\nexport function updateBulletTime(realDt: number) {\n  // Advance exit ramp (uses real time so duration is consistent)\n  if (_rampActive) {\n    _rampTimer += realDt * 1000;\n    if (_rampTimer >= BULLET_TIME.exitRampDuration) {\n      _rampActive = false;\n    }\n  }\n\n  if (!active) return;\n\n  // Skip drain when infinite mode is on\n  if (BULLET_TIME.infinite >= 1) return;\n\n  // Drain resource\n  resource -= BULLET_TIME.drainRate * realDt;\n\n  if (resource <= 0) {\n    resource = 0;\n    startExitRamp();\n  }\n}\n\nexport function getBulletTimeScale(): number {\n  if (active) return BULLET_TIME.timeScale;\n  if (_rampActive) {\n    const t = Math.min(_rampTimer / BULLET_TIME.exitRampDuration, 1);\n    // Ease-in quadratic: world \"winds up\" gradually then snaps to full speed\n    const eased = t * t;\n    return _rampFromScale + (1 - _rampFromScale) * eased;\n  }\n  return 1;\n}\n\nexport function refillBulletTime(amount: number) {\n  resource = Math.min(resource + amount, BULLET_TIME.maxResource);\n}\n\nexport function resetBulletTime() {\n  resource = BULLET_TIME.maxResource;\n  active = false;\n  _rampActive = false;\n  _autoEngaged = false;\n  _detectingCount = 0;\n}\n\nexport function isBulletTimeActive(): boolean {\n  return active || _rampActive;\n}\n\nexport function getBulletTimeResource(): number {\n  return resource;\n}\n\nexport function getBulletTimeMax(): number {\n  return BULLET_TIME.maxResource;\n}\n\n/** Auto-engage BT for a verb (e.g. dunk hold). Only activates if not already active. */\nexport function activateBulletTimeAuto() {\n  if (active) return; // already active (manual or prior auto)\n  _autoEngaged = true;\n  activateBulletTime();\n}\n\n/** Disengage auto-BT. No-op if player manually activated BT (preserves their choice). */\nexport function deactivateBulletTimeAuto() {\n  if (!_autoEngaged) return;\n  startExitRamp();\n}\n", "// Float Selector Verb \u2014 shared rising + float phases after launch\n// Resolves to either dunk (hold LMB) or spike (tap LMB) via transferClaim.\n//\n// Phases: rising \u2192 float \u2192 resolved (complete/cancel)\n//\n// Rising: both entities rise under normal gravity. Decal tracks aim.\n//   Transition to float when enemy descends within convergeDist of player Y.\n//   Cancel if enemy dies, falls in pit, or lands.\n//\n// Float: zero gravity \u2014 freeze both entities. Drift enemy toward player.\n//   Track LMB input:\n//   - Tap (press + release < holdThreshold) \u2192 transfer to 'spike'\n//   - Hold (>= holdThreshold) \u2192 transfer to 'dunk'\n//   - No input before float expires \u2192 cancel\n\nimport { DUNK, FLOAT_SELECTOR } from '../config/player';\nimport { setGravityOverride, transferClaim } from '../engine/aerialVerbs';\nimport type { AerialVerb, LaunchedEnemy } from '../engine/aerialVerbs';\nimport { activateBulletTimeAuto, deactivateBulletTimeAuto } from '../engine/bulletTime';\nimport { screenShake, getScene } from '../engine/renderer';\nimport { TAG } from '../engine/tags';\n\n// --------------- Internal State ---------------\n\ntype FloatSelectorPhase = 'none' | 'rising' | 'float';\n\nlet phase: FloatSelectorPhase = 'none';\nlet target: any = null;\nlet floatTimer = 0;           // ms remaining in float phase\n\n// LMB input tracking\nlet lmbPressed = false;        // LMB was pressed during float\nlet lmbHoldTimer = 0;          // ms since LMB pressed\nlet resolved = false;          // transfer already issued\n\n// Velocity override \u2014 player.ts checks this each frame\nlet playerVelYOverride: number | null = null;\n\n// Player position tracking \u2014 used to mirror air control onto launched enemy\nlet prevPlayerX = 0;\nlet prevPlayerZ = 0;\n\n// Landing target position (aim decal)\nlet landingX = 0;\nlet landingZ = 0;\n\n// --------------- Visual State ---------------\n\nlet decalGroup: any = null;\nlet decalFill: any = null;\nlet decalRing: any = null;\nlet decalAge = 0;\nconst DECAL_EXPAND_MS = 250;\n\nlet chargeRing: any = null;\nlet chargeRingMat: any = null;\n\n// --------------- Decal Management ---------------\n\nfunction createDecal(cx: number, cz: number): void {\n  const scene = getScene();\n  const radius = DUNK.targetRadius;\n\n  decalGroup = new THREE.Group();\n  decalGroup.position.set(cx, 0.06, cz);\n\n  // Filled circle \u2014 lower opacity than dunk's to indicate selection phase\n  const fillGeo = new THREE.CircleGeometry(radius, 32);\n  const fillMat = new THREE.MeshBasicMaterial({\n    color: 0xffaa44,\n    transparent: true,\n    opacity: 0.05,\n    depthWrite: false,\n  });\n  decalFill = new THREE.Mesh(fillGeo, fillMat);\n  decalFill.rotation.x = -Math.PI / 2;\n  decalGroup.add(decalFill);\n\n  // Outer ring\n  const ringGeo = new THREE.RingGeometry(radius - 0.06, radius, 48);\n  const ringMat = new THREE.MeshBasicMaterial({\n    color: 0xffaa44,\n    transparent: true,\n    opacity: 0.3,\n    depthWrite: false,\n  });\n  decalRing = new THREE.Mesh(ringGeo, ringMat);\n  decalRing.rotation.x = -Math.PI / 2;\n  decalGroup.add(decalRing);\n\n  // Start at scale 0 \u2014 expand over DECAL_EXPAND_MS\n  decalGroup.scale.set(0, 0, 0);\n  decalAge = 0;\n\n  scene.add(decalGroup);\n}\n\nfunction updateDecal(playerX: number, playerZ: number, dt: number): void {\n  if (!decalGroup) return;\n\n  // Expand animation\n  if (decalAge < DECAL_EXPAND_MS) {\n    decalAge += dt * 1000;\n    const t = Math.min(decalAge / DECAL_EXPAND_MS, 1);\n    const eased = 1 - (1 - t) * (1 - t);\n    decalGroup.scale.set(eased, eased, eased);\n  } else if (decalGroup.scale.x < 1) {\n    decalGroup.scale.set(1, 1, 1);\n  }\n\n  decalGroup.position.set(playerX, 0.06, playerZ);\n\n  // Pulse ring opacity\n  if (decalRing) {\n    const pulse = 0.2 + 0.1 * Math.sin(Date.now() * 0.008);\n    (decalRing.material as any).opacity = pulse;\n  }\n}\n\nfunction removeDecal(): void {\n  if (!decalGroup) return;\n  const scene = getScene();\n  decalGroup.traverse((child: any) => {\n    if (child.geometry) child.geometry.dispose();\n    if (child.material) child.material.dispose();\n  });\n  scene.remove(decalGroup);\n  decalGroup = null;\n  decalFill = null;\n  decalRing = null;\n}\n\n// --------------- Charge Ring Management ---------------\n\nfunction createChargeRing(playerPos: any): void {\n  removeChargeRing();\n  const scene = getScene();\n  const geo = new THREE.RingGeometry(0.5, 0.55, 32);\n  chargeRingMat = new THREE.MeshBasicMaterial({\n    color: 0xff8800,\n    transparent: true,\n    opacity: 0.6,\n    depthWrite: false,\n  });\n  chargeRing = new THREE.Mesh(geo, chargeRingMat);\n  chargeRing.rotation.x = -Math.PI / 2;\n  chargeRing.position.set(playerPos.x, playerPos.y + 0.1, playerPos.z);\n  scene.add(chargeRing);\n}\n\nfunction updateChargeRing(playerPos: any, fillT: number): void {\n  if (!chargeRing || !chargeRingMat) return;\n  chargeRing.position.set(playerPos.x, playerPos.y + 0.1, playerPos.z);\n\n  // Color shift: orange (0xff8800) \u2192 red (0xff2200) as fill progresses\n  const r = 0xff;\n  const g = Math.round(0x88 * (1 - fillT));\n  const b = 0x00;\n  chargeRingMat.color.setHex((r << 16) | (g << 8) | b);\n  chargeRingMat.opacity = 0.4 + 0.4 * fillT;\n}\n\nfunction removeChargeRing(): void {\n  if (!chargeRing) return;\n  const scene = getScene();\n  if (chargeRing.geometry) chargeRing.geometry.dispose();\n  if (chargeRing.material) chargeRing.material.dispose();\n  scene.remove(chargeRing);\n  chargeRing = null;\n  chargeRingMat = null;\n}\n\n// --------------- Targeting ---------------\n\nfunction updateTargeting(playerPos: any, inputState: any): void {\n  const aimDx = inputState.aimWorldPos.x - playerPos.x;\n  const aimDz = inputState.aimWorldPos.z - playerPos.z;\n  const aimDist = Math.sqrt(aimDx * aimDx + aimDz * aimDz) || 0.01;\n  const clampedDist = Math.min(aimDist, DUNK.targetRadius);\n  landingX = playerPos.x + (aimDx / aimDist) * clampedDist;\n  landingZ = playerPos.z + (aimDz / aimDist) * clampedDist;\n}\n\n// --------------- AerialVerb Implementation ---------------\n\nexport const floatSelectorVerb: AerialVerb = {\n  name: 'floatSelector',\n  tag: TAG.AERIAL_FLOAT,\n  interruptible: true,\n\n  canClaim(_entry: LaunchedEnemy, _playerPos: any, _inputState: any): boolean {\n    return true;\n  },\n\n  onClaim(entry: LaunchedEnemy): void {\n    phase = 'rising';\n    target = entry.enemy;\n    floatTimer = 0;\n    lmbPressed = false;\n    lmbHoldTimer = 0;\n    resolved = false;\n    playerVelYOverride = null;\n    prevPlayerX = NaN; // sentinel \u2014 first rising frame will initialize\n\n    if (!decalGroup) {\n      createDecal(0, 0);\n    }\n  },\n\n  update(dt: number, entry: LaunchedEnemy, playerPos: any, inputState: any): 'active' | 'complete' | 'cancel' {\n    const enemy = entry.enemy;\n\n    if (phase === 'rising') {\n      return updateRising(dt, enemy, playerPos, inputState);\n    } else if (phase === 'float') {\n      return updateFloat(dt, enemy, playerPos, inputState);\n    }\n\n    return 'cancel';\n  },\n\n  onCancel(entry: LaunchedEnemy): void {\n    removeDecal();\n    removeChargeRing();\n    deactivateBulletTimeAuto();\n    setGravityOverride(entry.enemy, 1);\n    phase = 'none';\n    target = null;\n    playerVelYOverride = null;\n    lmbPressed = false;\n    lmbHoldTimer = 0;\n    resolved = false;\n  },\n\n  onComplete(entry: LaunchedEnemy): void {\n    // Transfer already happened via transferClaim in float update.\n    // Clean up selector visuals (the receiving verb owns the enemy now).\n    removeDecal();\n    removeChargeRing();\n    phase = 'none';\n    target = null;\n    playerVelYOverride = null;\n    lmbPressed = false;\n    lmbHoldTimer = 0;\n    resolved = false;\n  },\n};\n\n// --------------- Rising Phase Update ---------------\n\nfunction updateRising(dt: number, enemy: any, playerPos: any, inputState: any): 'active' | 'complete' | 'cancel' {\n  const vel = enemy.vel;\n  const isRising = vel && vel.y > 0;\n\n  // Mirror player air control onto enemy \u2014 keeps arc in the player's reference frame.\n  // Without this, arc velocity aims at the player's launch-time position and the\n  // player drifts away via air control, creating a gap at float.\n  if (isNaN(prevPlayerX)) {\n    // First frame after claim \u2014 initialize, no delta to apply\n    prevPlayerX = playerPos.x;\n    prevPlayerZ = playerPos.z;\n  } else {\n    const deltaX = playerPos.x - prevPlayerX;\n    const deltaZ = playerPos.z - prevPlayerZ;\n    enemy.pos.x += deltaX;\n    enemy.pos.z += deltaZ;\n    if (enemy.mesh) {\n      enemy.mesh.position.x = enemy.pos.x;\n      enemy.mesh.position.z = enemy.pos.z;\n    }\n    prevPlayerX = playerPos.x;\n    prevPlayerZ = playerPos.z;\n  }\n\n  // Update targeting decal while rising\n  updateTargeting(playerPos, inputState);\n  updateDecal(playerPos.x, playerPos.z, dt);\n\n  // Cancel conditions\n  if (enemy.health <= 0 || enemy.fellInPit || (enemy.pos.y <= 0.3 && !isRising)) {\n    return 'cancel';\n  }\n\n  // Convergence check: enemy must be descending (vel.y <= 0) and within Y distance of player\n  if (vel && vel.y <= 0) {\n    const dy = enemy.pos.y - playerPos.y;\n    if (dy >= 0 && dy <= DUNK.floatConvergeDist) {\n      // Converged! Transition to float\n      phase = 'float';\n      floatTimer = DUNK.floatDuration;\n      playerVelYOverride = 0;\n      setGravityOverride(enemy, 0);\n\n      screenShake(DUNK.grabShake * 0.5);\n      return 'active';\n    }\n  }\n\n  return 'active';\n}\n\n// --------------- Float Phase Update ---------------\n\nfunction updateFloat(dt: number, enemy: any, playerPos: any, inputState: any): 'active' | 'complete' | 'cancel' {\n  floatTimer -= dt * 1000;\n  const vel = enemy.vel;\n\n  // Kill gravity on both \u2014 hold in place\n  playerVelYOverride = 0;\n  if (vel) vel.y = 0;\n\n  // Drift enemy Y toward hover position above player (linear lerp)\n  const targetEnemyY = playerPos.y + DUNK.floatEnemyOffsetY;\n  enemy.pos.y += (targetEnemyY - enemy.pos.y) * Math.min(1, dt * 10);\n\n  // Drift enemy XZ toward player (exponential lerp \u2014 drift fix)\n  const driftDx = playerPos.x - enemy.pos.x;\n  const driftDz = playerPos.z - enemy.pos.z;\n  const lerpFactor = 1 - Math.exp(-FLOAT_SELECTOR.floatDriftRate * dt);\n  enemy.pos.x += driftDx * lerpFactor;\n  enemy.pos.z += driftDz * lerpFactor;\n\n  // Sync enemy mesh\n  if (enemy.mesh) enemy.mesh.position.copy(enemy.pos);\n\n  // Update targeting decal\n  updateTargeting(playerPos, inputState);\n  updateDecal(playerPos.x, playerPos.z, dt);\n\n  // --- LMB Input Tracking ---\n  // Check both edge trigger (attack) and continuous flag (attackHeld).\n  // If the player held LMB before float started, the edge was consumed during\n  // rising \u2014 attackHeld detects the pre-held state so the hold still registers.\n  if (!lmbPressed && (inputState.attack || inputState.attackHeld)) {\n    lmbPressed = true;\n    lmbHoldTimer = 0;\n    createChargeRing(playerPos);\n  }\n\n  if (lmbPressed) {\n    if (inputState.attackHeld) {\n      // Still holding LMB \u2014 increment hold timer\n      lmbHoldTimer += dt * 1000;\n      const fillT = Math.min(lmbHoldTimer / FLOAT_SELECTOR.holdThreshold, 1);\n      updateChargeRing(playerPos, fillT);\n\n      if (lmbHoldTimer >= FLOAT_SELECTOR.holdThreshold) {\n        // Hold past threshold \u2192 confirmed dunk, engage BT for aim time\n        activateBulletTimeAuto();\n        transferClaim(enemy, 'dunk');\n        resolved = true;\n        return 'complete';\n      }\n    } else {\n      // LMB was released before threshold \u2192 tap \u2192 transfer to spike\n      transferClaim(enemy, 'spike');\n      resolved = true;\n      return 'complete';\n    }\n  }\n\n  // Float expired with no input \u2192 cancel\n  if (floatTimer <= 0) {\n    return 'cancel';\n  }\n\n  return 'active';\n}\n\n// --------------- Public State Queries ---------------\n\nexport function getFloatSelectorPhase(): FloatSelectorPhase {\n  return phase;\n}\n\nexport function getFloatSelectorLandingPos(): { x: number; z: number } | null {\n  if (phase === 'none') return null;\n  return { x: landingX, z: landingZ };\n}\n\nexport function isFloatSelectorActive(): boolean {\n  return phase !== 'none';\n}\n\nexport function getFloatSelectorPlayerVelY(): number | null {\n  return playerVelYOverride;\n}\n\n// --------------- Decal Handoff ---------------\n\n/** Transfer decal ownership to another verb (e.g. dunk). Returns the Three.js\n *  objects and nulls local refs so onComplete won't dispose them. */\nexport function handoffDecal(): { group: any; fill: any; ring: any } | null {\n  if (!decalGroup) return null;\n  const result = { group: decalGroup, fill: decalFill, ring: decalRing };\n  decalGroup = null;\n  decalFill = null;\n  decalRing = null;\n  return result;\n}\n\n// --------------- Reset ---------------\n\nexport function resetFloatSelector(): void {\n  phase = 'none';\n  target = null;\n  floatTimer = 0;\n  lmbPressed = false;\n  lmbHoldTimer = 0;\n  resolved = false;\n  playerVelYOverride = null;\n  landingX = 0;\n  landingZ = 0;\n  removeDecal();\n  removeChargeRing();\n}\n", "// Dunk Verb Module \u2014 extracted from player.ts\n// State machine: grab -> slam\n//\n// The float selector verb owns rising + float phases (convergence, aiming).\n// When the selector resolves to dunk (hold LMB past threshold), it transfers\n// claim to dunk via onClaim. At that point player and enemy are already\n// floating together.\n//\n// Grab: snap enemy to player, begin slam descent\n// Slam: arc trajectory toward landing target, enemy carried below player\n\nimport { DUNK, JUMP } from '../config/player';\nimport { getGroundHeight } from '../config/terrain';\nimport { setGravityOverride } from '../engine/aerialVerbs';\nimport type { AerialVerb, LaunchedEnemy } from '../engine/aerialVerbs';\nimport { deactivateBulletTimeAuto } from '../engine/bulletTime';\nimport { screenShake, getScene } from '../engine/renderer';\nimport { emit } from '../engine/events';\nimport { spawnDamageNumber } from '../ui/damageNumbers';\nimport { TAG } from '../engine/tags';\nimport { handoffDecal } from './floatSelector';\n\n// --------------- Internal State ---------------\n\ntype DunkPhase = 'none' | 'grab' | 'wind' | 'slam';\n\nlet phase: DunkPhase = 'none';\nlet target: any = null;        // enemy being dunked\nlet floatTimer = 0;            // ms remaining in float phase\n\n// Landing target position (where the slam will land)\nlet landingX = 0;\nlet landingZ = 0;\n\n// Decal origin (tracks player position \u2014 decal is centered on player)\nlet originX = 0;\nlet originZ = 0;\n\n// Slam arc state\nlet slamStartY = 0;\nlet slamStartX = 0;\nlet slamStartZ = 0;\n\n// Velocity override \u2014 when non-null, player.ts should use this for playerVelY\nlet playerVelYOverride: number | null = null;\n\n// Landing lag override \u2014 when > 0, player.ts should apply this many ms of landing lag\nlet landingLagMs = 0;\n\n// Game state reference \u2014 set during update, used by onComplete for AoE\nlet _gameState: any = null;\n\n// --------------- Visual State (decal + trail) ---------------\n\nlet decalGroup: any = null;\nlet decalFill: any = null;\nlet decalRing: any = null;\nlet decalAge = 0;\nconst DECAL_EXPAND_MS = 250;\n\n// Decal handoff \u2014 stolen from floatSelector during onClaim, consumed in transitionToGrab\nlet _handedDecal: { group: any; fill: any; ring: any } | null = null;\n\nconst TRAIL_MAX = 20;\nlet trailLine: any = null;\nlet trailPoints: { x: number; y: number; z: number }[] = [];\nlet trailLife = 0; // ms remaining for trail fade after landing\n\n// --------------- Decal Management ---------------\n\nfunction createDecal(cx: number, cz: number): void {\n  const scene = getScene();\n  const radius = DUNK.targetRadius;\n\n  decalGroup = new THREE.Group();\n  decalGroup.position.set(cx, 0.06, cz);\n\n  // Filled circle -- semi-transparent magenta\n  const fillGeo = new THREE.CircleGeometry(radius, 32);\n  const fillMat = new THREE.MeshBasicMaterial({\n    color: 0xff44ff,\n    transparent: true,\n    opacity: 0.08,\n    depthWrite: false,\n  });\n  decalFill = new THREE.Mesh(fillGeo, fillMat);\n  decalFill.rotation.x = -Math.PI / 2;\n  decalGroup.add(decalFill);\n\n  // Outer ring -- brighter border\n  const ringGeo = new THREE.RingGeometry(radius - 0.06, radius, 48);\n  const ringMat = new THREE.MeshBasicMaterial({\n    color: 0xff66ff,\n    transparent: true,\n    opacity: 0.4,\n    depthWrite: false,\n  });\n  decalRing = new THREE.Mesh(ringGeo, ringMat);\n  decalRing.rotation.x = -Math.PI / 2;\n  decalGroup.add(decalRing);\n\n  // Crosshair -- sized to match AoE splash radius\n  const dotGeo = new THREE.CircleGeometry(DUNK.aoeRadius, 24);\n  const dotMat = new THREE.MeshBasicMaterial({\n    color: 0xff88ff,\n    transparent: true,\n    opacity: 0.15,\n    depthWrite: false,\n  });\n  const dot = new THREE.Mesh(dotGeo, dotMat);\n  dot.rotation.x = -Math.PI / 2;\n  dot.name = 'dunkCrosshair';\n  decalGroup.add(dot);\n\n  // Start at scale 0 -- expand over DECAL_EXPAND_MS\n  decalGroup.scale.set(0, 0, 0);\n  decalAge = 0;\n\n  scene.add(decalGroup);\n}\n\nfunction updateDecal(aimX: number, aimZ: number, dt: number): void {\n  if (!decalGroup) return;\n\n  // Expand animation -- ease-out from 0 to 1\n  if (decalAge < DECAL_EXPAND_MS) {\n    decalAge += dt * 1000;\n    const t = Math.min(decalAge / DECAL_EXPAND_MS, 1);\n    const eased = 1 - (1 - t) * (1 - t); // ease-out quadratic\n    decalGroup.scale.set(eased, eased, eased);\n  } else if (decalGroup.scale.x < 1) {\n    decalGroup.scale.set(1, 1, 1);\n  }\n\n  // Decal stays centered on player position (originX/Z updated each frame)\n  decalGroup.position.set(originX, 0.06, originZ);\n\n  // Move crosshair dot to show landing target (relative to decal center)\n  const dot = decalGroup.getObjectByName('dunkCrosshair');\n  if (dot) {\n    const dx = landingX - originX;\n    const dz = landingZ - originZ;\n    dot.position.set(dx, 0, dz);\n  }\n\n  // Pulse ring opacity for urgency\n  if (decalRing) {\n    const pulse = 0.3 + 0.15 * Math.sin(Date.now() * 0.008);\n    (decalRing.material as any).opacity = pulse;\n  }\n}\n\nfunction removeDecal(): void {\n  if (!decalGroup) return;\n  const scene = getScene();\n\n  decalGroup.traverse((child: any) => {\n    if (child.geometry) child.geometry.dispose();\n    if (child.material) child.material.dispose();\n  });\n\n  scene.remove(decalGroup);\n  decalGroup = null;\n  decalFill = null;\n  decalRing = null;\n}\n\n// --------------- Trail Management ---------------\n\nfunction createTrail(): void {\n  removeTrail();\n  const geo = new THREE.BufferGeometry();\n  const positions = new Float32Array(TRAIL_MAX * 3);\n  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n  geo.setDrawRange(0, 0);\n\n  const mat = new THREE.LineBasicMaterial({\n    color: 0xff66ff,\n    transparent: true,\n    opacity: 0.7,\n    linewidth: 1,\n  });\n  trailLine = new THREE.Line(geo, mat);\n  trailLine.frustumCulled = false;\n  getScene().add(trailLine);\n  trailLife = 0;\n}\n\nfunction updateTrailGeometry(): void {\n  if (!trailLine) return;\n  const posAttr = trailLine.geometry.getAttribute('position');\n  const arr = posAttr.array;\n  for (let i = 0; i < trailPoints.length; i++) {\n    const p = trailPoints[i];\n    arr[i * 3] = p.x;\n    arr[i * 3 + 1] = p.y;\n    arr[i * 3 + 2] = p.z;\n  }\n  posAttr.needsUpdate = true;\n  trailLine.geometry.setDrawRange(0, trailPoints.length);\n}\n\nfunction startTrailFade(): void {\n  trailLife = 300; // ms to fade out after landing\n}\n\nfunction removeTrail(): void {\n  if (!trailLine) return;\n  const scene = getScene();\n  scene.remove(trailLine);\n  if (trailLine.geometry) trailLine.geometry.dispose();\n  if (trailLine.material) trailLine.material.dispose();\n  trailLine = null;\n  trailPoints = [];\n  trailLife = 0;\n}\n\n// --------------- Targeting (used during slam) ---------------\n\nfunction updateTargeting(playerPos: any, inputState: any): void {\n  // Keep the aim origin anchored to the player\n  originX = playerPos.x;\n  originZ = playerPos.z;\n\n  // Update landing target from current aim, clamped to radius\n  const aimDx = inputState.aimWorldPos.x - originX;\n  const aimDz = inputState.aimWorldPos.z - originZ;\n  const aimDist = Math.sqrt(aimDx * aimDx + aimDz * aimDz) || 0.01;\n  const clampedDist = Math.min(aimDist, DUNK.targetRadius);\n  landingX = originX + (aimDx / aimDist) * clampedDist;\n  landingZ = originZ + (aimDz / aimDist) * clampedDist;\n}\n\n// --------------- AerialVerb Implementation ---------------\n\nexport const dunkVerb: AerialVerb = {\n  name: 'dunk',\n  tag: TAG.AERIAL_DUNK,\n  interruptible: false,\n\n  canClaim(entry: LaunchedEnemy, playerPos: any, _inputState: any): boolean {\n    // Dunk auto-claims on launch \u2014 the launch code in player.ts sets up\n    // the pending target. For the framework, we always allow claim since\n    // the launch verb already validated proximity.\n    return true;\n  },\n\n  onClaim(entry: LaunchedEnemy): void {\n    // Selector already handled rising + float + convergence.\n    // Player and enemy are floating together \u2014 go straight to grab.\n    phase = 'grab';\n    target = entry.enemy;\n    floatTimer = 0;\n    playerVelYOverride = null;\n    landingLagMs = 0;\n\n    // Steal decal from floatSelector BEFORE its onComplete disposes it.\n    // This lets transitionToGrab adopt + recolor instead of creating from scratch.\n    _handedDecal = handoffDecal();\n  },\n\n  update(dt: number, entry: LaunchedEnemy, playerPos: any, inputState: any): 'active' | 'complete' | 'cancel' {\n    const enemy = entry.enemy;\n    _gameState = inputState._gameState; // sneak gameState through inputState for AoE\n\n    if (phase === 'grab') {\n      // Initialize the landing target from current aim position\n      originX = playerPos.x;\n      originZ = playerPos.z;\n      const aimDx = inputState.aimWorldPos.x - originX;\n      const aimDz = inputState.aimWorldPos.z - originZ;\n      const aimDist = Math.sqrt(aimDx * aimDx + aimDz * aimDz) || 0.01;\n      const clampedDist = Math.min(aimDist, DUNK.targetRadius);\n      landingX = originX + (aimDx / aimDist) * clampedDist;\n      landingZ = originZ + (aimDz / aimDist) * clampedDist;\n\n      transitionToGrab(enemy, playerPos);\n      // transitionToGrab sets phase to 'wind' (arc rise before slam)\n      return 'active';\n    }\n\n    if (phase === 'wind') {\n      return updateWind(dt, enemy, playerPos, inputState);\n    }\n\n    if (phase === 'slam') {\n      return updateSlam(dt, enemy, playerPos, inputState);\n    }\n\n    return 'cancel';\n  },\n\n  onCancel(entry: LaunchedEnemy): void {\n    // Clean up everything \u2014 enemy died, float expired, etc.\n    removeDecal();\n    removeTrail();\n    deactivateBulletTimeAuto();\n    // Reset gravity to normal for the enemy\n    setGravityOverride(entry.enemy, 1);\n    phase = 'none';\n    target = null;\n    playerVelYOverride = null;\n    landingLagMs = 0;\n  },\n\n  onComplete(entry: LaunchedEnemy): void {\n    const enemy = entry.enemy;\n    const groundHeight = getGroundHeight(enemy.pos.x, enemy.pos.z);\n\n    // Primary damage to dunk target\n    enemy.health -= DUNK.damage;\n    enemy.flashTimer = 150;\n    enemy.pos.y = groundHeight;\n    const tVel = (enemy as any).vel;\n    if (tVel) { tVel.x = 0; tVel.y = 0; tVel.z = 0; }\n    if (enemy.mesh) enemy.mesh.position.copy(enemy.pos);\n\n    // AoE splash damage to other nearby enemies\n    if (_gameState && _gameState.enemies) {\n      const enemies = _gameState.enemies;\n      for (let i = 0; i < enemies.length; i++) {\n        const e = enemies[i];\n        if (e === enemy) continue;\n        if (e.health <= 0 || (e as any).fellInPit) continue;\n        const dx = e.pos.x - enemy.pos.x;\n        const dz = e.pos.z - enemy.pos.z;\n        const distSq = dx * dx + dz * dz;\n        if (distSq < DUNK.aoeRadius * DUNK.aoeRadius) {\n          e.health -= DUNK.aoeDamage;\n          e.flashTimer = 100;\n          const dist = Math.sqrt(distSq) || 0.1;\n          const vel = (e as any).vel;\n          if (vel) {\n            vel.x += (dx / dist) * DUNK.aoeKnockback;\n            vel.z += (dz / dist) * DUNK.aoeKnockback;\n          }\n        }\n      }\n    }\n\n    // Screen shake (massive)\n    screenShake(DUNK.landingShake);\n\n    // Emit dunk impact event\n    emit({\n      type: 'dunkImpact',\n      enemy,\n      damage: DUNK.damage,\n      position: { x: enemy.pos.x, z: enemy.pos.z },\n    });\n    spawnDamageNumber(enemy.pos.x, enemy.pos.z, `DUNK! ${DUNK.damage}`, '#ff2244');\n\n    // Visual cleanup\n    removeDecal();\n    startTrailFade();\n    deactivateBulletTimeAuto();\n\n    // Set landing lag (player.ts reads this)\n    landingLagMs = DUNK.landingLag;\n\n    // Reset verb state\n    phase = 'none';\n    target = null;\n    playerVelYOverride = null;\n  },\n};\n\n// --------------- Grab Transition ---------------\n\nfunction transitionToGrab(enemy: any, playerPos: any): void {\n  phase = 'wind'; // rise arc before slam descent\n  target = enemy;\n  const ptVel = (enemy as any).vel;\n\n  // Snap enemy to player position\n  enemy.pos.x = playerPos.x;\n  enemy.pos.z = playerPos.z;\n  enemy.pos.y = playerPos.y + DUNK.carryOffsetY;\n\n  // Start with upward velocity \u2014 arc rises before slamming down\n  playerVelYOverride = DUNK.arcRiseVelocity;\n  if (ptVel) ptVel.y = DUNK.arcRiseVelocity;\n\n  // Adopt floatSelector's decal (seamless transition) or create fresh\n  if (_handedDecal) {\n    decalGroup = _handedDecal.group;\n    decalFill = _handedDecal.fill;\n    decalRing = _handedDecal.ring;\n    _handedDecal = null;\n\n    // Recolor from orange \u2192 magenta\n    if (decalFill) {\n      (decalFill.material as any).color.setHex(0xff44ff);\n      (decalFill.material as any).opacity = 0.08;\n    }\n    if (decalRing) (decalRing.material as any).color.setHex(0xff66ff);\n\n    // Add crosshair dot (floatSelector doesn't have one)\n    const dotGeo = new THREE.CircleGeometry(DUNK.aoeRadius, 24);\n    const dotMat = new THREE.MeshBasicMaterial({\n      color: 0xff88ff, transparent: true, opacity: 0.15, depthWrite: false,\n    });\n    const dot = new THREE.Mesh(dotGeo, dotMat);\n    dot.rotation.x = -Math.PI / 2;\n    dot.name = 'dunkCrosshair';\n    decalGroup.add(dot);\n\n    // Already expanded \u2014 skip scale animation\n    decalAge = DECAL_EXPAND_MS;\n  } else {\n    createDecal(originX, originZ);\n  }\n\n  // Record slam start for arc progress\n  slamStartY = playerPos.y;\n  slamStartX = playerPos.x;\n  slamStartZ = playerPos.z;\n  trailPoints = [{ x: playerPos.x, y: playerPos.y, z: playerPos.z }];\n  createTrail();\n\n  // Grab impact -- shake + event\n  screenShake(DUNK.grabShake);\n  emit({\n    type: 'dunkGrab',\n    enemy,\n    position: { x: playerPos.x, z: playerPos.z },\n  });\n  spawnDamageNumber(playerPos.x, playerPos.z, 'GRAB!', '#ff44ff');\n}\n\n// --------------- Wind Phase Update (upward arc before slam) ---------------\n\nfunction updateWind(dt: number, enemy: any, playerPos: any, inputState: any): 'active' | 'complete' | 'cancel' {\n  // End auto bullet time when player releases the aim button\n  if (!inputState.attackHeld) deactivateBulletTimeAuto();\n\n  // Update targeting (decal follows during wind too)\n  updateTargeting(playerPos, inputState);\n  updateDecal(landingX, landingZ, dt);\n\n  // Apply gravity to decelerate the upward velocity\n  playerVelYOverride! -= JUMP.gravity * dt;\n  const ptVel = (enemy as any).vel;\n  if (ptVel) ptVel.y = playerVelYOverride!;\n\n  // Gentle XZ movement toward landing target during rise\n  const toDx = landingX - playerPos.x;\n  const toDz = landingZ - playerPos.z;\n  const toDist = Math.sqrt(toDx * toDx + toDz * toDz);\n  if (toDist > 0.05) {\n    // Cover arcXzFraction of the total distance during the wind phase\n    // Rise time \u2248 arcRiseVelocity / gravity, so speed = fraction * dist / riseTime\n    const riseTime = DUNK.arcRiseVelocity / JUMP.gravity;\n    const windSpeed = (toDist * DUNK.arcXzFraction) / riseTime;\n    const moveStep = Math.min(windSpeed * dt, toDist);\n    playerPos.x += (toDx / toDist) * moveStep;\n    playerPos.z += (toDz / toDist) * moveStep;\n  }\n\n  // Carry enemy with offset\n  enemy.pos.x = playerPos.x;\n  enemy.pos.z = playerPos.z;\n  enemy.pos.y = playerPos.y + DUNK.carryOffsetY;\n  if (enemy.mesh) {\n    const faceDx = landingX - playerPos.x;\n    const faceDz = landingZ - playerPos.z;\n    const faceDist = Math.sqrt(faceDx * faceDx + faceDz * faceDz) || 0.01;\n    const fwdX = (faceDx / faceDist) * DUNK.carryOffsetZ;\n    const fwdZ = (faceDz / faceDist) * DUNK.carryOffsetZ;\n    enemy.mesh.position.set(enemy.pos.x + fwdX, enemy.pos.y, enemy.pos.z + fwdZ);\n  }\n\n  // Add trail point\n  trailPoints.push({ x: playerPos.x, y: playerPos.y, z: playerPos.z });\n  if (trailPoints.length > TRAIL_MAX) trailPoints.shift();\n  updateTrailGeometry();\n\n  // Transition to slam at apex (velocity crosses zero)\n  if (playerVelYOverride! <= 0) {\n    playerVelYOverride = DUNK.slamVelocity;\n    if (ptVel) ptVel.y = DUNK.slamVelocity;\n    // Update slam start to current (higher) position \u2014 makes slam more dramatic\n    slamStartY = playerPos.y;\n    slamStartX = playerPos.x;\n    slamStartZ = playerPos.z;\n    phase = 'slam';\n  }\n\n  return 'active';\n}\n\n// --------------- Slam Phase Update ---------------\n\nfunction updateSlam(dt: number, enemy: any, playerPos: any, inputState: any): 'active' | 'complete' | 'cancel' {\n  // Landing target is LOCKED at slam start \u2014 no more re-aiming mid-flight.\n  // Just update decal visuals (origin follows player so crosshair converges).\n  originX = playerPos.x;\n  originZ = playerPos.z;\n  updateDecal(landingX, landingZ, dt);\n\n  // Arc trajectory -- ease-in XZ so the slam curves instead of going straight\n  // Progress: 0 = slam start height, 1 = ground level\n  const groundY = getGroundHeight(playerPos.x, playerPos.z);\n  const totalDrop = Math.max(slamStartY - groundY, 0.1);\n  const dropped = Math.max(slamStartY - playerPos.y, 0);\n  const progress = Math.min(dropped / totalDrop, 1);\n  // Ease-in: XZ speed starts slow, accelerates -- creates a curved arc\n  const arcMult = 0.3 + 0.7 * progress;\n\n  // Home player XZ toward landing target with arc-scaled speed\n  const toDx = landingX - playerPos.x;\n  const toDz = landingZ - playerPos.z;\n  const toDist = Math.sqrt(toDx * toDx + toDz * toDz);\n  if (toDist > 0.05) {\n    const moveStep = Math.min(DUNK.homing * arcMult * dt, toDist);\n    playerPos.x += (toDx / toDist) * moveStep;\n    playerPos.z += (toDz / toDist) * moveStep;\n  }\n\n  // Add trail point\n  trailPoints.push({ x: playerPos.x, y: playerPos.y, z: playerPos.z });\n  if (trailPoints.length > TRAIL_MAX) trailPoints.shift();\n  updateTrailGeometry();\n\n  // Carry enemy with offset -- slightly below and in front of player\n  enemy.pos.x = playerPos.x;\n  enemy.pos.z = playerPos.z;\n  enemy.pos.y = playerPos.y + DUNK.carryOffsetY;\n  if (enemy.mesh) {\n    // Visual offset: push enemy mesh forward (toward landing target)\n    const faceDx = landingX - playerPos.x;\n    const faceDz = landingZ - playerPos.z;\n    const faceDist = Math.sqrt(faceDx * faceDx + faceDz * faceDz) || 0.01;\n    const fwdX = (faceDx / faceDist) * DUNK.carryOffsetZ;\n    const fwdZ = (faceDz / faceDist) * DUNK.carryOffsetZ;\n    enemy.mesh.position.set(\n      enemy.pos.x + fwdX,\n      enemy.pos.y,\n      enemy.pos.z + fwdZ\n    );\n  }\n\n  // Check if player reached ground (slam landed)\n  const groundHeight = getGroundHeight(playerPos.x, playerPos.z);\n  if (playerPos.y <= groundHeight) {\n    playerPos.y = groundHeight;\n    return 'complete';\n  }\n\n  return 'active';\n}\n\n// --------------- Public State Queries ---------------\n\nexport function getDunkPhase(): DunkPhase {\n  return phase;\n}\n\nexport function getDunkTarget(): any | null {\n  return target;\n}\n\nexport function isDunkActive(): boolean {\n  return phase !== 'none';\n}\n\nexport function getDunkLandingPos(): { x: number; z: number } | null {\n  if (phase === 'none') return null;\n  return { x: landingX, z: landingZ };\n}\n\n// Player velocity override -- player.ts checks this each frame\n// null = no override (use normal gravity), number = use this velY\nexport function getDunkPlayerVelY(): number | null {\n  return playerVelYOverride;\n}\n\n// Landing lag to apply after dunk completes -- player.ts reads + resets\nexport function getDunkLandingLag(): number {\n  const lag = landingLagMs;\n  landingLagMs = 0; // consumed once\n  return lag;\n}\n\n// --------------- Visual Updates (called from player.ts update loop) ---------------\n\nexport function updateDunkVisuals(dt: number): void {\n  // Trail fade after landing\n  if (trailLine && trailLife > 0) {\n    trailLife -= dt * 1000;\n    const opacity = Math.max(0, trailLife / 300) * 0.7;\n    (trailLine.material as any).opacity = opacity;\n    if (trailLife <= 0) {\n      removeTrail();\n    }\n  }\n}\n\n// --------------- Decal + Landing Setup (called from launch code) ---------------\n\n// Called by player.ts launch code to initialize the landing target before\n// the verb is formally activated (decal appears immediately on launch)\nexport function initDunkTarget(enemyX: number, enemyZ: number, aimX: number, aimZ: number): void {\n  originX = enemyX;\n  originZ = enemyZ;\n  landingX = aimX;\n  landingZ = aimZ;\n\n  // Clamp initial target to radius\n  const dx = landingX - originX;\n  const dz = landingZ - originZ;\n  const dist = Math.sqrt(dx * dx + dz * dz) || 0.01;\n  if (dist > DUNK.targetRadius) {\n    landingX = originX + (dx / dist) * DUNK.targetRadius;\n    landingZ = originZ + (dz / dist) * DUNK.targetRadius;\n  }\n\n  createDecal(originX, originZ);\n}\n\n// --------------- Reset ---------------\n\nexport function resetDunk(): void {\n  phase = 'none';\n  target = null;\n  floatTimer = 0;\n  playerVelYOverride = null;\n  landingLagMs = 0;\n  landingX = 0;\n  landingZ = 0;\n  originX = 0;\n  originZ = 0;\n  slamStartY = 0;\n  slamStartX = 0;\n  slamStartZ = 0;\n  _gameState = null;\n  removeDecal();\n  removeTrail();\n}\n", "// Entity Carrier \u2014 general-purpose physics projectile that carries an entity payload.\n// Created by verbs (spike creates one with angled-downward velocity).\n// Handles flight, through-hits, and ground impact independently.\n\nimport { getGroundHeight } from '../config/terrain';\nimport { screenShake } from './renderer';\nimport { emit } from './events';\nimport { spawnDamageNumber } from '../ui/damageNumbers';\n\n// --------------- Types ---------------\n\nexport interface CarrierConfig {\n  speed: number;\n  gravityMult: number;\n  throughDamage: number;\n  throughKnockback: number;\n  impactDamage: number;\n  impactRadius: number;\n  impactKnockback: number;\n  impactShake: number;\n}\n\ninterface Carrier {\n  payload: any;\n  vel: { x: number; y: number; z: number };\n  config: CarrierConfig;\n  hitSet: Set<any>;\n}\n\n// --------------- Constants ---------------\n\nconst GRAVITY = 25; // matches JUMP.gravity\nconst THROUGH_HIT_RADIUS = 1.5; // generous hit radius for through-hits\n\n// --------------- Internal State ---------------\n\nconst carriers: Carrier[] = [];\n\n// --------------- Public API ---------------\n\n/**\n * Create a carrier with the given payload, direction, and config.\n * Direction is normalized and scaled by config.speed.\n * The payload's hitSet starts with itself (immune to own carrier).\n */\nexport function createCarrier(\n  payload: any,\n  direction: { x: number; y: number; z: number },\n  config: CarrierConfig,\n): void {\n  // Normalize direction\n  const len = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z) || 1;\n  const nx = direction.x / len;\n  const ny = direction.y / len;\n  const nz = direction.z / len;\n\n  const hitSet = new Set<any>();\n  hitSet.add(payload);\n\n  // Mark payload as carried \u2014 enemy AI and physics should skip this entity\n  payload.isCarrierPayload = true;\n\n  carriers.push({\n    payload,\n    vel: {\n      x: nx * config.speed,\n      y: ny * config.speed,\n      z: nz * config.speed,\n    },\n    config,\n    hitSet,\n  });\n}\n\n/**\n * Update all active carriers. Called each frame from game loop.\n * Iterates in reverse for safe removal.\n */\nexport function updateCarriers(dt: number, gameState: any): void {\n  for (let i = carriers.length - 1; i >= 0; i--) {\n    const carrier = carriers[i];\n    const { payload, vel, config, hitSet } = carrier;\n\n    // 1. Apply gravity\n    vel.y -= GRAVITY * config.gravityMult * dt;\n\n    // 2. Move payload\n    payload.pos.x += vel.x * dt;\n    payload.pos.y += vel.y * dt;\n    payload.pos.z += vel.z * dt;\n\n    // 3. Sync mesh\n    if (payload.mesh && payload.mesh.position) {\n      payload.mesh.position.set(payload.pos.x, payload.pos.y, payload.pos.z);\n    }\n\n    // 4. Through-hit check\n    if (gameState.enemies) {\n      for (let j = 0; j < gameState.enemies.length; j++) {\n        const enemy = gameState.enemies[j];\n\n        // Skip if already hit, dead, or in pit\n        if (hitSet.has(enemy)) continue;\n        if (enemy.health <= 0) continue;\n        if (enemy.fellInPit) continue;\n\n        // 3D distance check\n        const dx = enemy.pos.x - payload.pos.x;\n        const dy = enemy.pos.y - payload.pos.y;\n        const dz = enemy.pos.z - payload.pos.z;\n        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n        if (dist < THROUGH_HIT_RADIUS) {\n          // Deal through damage\n          enemy.health -= config.throughDamage;\n          enemy.flashTimer = 100;\n\n          // Apply XZ knockback\n          const xzDist = Math.sqrt(dx * dx + dz * dz) || 0.1;\n          enemy.vel.x += (dx / xzDist) * config.throughKnockback;\n          enemy.vel.z += (dz / xzDist) * config.throughKnockback;\n\n          // Add to hitSet (no double-hits)\n          hitSet.add(enemy);\n\n          // Emit event\n          emit({\n            type: 'spikeThrough',\n            enemy,\n            damage: config.throughDamage,\n            position: { x: enemy.pos.x, z: enemy.pos.z },\n          });\n\n          // Damage number\n          spawnDamageNumber(enemy.pos.x, enemy.pos.z, config.throughDamage, '#ff8844');\n        }\n      }\n    }\n\n    // 5. Ground check\n    const groundY = getGroundHeight(payload.pos.x, payload.pos.z);\n    if (payload.pos.y <= groundY) {\n      // Clamp to ground\n      payload.pos.y = groundY;\n\n      // AoE impact damage to nearby enemies (excluding payload)\n      if (gameState.enemies) {\n        for (let j = 0; j < gameState.enemies.length; j++) {\n          const enemy = gameState.enemies[j];\n          if (enemy === payload) continue;\n          if (enemy.health <= 0) continue;\n          if (enemy.fellInPit) continue;\n\n          const dx = enemy.pos.x - payload.pos.x;\n          const dz = enemy.pos.z - payload.pos.z;\n          const distSq = dx * dx + dz * dz;\n\n          if (distSq < config.impactRadius * config.impactRadius) {\n            enemy.health -= config.impactDamage;\n            enemy.flashTimer = 100;\n\n            const dist = Math.sqrt(distSq) || 0.1;\n            enemy.vel.x += (dx / dist) * config.impactKnockback;\n            enemy.vel.z += (dz / dist) * config.impactKnockback;\n          }\n        }\n      }\n\n      // Stop payload velocity and release from carrier\n      payload.vel.x = 0;\n      payload.vel.y = 0;\n      payload.vel.z = 0;\n      payload.isCarrierPayload = false;\n\n      // Sync mesh to final position\n      if (payload.mesh && payload.mesh.position) {\n        payload.mesh.position.set(payload.pos.x, payload.pos.y, payload.pos.z);\n      }\n\n      // Screen shake\n      screenShake(config.impactShake);\n\n      // Emit impact event\n      emit({\n        type: 'spikeImpact',\n        position: { x: payload.pos.x, z: payload.pos.z },\n        damage: config.impactDamage,\n        radius: config.impactRadius,\n      });\n\n      // Damage number\n      spawnDamageNumber(payload.pos.x, payload.pos.z, 'IMPACT!', '#ff4444');\n\n      // Remove carrier\n      carriers.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Get all active carriers (for inspection/debugging).\n */\nexport function getActiveCarriers(): readonly Carrier[] {\n  return carriers;\n}\n\n/**\n * Clear all carriers (for game reset).\n */\nexport function clearCarriers(): void {\n  for (const c of carriers) {\n    c.payload.isCarrierPayload = false;\n  }\n  carriers.length = 0;\n}\n", "// Spike Verb Module \u2014 volleyball spike, enemy becomes a projectile\n// State machine: windup -> strike -> recovery\n//\n// Windup: hold both player and enemy in place, telegraph the strike\n// Strike: instantaneous \u2014 deal damage, create carrier with angled-downward direction\n// Recovery: player hangs briefly, then fast-falls\n//\n// The carrier system handles the enemy's flight, through-hits, and ground impact.\n\nimport { SPIKE } from '../config/player';\nimport { setGravityOverride } from '../engine/aerialVerbs';\nimport type { AerialVerb, LaunchedEnemy } from '../engine/aerialVerbs';\nimport { createCarrier } from '../engine/entityCarrier';\nimport { screenShake } from '../engine/renderer';\nimport { emit } from '../engine/events';\nimport { spawnDamageNumber } from '../ui/damageNumbers';\nimport { TAG } from '../engine/tags';\n\n// --------------- Internal State ---------------\n\ntype SpikePhase = 'none' | 'windup' | 'strike' | 'recovery';\n\nlet phase: SpikePhase = 'none';\nlet target: any = null;\nlet phaseTimer = 0;              // ms since phase started\n\n// Aim snapshot (captured on first windup frame)\nlet aimX = 0;\nlet aimZ = 0;\n\n// Velocity override \u2014 when non-null, player.ts should use this for playerVelY\nlet playerVelYOverride: number | null = null;\n\n// Fast fall flag \u2014 player.ts reads this for enhanced gravity after verb completes\nlet fastFallActive = false;\n\n// --------------- AerialVerb Implementation ---------------\n\nexport const spikeVerb: AerialVerb = {\n  name: 'spike',\n  tag: TAG.AERIAL_SPIKE,\n  interruptible: false,\n\n  canClaim(_entry: LaunchedEnemy, _playerPos: any, _inputState: any): boolean {\n    // Spike is activated via float selector transfer, always allow claim\n    return true;\n  },\n\n  onClaim(entry: LaunchedEnemy): void {\n    phase = 'windup';\n    target = entry.enemy;\n    phaseTimer = 0;\n    playerVelYOverride = 0;  // hold player in place\n    fastFallActive = false;\n\n    // Zero gravity on enemy during windup\n    setGravityOverride(entry.enemy, 0);\n\n    // Small screen shake telegraph\n    screenShake(0.5);\n  },\n\n  update(dt: number, entry: LaunchedEnemy, playerPos: any, inputState: any): 'active' | 'complete' | 'cancel' {\n    const enemy = entry.enemy;\n\n    if (phase === 'windup') {\n      return updateWindup(dt, enemy, playerPos, inputState);\n    } else if (phase === 'recovery') {\n      return updateRecovery(dt);\n    }\n\n    return 'cancel';\n  },\n\n  onCancel(entry: LaunchedEnemy): void {\n    setGravityOverride(entry.enemy, 1);\n    resetState();\n  },\n\n  onComplete(entry: LaunchedEnemy): void {\n    resetState();\n  },\n};\n\n// --------------- Windup Phase Update ---------------\n\nfunction updateWindup(dt: number, enemy: any, playerPos: any, inputState: any): 'active' | 'complete' | 'cancel' {\n  phaseTimer += dt * 1000;\n\n  // Hold enemy in place\n  enemy.vel.y = 0;\n\n  // Snapshot aim position on first frame\n  if (phaseTimer <= dt * 1000 + 0.1) {\n    aimX = inputState.aimWorldPos.x;\n    aimZ = inputState.aimWorldPos.z;\n  }\n\n  // Hold player in place\n  playerVelYOverride = 0;\n\n  // Check if windup is done\n  if (phaseTimer >= SPIKE.windupDuration) {\n    executeStrike(enemy, playerPos);\n    return 'active';\n  }\n\n  return 'active';\n}\n\n// --------------- Strike (Instantaneous) ---------------\n\nfunction executeStrike(enemy: any, playerPos: any): void {\n  // Deal damage\n  enemy.health -= SPIKE.damage;\n  enemy.flashTimer = 150;\n\n  // Calculate carrier direction: angled downward toward aim position\n  const dx = aimX - playerPos.x;\n  const dz = aimZ - playerPos.z;\n  const horizontalDist = Math.sqrt(dx * dx + dz * dz) || 0.01;\n  const nx = dx / horizontalDist;\n  const nz = dz / horizontalDist;\n\n  // Vertical component: -tan(angle) gives downward slope\n  const angleRad = SPIKE.projectileAngle * Math.PI / 180;\n  const dirY = -Math.tan(angleRad);\n\n  const dirX = nx;\n  const dirZ = nz;\n\n  // Create carrier \u2014 entity carrier normalizes direction and applies speed\n  createCarrier(enemy, { x: dirX, y: dirY, z: dirZ }, {\n    speed: SPIKE.projectileSpeed,\n    gravityMult: 0.5,  // some gravity for arc feel\n    throughDamage: SPIKE.throughDamage,\n    throughKnockback: SPIKE.throughKnockback,\n    impactDamage: SPIKE.impactDamage,\n    impactRadius: SPIKE.impactRadius,\n    impactKnockback: SPIKE.impactKnockback,\n    impactShake: SPIKE.impactShake,\n  });\n\n  // Screen shake\n  screenShake(SPIKE.screenShake);\n\n  // Emit event\n  emit({\n    type: 'spikeStrike',\n    enemy,\n    damage: SPIKE.damage,\n    position: { x: enemy.pos.x, z: enemy.pos.z },\n  });\n\n  // Damage number\n  spawnDamageNumber(enemy.pos.x, enemy.pos.z, `SPIKE! ${SPIKE.damage}`, '#ff4488');\n\n  // Transition to recovery\n  phase = 'recovery';\n  phaseTimer = 0;\n  playerVelYOverride = 0;  // hang during recovery\n  fastFallActive = true;\n}\n\n// --------------- Recovery Phase Update ---------------\n\nfunction updateRecovery(dt: number): 'active' | 'complete' | 'cancel' {\n  phaseTimer += dt * 1000;\n\n  // Hold player in place during hang\n  playerVelYOverride = 0;\n\n  if (phaseTimer >= SPIKE.hangDuration) {\n    // Recovery complete \u2014 release player to fast-fall\n    playerVelYOverride = null;\n    return 'complete';\n  }\n\n  return 'active';\n}\n\n// --------------- Public State Queries ---------------\n\nexport function getSpikePhase(): SpikePhase {\n  return phase;\n}\n\nexport function getSpikePlayerVelYOverride(): number | null {\n  return playerVelYOverride;\n}\n\nexport function getSpikeFastFallActive(): boolean {\n  return fastFallActive;\n}\n\n// --------------- Reset ---------------\n\nfunction resetState(): void {\n  phase = 'none';\n  target = null;\n  phaseTimer = 0;\n  aimX = 0;\n  aimZ = 0;\n  playerVelYOverride = null;\n  fastFallActive = false;\n}\n\nexport function resetSpike(): void {\n  resetState();\n}\n", "// Physics config \u2014 tunable via tuning panel\n// Controls velocity-based knockback, wall slam damage, and bounce behavior\n\nexport const PHYSICS = {\n  // Knockback velocity\n  friction: 25,              // deceleration rate (units/s\u00B2) \u2014 higher = snappier stop\n  minVelocity: 0.1,          // below this speed, zero out velocity\n  pushInstantRatio: 0,       // fraction of knockback as instant position offset (0 = pure velocity)\n\n  // Wall slam\n  wallSlamMinSpeed: 3,       // minimum impact speed for wall damage\n  wallSlamDamage: 8,         // damage per unit of impact speed above threshold\n  wallSlamStun: 400,         // ms stun on wall slam\n  wallSlamBounce: 0.4,       // velocity reflection coefficient (0 = dead stop, 1 = perfect bounce)\n  wallSlamShake: 3,          // screen shake intensity on wall slam\n\n  // Force push wave occlusion\n  pushWaveBlockRadius: 0.8,  // lateral distance for one enemy to block another from push wave\n\n  // Enemy-enemy collision\n  enemyBounce: 0.4,          // enemy-enemy restitution coefficient\n  impactMinSpeed: 2,         // minimum relative speed for collision damage\n  impactDamage: 5,           // damage per unit of relative speed above threshold\n  impactStun: 300,           // ms stun when hit by another enemy\n\n  // Y-axis / vertical physics\n  gravity: 25,               // units/s\u00B2 downward acceleration\n  terminalVelocity: 20,      // max downward Y velocity\n  airControlMult: 1.0,       // XZ movement multiplier while airborne (1.0 = full control)\n  landingLagBase: 50,        // ms of landing lag (minimum)\n  landingLagPerSpeed: 10,    // ms of landing lag per unit of fall speed\n  groundEpsilon: 0.05,       // height threshold for \"grounded\" detection\n\n  // Physics objects\n  objectFriction: 25,\n  objectWallSlamMinSpeed: 3,\n  objectWallSlamDamage: 8,\n  objectWallSlamBounce: 0.4,\n  objectWallSlamShake: 2,\n  objectImpactMinSpeed: 2,\n  objectImpactDamage: 5,\n};\n", "// Launch Pillar \u2014 rock column that erupts from the ground at the launch point.\n// Follows aoeTelegraph.ts pattern: create mesh, track in array, animate per-frame, dispose.\n\nimport { LAUNCH } from '../config/player';\n\nlet sceneRef: any;\n\n// Active pillars being animated\nconst activePillars: any[] = [];\n\n// Shared geometry (lazy-init, 6-sided cylinder for rocky look)\nlet pillarGeo: any;\n\n// --- Init ---\n\nexport function initLaunchPillars(scene: any) {\n  sceneRef = scene;\n}\n\n// --- Spawn ---\n\nexport function spawnLaunchPillar(x: number, z: number) {\n  if (!sceneRef) return;\n\n  if (!pillarGeo) {\n    pillarGeo = new THREE.CylinderGeometry(\n      LAUNCH.pillarRadius * 0.7, // top radius (tapered)\n      LAUNCH.pillarRadius,       // bottom radius\n      LAUNCH.pillarHeight,\n      6                          // 6 sides \u2014 hexagonal for rocky look\n    );\n  }\n\n  // Per-pillar material instance (independent opacity for fading)\n  const mat = new THREE.MeshStandardMaterial({\n    color: LAUNCH.pillarColor,\n    flatShading: true,\n    transparent: true,\n    opacity: 1.0,\n  });\n\n  const mesh = new THREE.Mesh(pillarGeo, mat);\n  // Start below ground \u2014 pivot is at cylinder center, so offset by half height\n  mesh.position.set(x, -LAUNCH.pillarHeight, z);\n  // Random Y rotation for visual variety\n  mesh.rotation.y = Math.random() * Math.PI * 2;\n  sceneRef.add(mesh);\n\n  activePillars.push({\n    mesh,\n    material: mat,\n    elapsed: 0,\n  });\n}\n\n// --- Update ---\n\nfunction easeOutQuad(t: number) {\n  return t * (2 - t);\n}\n\nfunction easeInQuad(t: number) {\n  return t * t;\n}\n\nexport function updateLaunchPillars(dt: number) {\n  const dtMs = dt * 1000;\n\n  for (let i = activePillars.length - 1; i >= 0; i--) {\n    const p = activePillars[i];\n    p.elapsed += dtMs;\n\n    const { pillarRiseTime, pillarHoldTime, pillarDuration, pillarHeight } = LAUNCH;\n    const sinkStart = pillarRiseTime + pillarHoldTime;\n    const sinkDuration = pillarDuration - sinkStart;\n\n    if (p.elapsed < pillarRiseTime) {\n      // Rise phase \u2014 ease-out emergence\n      const t = easeOutQuad(p.elapsed / pillarRiseTime);\n      // From fully buried (-pillarHeight) to ground-level position (half height above ground)\n      p.mesh.position.y = -pillarHeight + t * (pillarHeight * 0.5 + pillarHeight);\n    } else if (p.elapsed < sinkStart) {\n      // Hold phase \u2014 at peak\n      p.mesh.position.y = pillarHeight * 0.5;\n    } else if (p.elapsed < pillarDuration) {\n      // Sink phase \u2014 ease-in descent + opacity fade\n      const sinkT = easeInQuad((p.elapsed - sinkStart) / sinkDuration);\n      p.mesh.position.y = pillarHeight * 0.5 - sinkT * (pillarHeight * 0.5 + pillarHeight);\n      p.material.opacity = 1 - sinkT;\n    } else {\n      // Done \u2014 remove\n      p.material.dispose();\n      sceneRef.remove(p.mesh);\n      activePillars.splice(i, 1);\n    }\n  }\n}\n\n// --- Cleanup ---\n\nexport function clearLaunchPillars() {\n  for (const p of activePillars) {\n    p.material.dispose();\n    sceneRef.remove(p.mesh);\n  }\n  activePillars.length = 0;\n}\n", "// Launch Indicator \u2014 shows which enemy will be launched (passive ring + emissive highlight)\n// and intensifies during the windup phase before launch fires.\n\nimport { LAUNCH } from '../config/player';\n\nlet sceneRef: any;\n\n// Ring mesh (singleton \u2014 repositioned each frame)\nlet ringGeo: any;\nlet ringMat: any;\nlet ringMesh: any;\n\n// Target tracking (to restore emissive when target changes)\nlet previousTarget: any = null;\n\n// --- Init ---\n\nexport function initLaunchIndicator(scene: any) {\n  sceneRef = scene;\n}\n\n// --- Target Finding ---\n\nexport function findLaunchTarget(enemies: any[], playerPos: any): any | null {\n  let closestEnemy: any = null;\n  let closestDistSq = LAUNCH.range * LAUNCH.range;\n  for (let i = 0; i < enemies.length; i++) {\n    const e = enemies[i];\n    if (e.health <= 0 || e.fellInPit) continue;\n    const dx = e.pos.x - playerPos.x;\n    const dz = e.pos.z - playerPos.z;\n    const distSq = dx * dx + dz * dz;\n    if (distSq < closestDistSq) {\n      closestDistSq = distSq;\n      closestEnemy = e;\n    }\n  }\n  return closestEnemy;\n}\n\n// --- Ring Mesh (lazy init) ---\n\nfunction ensureRing() {\n  if (ringMesh) return;\n  if (!sceneRef) return;\n\n  const innerRadius = LAUNCH.indicatorRingRadius * 0.65;\n  ringGeo = new THREE.RingGeometry(innerRadius, LAUNCH.indicatorRingRadius, 24);\n  ringGeo.rotateX(-Math.PI / 2); // lay flat on ground\n\n  ringMat = new THREE.MeshBasicMaterial({\n    color: LAUNCH.indicatorColor,\n    transparent: true,\n    opacity: LAUNCH.indicatorOpacity,\n    side: THREE.DoubleSide,\n    depthWrite: false,\n  });\n\n  ringMesh = new THREE.Mesh(ringGeo, ringMat);\n  ringMesh.renderOrder = -1;\n  ringMesh.visible = false;\n  sceneRef.add(ringMesh);\n}\n\n// --- Emissive Helpers ---\n\nfunction setTargetHighlight(enemy: any, intensity: number) {\n  if (!enemy || !enemy.bodyMesh) return;\n  enemy.bodyMesh.material.emissive.setHex(LAUNCH.indicatorColor);\n  enemy.bodyMesh.material.emissiveIntensity = intensity;\n  if (enemy.headMesh) {\n    enemy.headMesh.material.emissive.setHex(LAUNCH.indicatorColor);\n    enemy.headMesh.material.emissiveIntensity = intensity;\n  }\n}\n\nfunction restoreTargetEmissive(enemy: any) {\n  if (!enemy || !enemy.bodyMesh || !enemy.config) return;\n  enemy.bodyMesh.material.emissive.setHex(enemy.config.emissive);\n  enemy.bodyMesh.material.emissiveIntensity = enemy.config.emissiveIntensity || 0.3;\n  if (enemy.headMesh) {\n    enemy.headMesh.material.emissive.setHex(enemy.config.emissive);\n    enemy.headMesh.material.emissiveIntensity = enemy.config.emissiveIntensity || 0.3;\n  }\n}\n\n// --- Update ---\n\n/**\n * @param target - The enemy to highlight (null = no target)\n * @param windupProgress - Negative = passive mode, 0..1 = windup intensification\n */\nexport function updateLaunchIndicator(target: any, windupProgress: number) {\n  ensureRing();\n\n  // Target changed \u2014 restore previous\n  if (previousTarget && previousTarget !== target) {\n    restoreTargetEmissive(previousTarget);\n  }\n  previousTarget = target;\n\n  if (!target) {\n    // No target \u2014 hide everything\n    if (ringMesh) ringMesh.visible = false;\n    return;\n  }\n\n  // Position ring under enemy\n  if (ringMesh) {\n    ringMesh.position.set(target.pos.x, 0.04, target.pos.z);\n    ringMesh.visible = true;\n  }\n\n  if (windupProgress < 0) {\n    // --- Passive mode: gentle pulse ---\n    const pulse = 0.3 + 0.1 * Math.sin(performance.now() * 0.004);\n    if (ringMat) {\n      ringMat.opacity = LAUNCH.indicatorOpacity * pulse / 0.3;\n    }\n    if (ringMesh) {\n      ringMesh.scale.setScalar(1.0);\n    }\n    setTargetHighlight(target, 0.5);\n  } else {\n    // --- Windup mode: intensify with progress (0 \u2192 1) ---\n    const t = Math.min(windupProgress, 1);\n\n    // Ring: opacity ramps, faster pulse\n    const pulse = 0.8 + 0.2 * Math.sin(performance.now() * 0.015);\n    if (ringMat) {\n      ringMat.opacity = (LAUNCH.indicatorOpacity + (0.8 - LAUNCH.indicatorOpacity) * t) * pulse;\n    }\n\n    // Ring: slight scale pulse during windup\n    if (ringMesh) {\n      const scalePulse = 1.0 + 0.15 * Math.sin(performance.now() * 0.02) * t;\n      ringMesh.scale.setScalar(scalePulse);\n    }\n\n    // Enemy emissive ramps up\n    setTargetHighlight(target, 0.5 + 0.5 * t);\n  }\n}\n\n// --- Cleanup ---\n\nexport function clearLaunchIndicator() {\n  if (previousTarget) {\n    restoreTargetEmissive(previousTarget);\n    previousTarget = null;\n  }\n  if (ringMesh && sceneRef) {\n    sceneRef.remove(ringMesh);\n    ringMesh = null;\n  }\n  if (ringMat) {\n    ringMat.dispose();\n    ringMat = null;\n  }\n  if (ringGeo) {\n    ringGeo.dispose();\n    ringGeo = null;\n  }\n}\n", "import { PLAYER, MELEE, JUMP, LAUNCH, AERIAL_STRIKE, SELF_SLAM, SPIKE } from '../config/player';\nimport { ABILITIES } from '../config/abilities';\nimport { ARENA_HALF_X, ARENA_HALF_Z } from '../config/arena';\nimport { screenShake, getScene } from '../engine/renderer';\nimport { getAbilityDirOverride, clearAbilityDirOverride } from '../engine/input';\nimport { getIceEffects } from './mortarProjectile';\nimport { emit } from '../engine/events';\nimport { createPlayerRig, getGhostGeometries } from './playerRig';\nimport type { PlayerRig } from './playerRig';\nimport { createAnimatorState, updateAnimation, resetAnimatorState } from './playerAnimator';\nimport type { AnimatorState } from './playerAnimator';\nimport { getActiveProfile } from '../engine/profileManager';\nimport { fireProjectile } from './projectile';\nimport { registerLaunch, claimLaunched, activateVerb } from '../engine/aerialVerbs';\nimport { playerHasTag, clearPlayerTags, TAG } from '../engine/tags';\nimport { getDunkPhase, getDunkPlayerVelY, getDunkLandingLag, updateDunkVisuals, resetDunk } from '../verbs/dunk';\nimport { getFloatSelectorPlayerVelY, resetFloatSelector } from '../verbs/floatSelector';\nimport { getSpikePlayerVelYOverride, getSpikeFastFallActive, resetSpike } from '../verbs/spike';\nimport { getGroundHeight } from '../config/terrain';\nimport { PHYSICS } from '../config/physics';\nimport { spawnLaunchPillar } from '../effects/launchPillar';\nimport { findLaunchTarget, updateLaunchIndicator, clearLaunchIndicator } from '../effects/launchIndicator';\nimport { spawnDamageNumber } from '../ui/damageNumbers';\n\nlet playerGroup: any, aimIndicator: any;\nlet rig: PlayerRig;\nlet animState: AnimatorState;\nconst playerPos = new THREE.Vector3(0, 0, 0);\n\n// Melee state\nlet meleeSwinging = false;\nlet meleeCooldownTimer = 0;  // ms remaining until next swing allowed\nlet meleeSwingTimer = 0;     // ms into current swing (for animation)\nconst MELEE_SWING_DURATION = 200; // ms \u2014 how long the swing animation plays\nconst meleeHitEnemies: Set<any> = new Set(); // track which enemies were hit this swing (multi-hit)\nlet meleeSwingDir = 0;        // angle of the swing (radians)\n\n// Dash state\nlet isDashing = false;\nlet dashTimer = 0;\nlet dashDuration = 0;\nlet dashDistance = 0;\nconst dashDir = new THREE.Vector3();\nconst dashStartPos = new THREE.Vector3();\nlet isInvincible = false;\nlet endLagTimer = 0;\n\n// Afterimages\nconst afterimages: any[] = [];\n\n// Push event (consumed by physics each frame)\nlet pushEvent: any = null;\n\n// Charge state\nlet isCharging = false;\nlet chargeTimer = 0;\nlet chargeAimAngle = 0;\nlet chargeTelegraphGroup: any = null;\nlet chargeFillMesh: any = null;\nlet chargeBorderMesh: any = null;\nlet chargeBorderGeo: any = null;\n\n// Jump / vertical state (active only in vertical profile)\nlet playerVelY = 0;\nlet isPlayerAirborne = false;\nlet landingLagTimer = 0;\nlet actionLockoutTimer = 0;\nconst ACTION_LOCKOUT_MS = 300;\n\n// Launch verb state\nlet launchCooldownTimer = 0;\nlet launchWindupTimer = 0;\nlet launchWindupTarget: any = null;\n\n// Self-slam state\nlet isSlamming = false;\n\n// Origin model (cylinder+sphere \u2014 Feb 7 prototype visual)\nlet originGroup: any = null;\nlet lastFireTime = 0;\n\n// Original emissive colors (used for charge glow reset)\nconst DEFAULT_EMISSIVE = 0x22aa66;\nconst DEFAULT_EMISSIVE_INTENSITY = 0.4;\n\nfunction restoreDefaultEmissive() {\n  if (!rig) return;\n  for (const mat of rig.materials) {\n    mat.emissive.setHex(DEFAULT_EMISSIVE);\n    mat.emissiveIntensity = DEFAULT_EMISSIVE_INTENSITY;\n  }\n}\n\nexport function setPlayerVisual(profile: string) {\n  if (!originGroup || !rig) return;\n  const isOrigin = profile === 'origin';\n  originGroup.visible = isOrigin;\n  rig.joints.rigRoot.visible = !isOrigin;\n}\n\nfunction updateOriginBob(dt: number) {\n  if (!originGroup || !originGroup.visible) return;\n  const t = performance.now() * 0.003;\n  originGroup.position.y = Math.sin(t) * 0.04;\n  originGroup.rotation.y = 0; // no spin \u2014 facing handled by playerGroup\n}\n\nexport function createPlayer(scene: any) {\n  playerGroup = new THREE.Group();\n\n  // Build bipedal rig (joint hierarchy + box-limb meshes)\n  rig = createPlayerRig(playerGroup);\n  animState = createAnimatorState();\n\n  // Build origin model (cylinder+sphere \u2014 Feb 7 prototype)\n  originGroup = new THREE.Group();\n  const bodyGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.9, 8);\n  const bodyMat = new THREE.MeshStandardMaterial({ color: 0x44ff88, emissive: 0x22aa66, emissiveIntensity: 0.4 });\n  const body = new THREE.Mesh(bodyGeo, bodyMat);\n  body.position.y = 0.45;\n  originGroup.add(body);\n  const headGeo = new THREE.SphereGeometry(0.25, 8, 6);\n  const headMat = new THREE.MeshStandardMaterial({ color: 0x66ffaa, emissive: 0x22aa66, emissiveIntensity: 0.4 });\n  const head = new THREE.Mesh(headGeo, headMat);\n  head.position.y = 1.1;\n  originGroup.add(head);\n  originGroup.visible = false;\n  playerGroup.add(originGroup);\n\n  // Aim indicator \u2014 attached to playerGroup directly (not rig)\n  // so squash/stretch doesn't affect it\n  aimIndicator = new THREE.Mesh(\n    new THREE.ConeGeometry(0.12, 0.6, 4),\n    new THREE.MeshStandardMaterial({\n      color: 0x44ff88,\n      emissive: 0x44ff88,\n      emissiveIntensity: 0.8\n    })\n  );\n  aimIndicator.rotation.x = -Math.PI / 2;\n  aimIndicator.position.set(0, 0.8, -0.7);\n  playerGroup.add(aimIndicator);\n\n  scene.add(playerGroup);\n  return playerGroup;\n}\n\nexport function updatePlayer(inputState: any, dt: number, gameState: any) {\n  const now = performance.now();\n\n  // Tick ability cooldowns\n  for (const key of Object.keys(gameState.abilities)) {\n    if (gameState.abilities[key].cooldownRemaining > 0) {\n      gameState.abilities[key].cooldownRemaining -= dt * 1000;\n    }\n  }\n\n  // Tick charge system\n  if (isCharging) {\n    updateCharge(inputState, dt, gameState);\n  }\n\n  // End lag (post-dash lockout)\n  if (endLagTimer > 0) {\n    endLagTimer -= dt * 1000;\n    // During end lag, don't process movement or abilities\n    playerGroup.position.copy(playerPos);\n    aimAtCursor(inputState);\n    if (getActiveProfile() === 'origin') {\n      updateOriginBob(dt);\n    } else {\n      updateAnimation(rig.joints, animState, dt,\n        { moveX: 0, moveZ: 0 }, playerGroup.rotation.y,\n        false, true, 0);\n    }\n    updateAfterimages(dt);\n    return;\n  }\n\n  // === DASH ===\n  if (isDashing) {\n    updateDash(dt, gameState);\n    playerGroup.position.copy(playerPos);\n\n    // Aim still tracks cursor during dash\n    aimAtCursor(inputState);\n\n    if (getActiveProfile() === 'origin') {\n      updateOriginBob(dt);\n    } else {\n      updateAnimation(rig.joints, animState, dt,\n        { moveX: inputState.moveX, moveZ: inputState.moveZ }, playerGroup.rotation.y,\n        true, false, Math.min(dashTimer / dashDuration, 1));\n    }\n    updateAfterimages(dt);\n    return;\n  }\n\n  // Trigger dash\n  if (inputState.dash && gameState.abilities.dash.cooldownRemaining <= 0) {\n    startDash(inputState, gameState);\n  }\n\n  // Trigger charge (start) \u2014 not available in origin profile\n  if (getActiveProfile() !== 'origin' && (inputState.chargeStarted || (inputState.ultimate && getActiveProfile() !== 'vertical')) && gameState.abilities.ultimate.cooldownRemaining <= 0 && !isCharging && !isPlayerAirborne && !playerHasTag(TAG.AERIAL) && actionLockoutTimer <= 0) {\n    startCharge(inputState, gameState);\n  }\n\n  // === VERTICAL MECHANICS (vertical profile only) ===\n  if (getActiveProfile() === 'vertical') {\n    // Jump (Space)\n    if (inputState.jump && !isPlayerAirborne && !isDashing && landingLagTimer <= 0) {\n      playerVelY = JUMP.initialVelocity;\n      isPlayerAirborne = true;\n      emit({ type: 'playerJump', position: { x: playerPos.x, z: playerPos.z } });\n    }\n\n    // Launch cooldown\n    if (launchCooldownTimer > 0) {\n      launchCooldownTimer -= dt * 1000;\n    }\n\n    // Cancel windup if player starts dashing or target dies\n    if (launchWindupTimer > 0) {\n      if (isDashing || !launchWindupTarget || launchWindupTarget.health <= 0 || launchWindupTarget.fellInPit) {\n        updateLaunchIndicator(null, -1);\n        launchWindupTimer = 0;\n        launchWindupTarget = null;\n      }\n    }\n\n    if (launchWindupTimer > 0) {\n      // Winding up: tick timer, intensify visuals, fire when done\n      launchWindupTimer -= dt * 1000;\n      const progress = 1 - Math.max(0, launchWindupTimer) / LAUNCH.windupDuration;\n      updateLaunchIndicator(launchWindupTarget, progress);\n\n      if (launchWindupTimer <= 0) {\n        // Fire the launch\n        const closestEnemy = launchWindupTarget;\n        launchWindupTarget = null;\n        updateLaunchIndicator(null, -1);\n\n        const vel = (closestEnemy as any).vel;\n        const launchVelY = JUMP.initialVelocity * LAUNCH.enemyVelMult;\n        if (vel) {\n          vel.y = launchVelY;\n          const arcDx = playerPos.x - closestEnemy.pos.x;\n          const arcDz = playerPos.z - closestEnemy.pos.z;\n          const arcDist = Math.sqrt(arcDx * arcDx + arcDz * arcDz);\n          if (arcDist > 0.1) {\n            const convergenceTime = launchVelY / PHYSICS.gravity;\n            const arcSpeed = (arcDist * LAUNCH.arcFraction) / convergenceTime;\n            vel.x = (arcDx / arcDist) * arcSpeed;\n            vel.z = (arcDz / arcDist) * arcSpeed;\n          }\n        }\n\n        spawnLaunchPillar(closestEnemy.pos.x, closestEnemy.pos.z);\n        closestEnemy.health -= LAUNCH.damage;\n\n        playerVelY = JUMP.initialVelocity * LAUNCH.playerVelMult;\n        isPlayerAirborne = true;\n        launchCooldownTimer = LAUNCH.cooldown;\n\n        registerLaunch(closestEnemy);\n        claimLaunched(closestEnemy, 'floatSelector');\n        activateVerb('floatSelector', closestEnemy);\n\n        emit({\n          type: 'enemyLaunched',\n          enemy: closestEnemy,\n          position: { x: closestEnemy.pos.x, z: closestEnemy.pos.z },\n          velocity: JUMP.initialVelocity * LAUNCH.enemyVelMult,\n        });\n        spawnDamageNumber(closestEnemy.pos.x, closestEnemy.pos.z, `LAUNCH! ${LAUNCH.damage}`, '#ffaa00');\n        inputState.launch = false;\n      }\n    } else if (inputState.launch && !isPlayerAirborne && !isDashing && launchCooldownTimer <= 0) {\n      // Start windup if target found\n      const closestEnemy = findLaunchTarget(gameState.enemies || [], playerPos);\n      if (closestEnemy) {\n        launchWindupTarget = closestEnemy;\n        launchWindupTimer = LAUNCH.windupDuration;\n        const dx = closestEnemy.pos.x - playerPos.x;\n        const dz = closestEnemy.pos.z - playerPos.z;\n        playerGroup.rotation.y = Math.atan2(-dx, -dz);\n        inputState.launch = false;\n      }\n    } else if (!isPlayerAirborne && !isDashing && launchCooldownTimer <= 0 && launchWindupTimer <= 0) {\n      // Passive: show indicator on closest enemy in range\n      const candidate = findLaunchTarget(gameState.enemies || [], playerPos);\n      updateLaunchIndicator(candidate, -1);\n    } else if (launchWindupTimer <= 0) {\n      updateLaunchIndicator(null, -1);\n    }\n\n    // Self-slam (E while airborne, no active verb)\n    if (inputState.launch && isPlayerAirborne && !isSlamming && !playerHasTag(TAG.AERIAL)) {\n      isSlamming = true;\n      playerVelY = SELF_SLAM.slamVelocity;\n    }\n  }\n\n  // === MOVEMENT ===\n  if (Math.abs(inputState.moveX) > 0.01 || Math.abs(inputState.moveZ) > 0.01) {\n    const chargeSlow = isCharging ? ABILITIES.ultimate.chargeMoveSpeedMult : 1;\n    // Check for ice patch effects (doubled speed on ice)\n    const iceEffects = getIceEffects(playerPos.x, playerPos.z, true);\n    const speedMod = chargeSlow * iceEffects.speedMult;\n    playerPos.x += inputState.moveX * PLAYER.speed * speedMod * dt;\n    playerPos.z += inputState.moveZ * PLAYER.speed * speedMod * dt;\n\n  }\n\n  // Arena clamp \u2014 0.5 margin from walls (dynamic per room size)\n  const clampX = ARENA_HALF_X - 0.5;\n  const clampZ = ARENA_HALF_Z - 0.5;\n  playerPos.x = Math.max(-clampX, Math.min(clampX, playerPos.x));\n  playerPos.z = Math.max(-clampZ, Math.min(clampZ, playerPos.z));\n\n  // === LEDGE FALL + Y-AXIS PHYSICS (vertical profile only) ===\n  if (getActiveProfile() === 'vertical') {\n    if (!isPlayerAirborne) {\n      const groundBelow = getGroundHeight(playerPos.x, playerPos.z);\n      if (playerPos.y > groundBelow + PHYSICS.groundEpsilon) {\n        isPlayerAirborne = true;\n        playerVelY = 0;\n      }\n    }\n\n    if (isPlayerAirborne) {\n      const dunkVelY = getDunkPlayerVelY();\n      const selectorVelY = getFloatSelectorPlayerVelY();\n      const spikeVelY = getSpikePlayerVelYOverride();\n      const hasVerbOverride = dunkVelY !== null || selectorVelY !== null || spikeVelY !== null;\n\n      if (hasVerbOverride) {\n        if (dunkVelY !== null) playerVelY = dunkVelY;\n        else if (selectorVelY !== null) playerVelY = selectorVelY;\n        else if (spikeVelY !== null) playerVelY = spikeVelY;\n      } else {\n        playerVelY -= JUMP.gravity * dt;\n        if (getSpikeFastFallActive()) {\n          playerVelY -= JUMP.gravity * (SPIKE.fastFallGravityMult - 1) * dt;\n        }\n      }\n\n      playerPos.y += playerVelY * dt;\n\n      const groundHeight = getGroundHeight(playerPos.x, playerPos.z);\n      if (playerPos.y <= groundHeight) {\n        const fallSpeed = Math.abs(playerVelY);\n        playerPos.y = groundHeight;\n        playerVelY = 0;\n        isPlayerAirborne = false;\n\n        if (isSlamming) {\n          isSlamming = false;\n          landingLagTimer = SELF_SLAM.landingLag;\n          screenShake(SELF_SLAM.landingShake);\n          const enemies = gameState.enemies;\n          if (enemies) {\n            for (let i = 0; i < enemies.length; i++) {\n              const e = enemies[i];\n              if (e.health <= 0 || (e as any).fellInPit) continue;\n              const dx = e.pos.x - playerPos.x;\n              const dz = e.pos.z - playerPos.z;\n              const distSq = dx * dx + dz * dz;\n              if (distSq < SELF_SLAM.damageRadius * SELF_SLAM.damageRadius) {\n                e.health -= SELF_SLAM.damage;\n                e.flashTimer = 100;\n                const dist = Math.sqrt(distSq) || 0.1;\n                const vel = (e as any).vel;\n                if (vel) {\n                  vel.x += (dx / dist) * SELF_SLAM.knockback;\n                  vel.z += (dz / dist) * SELF_SLAM.knockback;\n                }\n              }\n            }\n          }\n          emit({ type: 'playerSlam', position: { x: playerPos.x, z: playerPos.z }, fallSpeed });\n          spawnDamageNumber(playerPos.x, playerPos.z, 'SLAM!', '#ff8800');\n        } else if (getDunkPhase() === 'slam') {\n          const lag = getDunkLandingLag();\n          if (lag > 0) landingLagTimer = lag;\n          actionLockoutTimer = ACTION_LOCKOUT_MS;\n        } else {\n          landingLagTimer = JUMP.landingLag;\n          emit({ type: 'playerLand', position: { x: playerPos.x, z: playerPos.z }, fallSpeed });\n        }\n      }\n    }\n    if (landingLagTimer > 0) landingLagTimer -= dt * 1000;\n    if (actionLockoutTimer > 0) actionLockoutTimer -= dt * 1000;\n    updateDunkVisuals(dt);\n  }\n\n  playerGroup.position.copy(playerPos);\n\n  // === AIM ===\n  aimAtCursor(inputState);\n\n  // === PROCEDURAL ANIMATION ===\n  if (getActiveProfile() === 'origin') {\n    updateOriginBob(dt);\n  } else {\n    updateAnimation(\n      rig.joints,\n      animState,\n      dt,\n      { moveX: inputState.moveX, moveZ: inputState.moveZ },\n      playerGroup.rotation.y,\n      isDashing,\n      endLagTimer > 0,\n      isDashing ? Math.min(dashTimer / dashDuration, 1) : 0,\n      meleeSwinging,\n      meleeSwinging ? meleeSwingTimer / MELEE_SWING_DURATION : 0,\n      getActiveProfile() === 'vertical' ? isPlayerAirborne : false,\n      getActiveProfile() === 'vertical' ? playerVelY : 0,\n      getActiveProfile() === 'vertical' ? (isSlamming || getDunkPhase() === 'slam') : false,\n      isCharging,\n      isCharging ? Math.min(chargeTimer / ABILITIES.ultimate.chargeTimeMs, 1) : 0\n    );\n  }\n\n  // === AUTO-FIRE (origin profile only) ===\n  if (getActiveProfile() === 'origin' && !isDashing) {\n    if (now - lastFireTime >= PLAYER.fireRate) {\n      lastFireTime = now;\n      const aimDx = inputState.aimWorldPos.x - playerPos.x;\n      const aimDz = inputState.aimWorldPos.z - playerPos.z;\n      const aimDir = new THREE.Vector3(aimDx, 0, aimDz).normalize();\n      fireProjectile(playerPos, aimDir, PLAYER.projectile);\n    }\n  }\n\n  // === MELEE COOLDOWN ===\n  if (meleeCooldownTimer > 0) {\n    meleeCooldownTimer -= dt * 1000;\n  }\n\n  // === MELEE SWING UPDATE ===\n  if (meleeSwinging) {\n    meleeSwingTimer += dt * 1000;\n    if (meleeSwingTimer >= MELEE_SWING_DURATION) {\n      meleeSwinging = false;\n      meleeSwingTimer = 0;\n    }\n  }\n\n  // === MELEE ATTACK (left click) \u2014 not available in origin profile ===\n  if (getActiveProfile() !== 'origin' && inputState.attack && meleeCooldownTimer <= 0 && !isDashing && !isCharging && !playerHasTag(TAG.AERIAL) && actionLockoutTimer <= 0) {\n    if (getActiveProfile() === 'vertical' && isPlayerAirborne) {\n      // \u2500\u2500\u2500 AERIAL STRIKE \u2014 downward spike on nearby enemy \u2500\u2500\u2500\n      const enemies = gameState.enemies;\n      let closestEnemy: any = null;\n      let closestDistSq = AERIAL_STRIKE.range * AERIAL_STRIKE.range;\n      if (enemies) {\n        for (let i = 0; i < enemies.length; i++) {\n          const e = enemies[i];\n          if (e.health <= 0 || (e as any).fellInPit) continue;\n          const dx = e.pos.x - playerPos.x;\n          const dz = e.pos.z - playerPos.z;\n          const distSq = dx * dx + dz * dz;\n          if (distSq < closestDistSq) {\n            closestDistSq = distSq;\n            closestEnemy = e;\n          }\n        }\n      }\n\n      if (closestEnemy) {\n        closestEnemy.health -= AERIAL_STRIKE.damage;\n        closestEnemy.flashTimer = 120;\n        const vel = (closestEnemy as any).vel;\n        if (vel) vel.y = AERIAL_STRIKE.slamVelocity;\n        const dx = closestEnemy.pos.x - playerPos.x;\n        const dz = closestEnemy.pos.z - playerPos.z;\n        playerGroup.rotation.y = Math.atan2(-dx, -dz);\n        screenShake(AERIAL_STRIKE.screenShake);\n        meleeCooldownTimer = AERIAL_STRIKE.cooldown;\n        emit({\n          type: 'aerialStrike',\n          enemy: closestEnemy,\n          damage: AERIAL_STRIKE.damage,\n          position: { x: closestEnemy.pos.x, z: closestEnemy.pos.z },\n        });\n        spawnDamageNumber(closestEnemy.pos.x, closestEnemy.pos.z, 'SPIKE!', '#44ddff');\n      } else {\n        meleeSwinging = true;\n        meleeSwingTimer = 0;\n        meleeCooldownTimer = MELEE.cooldown;\n        meleeHitEnemies.clear();\n        meleeSwingDir = playerGroup.rotation.y;\n        emit({\n          type: 'meleeSwing',\n          position: { x: playerPos.x, z: playerPos.z },\n          direction: { x: -Math.sin(meleeSwingDir), z: -Math.cos(meleeSwingDir) },\n        });\n      }\n    } else {\n      // Auto-targeting: snap aim to nearest enemy within cone before swinging\n      const enemies = gameState.enemies;\n      if (enemies) {\n        let bestDist = MELEE.autoTargetRange * MELEE.autoTargetRange;\n        let bestEnemy: any = null;\n        const aimAngle = playerGroup.rotation.y;\n        for (let i = 0; i < enemies.length; i++) {\n          const e = enemies[i];\n          if (e.health <= 0 || e.fellInPit) continue;\n          const dx = e.pos.x - playerPos.x;\n          const dz = e.pos.z - playerPos.z;\n          const distSq = dx * dx + dz * dz;\n          if (distSq > bestDist) continue;\n          // Check if within auto-target arc\n          const angleToEnemy = Math.atan2(-dx, -dz);\n          let angleDiff = angleToEnemy - aimAngle;\n          while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;\n          while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;\n          if (Math.abs(angleDiff) <= MELEE.autoTargetArc / 2) {\n            bestDist = distSq;\n            bestEnemy = e;\n          }\n        }\n        if (bestEnemy) {\n          const dx = bestEnemy.pos.x - playerPos.x;\n          const dz = bestEnemy.pos.z - playerPos.z;\n          playerGroup.rotation.y = Math.atan2(-dx, -dz);\n        }\n      }\n\n      meleeSwinging = true;\n      meleeSwingTimer = 0;\n      meleeCooldownTimer = MELEE.cooldown;\n      meleeHitEnemies.clear();\n      meleeSwingDir = playerGroup.rotation.y;\n\n      emit({\n        type: 'meleeSwing',\n        position: { x: playerPos.x, z: playerPos.z },\n        direction: { x: -Math.sin(meleeSwingDir), z: -Math.cos(meleeSwingDir) },\n      });\n    }\n  }\n\n  updateAfterimages(dt);\n}\n\nfunction aimAtCursor(inputState: any) {\n  const dx = inputState.aimWorldPos.x - playerPos.x;\n  const dz = inputState.aimWorldPos.z - playerPos.z;\n  if (dx * dx + dz * dz > 0.01) {\n    playerGroup.rotation.y = Math.atan2(-dx, -dz);\n  }\n}\n\n// === DASH SYSTEM ===\nfunction startDash(inputState: any, gameState: any) {\n  const cfg = ABILITIES.dash;\n  isDashing = true;\n  dashTimer = 0;\n  dashDuration = cfg.duration;\n  dashDistance = cfg.distance;\n  dashStartPos.copy(playerPos);\n\n  // Direction source \u2014 drag-to-aim override takes priority (mobile buttons)\n  const override = getAbilityDirOverride();\n  const hasMovement = Math.abs(inputState.moveX) > 0.01 || Math.abs(inputState.moveZ) > 0.01;\n\n  if (override) {\n    dashDir.set(override.x, 0, override.z).normalize();\n    clearAbilityDirOverride();\n  } else if (cfg.directionSource === 'movement' && hasMovement) {\n    dashDir.set(inputState.moveX, 0, inputState.moveZ).normalize();\n  } else if (cfg.directionSource === 'aim') {\n    dashDir.set(\n      inputState.aimWorldPos.x - playerPos.x, 0,\n      inputState.aimWorldPos.z - playerPos.z\n    ).normalize();\n  } else {\n    // 'movementOrAim' or fallback\n    if (hasMovement) {\n      dashDir.set(inputState.moveX, 0, inputState.moveZ).normalize();\n    } else {\n      dashDir.set(\n        inputState.aimWorldPos.x - playerPos.x, 0,\n        inputState.aimWorldPos.z - playerPos.z\n      ).normalize();\n    }\n  }\n\n  gameState.abilities.dash.cooldownRemaining = cfg.cooldown;\n\n  if (cfg.screenShakeOnStart > 0) {\n    screenShake(cfg.screenShakeOnStart, 80);\n  }\n\n  emit({ type: 'playerDash', direction: { x: dashDir.x, z: dashDir.z }, position: { x: playerPos.x, z: playerPos.z } });\n}\n\nfunction updateDash(dt: number, gameState: any) {\n  const cfg = ABILITIES.dash;\n  dashTimer += dt * 1000;\n  const t = Math.min(dashTimer / dashDuration, 1.0);\n\n  // Easing\n  let easedT: number;\n  switch (cfg.curve) {\n    case 'easeOut':   easedT = 1 - (1 - t) * (1 - t); break;\n    case 'easeIn':    easedT = t * t; break;\n    case 'easeInOut': easedT = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2; break;\n    default:          easedT = t;\n  }\n\n  // Position along dash path\n  playerPos.copy(dashStartPos);\n  playerPos.x += dashDir.x * dashDistance * easedT;\n  playerPos.z += dashDir.z * dashDistance * easedT;\n\n  // Arena clamp during dash \u2014 dynamic per room size\n  const dashClampX = ARENA_HALF_X - 0.5;\n  const dashClampZ = ARENA_HALF_Z - 0.5;\n  playerPos.x = Math.max(-dashClampX, Math.min(dashClampX, playerPos.x));\n  playerPos.z = Math.max(-dashClampZ, Math.min(dashClampZ, playerPos.z));\n\n  // I-frame window\n  isInvincible = cfg.invincible && (dashTimer >= cfg.iFrameStart && dashTimer <= cfg.iFrameEnd);\n\n  // Spawn afterimages at intervals (skip for origin profile \u2014 no rig ghosts)\n  if (cfg.afterimageCount > 0 && getActiveProfile() !== 'origin') {\n    const interval = dashDuration / (cfg.afterimageCount + 1);\n    const prevCount = Math.floor((dashTimer - dt * 1000) / interval);\n    const currCount = Math.floor(dashTimer / interval);\n    if (currCount > prevCount) {\n      spawnAfterimage(cfg);\n    }\n  }\n\n  // End dash\n  if (t >= 1.0) {\n    isDashing = false;\n    isInvincible = false;\n    endLagTimer = cfg.endLag;\n    emit({ type: 'playerDashEnd' });\n  }\n}\n\nfunction spawnAfterimage(cfg: any) {\n  const scene = getScene();\n  const ghost = new THREE.Group();\n\n  // Update world matrices so we can sample joint positions\n  playerGroup.updateMatrixWorld(true);\n\n  // Simplified ghost \u2014 torso + head silhouettes from rig world positions\n  const geos = getGhostGeometries();\n  const ghostMat = new THREE.MeshBasicMaterial({\n    color: cfg.ghostColor,\n    transparent: true,\n    opacity: 0.5,\n  });\n\n  // Torso ghost at rig torso's world position\n  const torsoWorld = new THREE.Vector3();\n  rig.joints.torso.getWorldPosition(torsoWorld);\n  const ghostTorso = new THREE.Mesh(geos.torso, ghostMat.clone());\n  ghostTorso.position.copy(torsoWorld).sub(playerPos);\n  ghost.add(ghostTorso);\n\n  // Head ghost at rig head's world position\n  const headWorld = new THREE.Vector3();\n  rig.joints.head.getWorldPosition(headWorld);\n  const ghostHead = new THREE.Mesh(geos.head, ghostMat.clone());\n  ghostHead.position.copy(headWorld).sub(playerPos);\n  ghost.add(ghostHead);\n\n  ghost.position.copy(playerPos);\n  ghost.rotation.y = playerGroup.rotation.y;\n  scene.add(ghost);\n\n  afterimages.push({ mesh: ghost, life: 0, maxLife: cfg.afterimageFadeDuration });\n}\n\nfunction updateAfterimages(dt: number) {\n  const scene = getScene();\n  for (let i = afterimages.length - 1; i >= 0; i--) {\n    const ai = afterimages[i];\n    ai.life += dt * 1000;\n    const fade = Math.max(0, 1 - ai.life / ai.maxLife);\n\n    ai.mesh.children.forEach((child: any) => {\n      if (child.material) child.material.opacity = fade * 0.5;\n    });\n\n    if (ai.life >= ai.maxLife) {\n      scene.remove(ai.mesh);\n      afterimages.splice(i, 1);\n    }\n  }\n}\n\n// === CHARGE PUSH SYSTEM ===\nfunction startCharge(inputState: any, gameState: any) {\n  const cfg = ABILITIES.ultimate;\n  isCharging = true;\n  chargeTimer = 0;\n  gameState.abilities.ultimate.charging = true;\n  gameState.abilities.ultimate.chargeT = 0;\n\n  // Calculate initial aim angle toward cursor\n  // atan2(dx, dz) so that sin(angle)=dx/len, cos(angle)=dz/len -> local +Z extends toward cursor\n  const dx = inputState.aimWorldPos.x - playerPos.x;\n  const dz = inputState.aimWorldPos.z - playerPos.z;\n  chargeAimAngle = Math.atan2(dx, dz);\n\n  // Create telegraph visual\n  createChargeTelegraph(cfg);\n\n  // Visual feedback \u2014 player glows while charging (skip for origin profile)\n  if (getActiveProfile() !== 'origin') {\n    for (const mat of rig.materials) {\n      mat.emissive.setHex(0x44ffaa);\n      mat.emissiveIntensity = 0.6;\n    }\n  }\n}\n\nfunction createChargeTelegraph(cfg: any) {\n  const scene = getScene();\n\n  chargeTelegraphGroup = new THREE.Group();\n  chargeTelegraphGroup.position.set(playerPos.x, 0.05, playerPos.z);\n  chargeTelegraphGroup.rotation.y = chargeAimAngle;\n\n  // Fill plane (unit plane, scaled each frame)\n  const fillGeo = new THREE.PlaneGeometry(1, 1);\n  fillGeo.rotateX(-Math.PI / 2);\n  const fillMat = new THREE.MeshBasicMaterial({\n    color: cfg.color,\n    transparent: true,\n    opacity: cfg.telegraphOpacity,\n    side: THREE.DoubleSide,\n    depthWrite: false,\n  });\n  chargeFillMesh = new THREE.Mesh(fillGeo, fillMat);\n  // Position fill to start from player (offset by half minLength)\n  const halfLen = cfg.minLength / 2;\n  chargeFillMesh.scale.set(cfg.width, 1, cfg.minLength);\n  chargeFillMesh.position.set(0, 0, halfLen);\n  chargeTelegraphGroup.add(chargeFillMesh);\n\n  // Border \u2014 edges of a unit-sized plane, scaled each frame\n  const basePlane = new THREE.PlaneGeometry(1, 1);\n  const borderGeo = new THREE.EdgesGeometry(basePlane);\n  borderGeo.rotateX(-Math.PI / 2);\n  const borderMat = new THREE.LineBasicMaterial({\n    color: cfg.color,\n    transparent: true,\n    opacity: 0.8,\n    depthWrite: false,\n  });\n  chargeBorderMesh = new THREE.LineSegments(borderGeo, borderMat);\n  chargeBorderGeo = borderGeo;\n  chargeBorderMesh.scale.set(cfg.width, 1, cfg.minLength);\n  chargeBorderMesh.position.set(0, 0, halfLen);\n  chargeTelegraphGroup.add(chargeBorderMesh);\n\n  scene.add(chargeTelegraphGroup);\n}\n\nfunction updateCharge(inputState: any, dt: number, gameState: any) {\n  const cfg = ABILITIES.ultimate;\n  chargeTimer += dt * 1000;\n  const chargeT = Math.min(chargeTimer / cfg.chargeTimeMs, 1);\n  gameState.abilities.ultimate.chargeT = chargeT;\n\n  // Update aim angle from cursor\n  const dx = inputState.aimWorldPos.x - playerPos.x;\n  const dz = inputState.aimWorldPos.z - playerPos.z;\n  if (dx * dx + dz * dz > 0.01) {\n    chargeAimAngle = Math.atan2(dx, dz);\n  }\n\n  // Calculate current rect length\n  const currentLength = cfg.minLength + (cfg.maxLength - cfg.minLength) * chargeT;\n\n  // Update telegraph position and rotation\n  if (chargeTelegraphGroup) {\n    chargeTelegraphGroup.position.set(playerPos.x, 0.05, playerPos.z);\n    chargeTelegraphGroup.rotation.y = chargeAimAngle;\n\n    // Offset fill and border so the rect starts at the player and extends forward\n    const halfLen = currentLength / 2;\n\n    // Scale fill (unit plane scaled to desired size)\n    chargeFillMesh.scale.set(cfg.width, 1, currentLength);\n    chargeFillMesh.position.set(0, 0, halfLen);\n\n    // Scale border (unit-sized EdgesGeometry, scale to desired size)\n    chargeBorderMesh.scale.set(cfg.width, 1, currentLength);\n    chargeBorderMesh.position.set(0, 0, halfLen);\n\n    // Pulse border opacity\n    const pulse = 0.6 + 0.3 * Math.sin(performance.now() * 0.008);\n    chargeBorderMesh.material.opacity = pulse;\n\n    // Fill gets brighter as charge increases\n    chargeFillMesh.material.opacity = cfg.telegraphOpacity + chargeT * 0.2;\n  }\n\n  // Player glow intensifies with charge (skip for origin profile)\n  if (getActiveProfile() !== 'origin') {\n    for (const mat of rig.materials) {\n      mat.emissiveIntensity = 0.6 + chargeT * 0.4;\n    }\n  }\n\n  // Auto-fire at max charge OR release key (100ms grace period prevents instant-fire)\n  if (chargeT >= 1 || (chargeTimer > 100 && !inputState.ultimateHeld)) {\n    fireChargePush(chargeT, gameState);\n  }\n}\n\nfunction fireChargePush(chargeT: number, gameState: any) {\n  const cfg = ABILITIES.ultimate;\n  const currentLength = cfg.minLength + (cfg.maxLength - cfg.minLength) * chargeT;\n  const force = cfg.minKnockback + (cfg.maxKnockback - cfg.minKnockback) * chargeT;\n\n  // Rectangle center = player position + half length toward cursor\n  // chargeAimAngle = atan2(dx, dz), so sin(angle) = dx/len, cos(angle) = dz/len -> toward cursor\n  const halfLen = currentLength / 2;\n  const dirX = Math.sin(chargeAimAngle);\n  const dirZ = Math.cos(chargeAimAngle);\n  const centerX = playerPos.x + dirX * halfLen;\n  const centerZ = playerPos.z + dirZ * halfLen;\n\n  // Emit push event for physics\n  pushEvent = {\n    x: centerX,\n    z: centerZ,\n    width: cfg.width,\n    length: currentLength,\n    rotation: chargeAimAngle,\n    force: force,\n    dirX: dirX,\n    dirZ: dirZ,\n  };\n\n  // Clean up telegraph\n  removeChargeTelegraph();\n\n  // Reset charge state\n  isCharging = false;\n  gameState.abilities.ultimate.charging = false;\n  gameState.abilities.ultimate.chargeT = 0;\n  gameState.abilities.ultimate.cooldownRemaining = cfg.cooldown;\n\n  // Restore player visuals\n  restoreDefaultEmissive();\n\n  // Screen shake scales with charge\n  screenShake(2 + chargeT * 3, 120);\n\n  emit({ type: 'chargeFired', chargeT, direction: { x: dirX, z: dirZ }, position: { x: playerPos.x, z: playerPos.z } });\n}\n\nfunction removeChargeTelegraph() {\n  if (chargeTelegraphGroup) {\n    const scene = getScene();\n    // Dispose materials and geometries\n    if (chargeFillMesh) {\n      chargeFillMesh.material.dispose();\n      chargeFillMesh.geometry.dispose();\n    }\n    if (chargeBorderMesh) {\n      chargeBorderMesh.material.dispose();\n      if (chargeBorderGeo) chargeBorderGeo.dispose();\n    }\n    scene.remove(chargeTelegraphGroup);\n    chargeTelegraphGroup = null;\n    chargeFillMesh = null;\n    chargeBorderMesh = null;\n    chargeBorderGeo = null;\n  }\n}\n\n// === MELEE PUBLIC API ===\nexport function isMeleeSwinging() { return meleeSwinging; }\nexport function getMeleeSwingDir() { return meleeSwingDir; }\nexport function getMeleeHitEnemies() { return meleeHitEnemies; }\n\n// === PUBLIC API ===\nexport function getPlayerPos() { return playerPos; }\nexport function getPlayerGroup() { return playerGroup; }\nexport function isPlayerInvincible() { return isInvincible; }\nexport function isPlayerDashing() { return isDashing; }\nexport function getIsPlayerAirborne() { return isPlayerAirborne; }\nexport function getPlayerVelY() { return playerVelY; }\nexport function getLaunchCooldownTimer() { return launchCooldownTimer; }\nexport function consumePushEvent() {\n  const evt = pushEvent;\n  pushEvent = null;\n  return evt;\n}\n\nexport function resetPlayer() {\n  playerPos.set(0, 0, 0);\n  playerGroup.position.set(0, 0, 0);\n  playerGroup.rotation.y = 0;\n  isDashing = false;\n  isInvincible = false;\n  endLagTimer = 0;\n  meleeSwinging = false;\n  meleeCooldownTimer = 0;\n  meleeSwingTimer = 0;\n  meleeHitEnemies.clear();\n  isCharging = false;\n  chargeTimer = 0;\n  pushEvent = null;\n  playerVelY = 0;\n  isPlayerAirborne = false;\n  landingLagTimer = 0;\n  actionLockoutTimer = 0;\n  launchCooldownTimer = 0;\n  launchWindupTimer = 0;\n  launchWindupTarget = null;\n  isSlamming = false;\n  clearLaunchIndicator();\n  resetDunk();\n  resetFloatSelector();\n  resetSpike();\n  clearPlayerTags();\n  lastFireTime = 0;\n  removeChargeTelegraph();\n  restoreDefaultEmissive();\n  resetAnimatorState(animState);\n\n  // Clean up afterimages\n  const scene = getScene();\n  for (const ai of afterimages) {\n    scene.remove(ai.mesh);\n  }\n  afterimages.length = 0;\n}\n\nexport function setPlayerPosition(x: number, z: number) {\n  playerPos.set(x, 0, z);\n  playerGroup.position.set(x, 0, z);\n}\n", "import { screenToWorld } from './renderer';\nimport { getPlayerPos } from '../entities/player';\nimport { getActiveEnemy } from './aerialVerbs';\n\nconst keys: Record<string, boolean> = {};\n\nconst inputState = {\n  moveX: 0,\n  moveZ: 0,\n  aimWorldPos: { x: 0, y: 0, z: 0 },\n  mouseNDC: { x: 0, y: 0 },\n  dash: false,\n  attack: false,\n  attackHeld: false,       // continuous: true while LMB is down\n  ultimate: false,\n  ultimateHeld: false,\n  interact: false,\n  bulletTime: false,\n  bendMode: false,\n  jump: false,\n  launch: false,\n  chargeStarted: false,\n};\n\n// Isometric basis vectors (from prototype)\n// Camera faces along (-1, -1, -1)\n// Screen-right \u2192 world (1, 0, -1) normalized\n// Screen-up \u2192 world (-1, 0, -1) normalized\nconst INV_SQRT2 = 1 / Math.SQRT2;\nconst ISO_RIGHT_X = INV_SQRT2;\nconst ISO_RIGHT_Z = -INV_SQRT2;\nconst ISO_UP_X = -INV_SQRT2;\nconst ISO_UP_Z = -INV_SQRT2;\n\n// Gamepad state\nconst DEADZONE = 0.15;\nlet gamepadIndex = -1;\nlet gamepadAimActive = false;   // true while right stick is deflected beyond deadzone\nlet prevGamepadButtons: Record<string, boolean> = {};    // for edge-triggered button detection\n\n// Track input source \u2014 gamepad/touch aim overrides mouse aim when active\nlet usingGamepad = false;\n\n// Touch joystick state (nipplejs)\nlet touchMoveX = 0, touchMoveY = 0;  // screen-space from left stick\nlet touchAimX = 0, touchAimY = 0;    // screen-space from right stick\nlet touchAimActive = false;\nlet touchActive = false;             // true when any touch joystick is in use\n\nlet _checkMouseHold: () => void = () => {};\n\nexport function initInput() {\n  window.addEventListener('keydown', (e) => {\n    if (e.repeat) return;\n    keys[e.code] = true;\n    usingGamepad = false;\n\n    // Edge-triggered ability inputs\n    if (e.code === 'Space') { inputState.jump = true; e.preventDefault(); }\n    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') inputState.dash = true;\n    if (e.code === 'KeyE') { inputState.launch = true; inputState.ultimate = true; }\n    if (e.code === 'KeyF' || e.code === 'Enter') inputState.interact = true;\n    if (e.code === 'KeyQ') { inputState.bulletTime = true; inputState.bendMode = true; }\n  });\n\n  window.addEventListener('keyup', (e) => {\n    keys[e.code] = false;\n  });\n\n  window.addEventListener('mousemove', (e) => {\n    inputState.mouseNDC.x = (e.clientX / window.innerWidth) * 2 - 1;\n    inputState.mouseNDC.y = -(e.clientY / window.innerHeight) * 2 + 1;\n    usingGamepad = false;\n  });\n\n  let mouseDownTime = 0;\n  let mouseIsDown = false;\n  const HOLD_THRESHOLD = 200; // ms \u2014 LMB hold longer than this triggers force push charge\n\n  window.addEventListener('mousedown', (e) => {\n    if (e.button === 0) { // left click\n      inputState.attack = true;\n      inputState.attackHeld = true;\n      mouseDownTime = performance.now();\n      mouseIsDown = true;\n      usingGamepad = false;\n    }\n  });\n\n  window.addEventListener('mouseup', (e) => {\n    if (e.button === 0) {\n      mouseIsDown = false;\n      inputState.attackHeld = false;\n    }\n  });\n\n  // Check LMB hold each frame (called from updateInput)\n  _checkMouseHold = () => {\n    if (mouseIsDown && (performance.now() - mouseDownTime > HOLD_THRESHOLD)) {\n      inputState.chargeStarted = true;\n    }\n  };\n\n  // Gamepad connect/disconnect\n  window.addEventListener('gamepadconnected', (e: GamepadEvent) => {\n    console.log(`[input] Gamepad connected: ${e.gamepad.id}`);\n    gamepadIndex = e.gamepad.index;\n  });\n  window.addEventListener('gamepaddisconnected', (e: GamepadEvent) => {\n    console.log(`[input] Gamepad disconnected: ${e.gamepad.id}`);\n    if (e.gamepad.index === gamepadIndex) gamepadIndex = -1;\n  });\n\n  // Touch joysticks (nipplejs) \u2014 only on touch-capable devices\n  initTouchJoysticks();\n}\n\nfunction applyDeadzone(value: number) {\n  if (Math.abs(value) < DEADZONE) return 0;\n  // Remap from [deadzone..1] to [0..1] for smooth ramp\n  const sign = value > 0 ? 1 : -1;\n  return sign * (Math.abs(value) - DEADZONE) / (1 - DEADZONE);\n}\n\nfunction initTouchJoysticks() {\n  // Only initialize if nipplejs is loaded and we have touch capability\n  if (typeof nipplejs === 'undefined') return;\n  const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n  if (!hasTouch) return;\n\n  const zoneLeft = document.getElementById('zone-left');\n  const zoneRight = document.getElementById('zone-right');\n  if (!zoneLeft || !zoneRight) return;\n\n  // Ensure zones are visible on touch devices\n  zoneLeft.style.display = 'block';\n  zoneRight.style.display = 'block';\n\n  console.log('[input] Touch joysticks initialized');\n\n  // Left joystick \u2014 movement\n  const leftJoystick = nipplejs.create({\n    zone: zoneLeft,\n    mode: 'dynamic',\n    position: { left: '50%', top: '50%' },\n    color: 'rgba(68, 204, 136, 0.35)',\n    size: 120,\n    restOpacity: 0.5,\n  });\n\n  leftJoystick.on('move', (evt: any, data: any) => {\n    const force = Math.min(data.force, 1.5) / 1.5;\n    const angle = data.angle.radian;\n    touchMoveX = Math.cos(angle) * force;   // screen-right\n    touchMoveY = Math.sin(angle) * force;   // screen-up\n    touchActive = true;\n  });\n  leftJoystick.on('end', () => {\n    touchMoveX = 0;\n    touchMoveY = 0;\n  });\n\n  // Right joystick \u2014 aim + auto-fire\n  const rightJoystick = nipplejs.create({\n    zone: zoneRight,\n    mode: 'dynamic',\n    position: { left: '50%', top: '50%' },\n    color: 'rgba(255, 102, 68, 0.35)',\n    size: 120,\n    restOpacity: 0.5,\n  });\n\n  rightJoystick.on('move', (evt: any, data: any) => {\n    const force = Math.min(data.force, 1.5) / 1.5;\n    const angle = data.angle.radian;\n    touchAimX = Math.cos(angle) * force;\n    touchAimY = Math.sin(angle) * force;\n    touchAimActive = true;\n    touchActive = true;\n  });\n  rightJoystick.on('end', () => {\n    touchAimX = 0;\n    touchAimY = 0;\n    touchAimActive = false;\n  });\n}\n\nfunction pollTouchJoysticks() {\n  if (!touchActive) return;\n\n  // --- Left stick: movement ---\n  if (Math.abs(touchMoveX) > 0.01 || Math.abs(touchMoveY) > 0.01) {\n    // Map screen-space joystick to isometric world-space (same as WASD/gamepad)\n    // touchMoveX = screen right, touchMoveY = screen up\n    const tMoveX = touchMoveX * ISO_RIGHT_X + touchMoveY * ISO_UP_X;\n    const tMoveZ = touchMoveX * ISO_RIGHT_Z + touchMoveY * ISO_UP_Z;\n\n    // Touch overrides keyboard if keyboard isn't active\n    const kbActive = Math.abs(inputState.moveX) > 0.01 || Math.abs(inputState.moveZ) > 0.01;\n    if (!kbActive) {\n      inputState.moveX = tMoveX;\n      inputState.moveZ = tMoveZ;\n      const len = Math.sqrt(inputState.moveX * inputState.moveX + inputState.moveZ * inputState.moveZ);\n      if (len > 1) {\n        inputState.moveX /= len;\n        inputState.moveZ /= len;\n      }\n    }\n  }\n\n  // --- Right stick: aim ---\n  if (touchAimActive) {\n    const aimDirX = touchAimX * ISO_RIGHT_X + touchAimY * ISO_UP_X;\n    const aimDirZ = touchAimX * ISO_RIGHT_Z + touchAimY * ISO_UP_Z;\n\n    const pp = getPlayerPos();\n    const aimDist = 10;\n    inputState.aimWorldPos.x = pp.x + aimDirX * aimDist;\n    inputState.aimWorldPos.y = 0;\n    inputState.aimWorldPos.z = pp.z + aimDirZ * aimDist;\n  }\n}\n\nfunction pollGamepad() {\n  if (gamepadIndex < 0) return;\n  const gamepads = navigator.getGamepads();\n  const gp = gamepads[gamepadIndex];\n  if (!gp) return;\n\n  usingGamepad = true;\n\n  // --- Left stick: movement (axes 0, 1) ---\n  const lx = applyDeadzone(gp.axes[0] || 0);\n  const ly = applyDeadzone(gp.axes[1] || 0); // Y axis inverted (up = negative)\n\n  // Map screen-space stick to isometric world-space (same as WASD)\n  // lx = screen right, -ly = screen up (stick Y is inverted)\n  const gpMoveX = lx * ISO_RIGHT_X + (-ly) * ISO_UP_X;\n  const gpMoveZ = lx * ISO_RIGHT_Z + (-ly) * ISO_UP_Z;\n\n  // Blend with keyboard: if keyboard has input, keyboard wins; otherwise gamepad\n  const kbActive = Math.abs(inputState.moveX) > 0.01 || Math.abs(inputState.moveZ) > 0.01;\n  if (!kbActive && (Math.abs(gpMoveX) > 0.01 || Math.abs(gpMoveZ) > 0.01)) {\n    inputState.moveX = gpMoveX;\n    inputState.moveZ = gpMoveZ;\n    // Normalize if > 1\n    const len = Math.sqrt(inputState.moveX * inputState.moveX + inputState.moveZ * inputState.moveZ);\n    if (len > 1) {\n      inputState.moveX /= len;\n      inputState.moveZ /= len;\n    }\n  }\n\n  // --- Right stick: aim (axes 2, 3) ---\n  const rx = applyDeadzone(gp.axes[2] || 0);\n  const ry = applyDeadzone(gp.axes[3] || 0);\n\n  gamepadAimActive = (Math.abs(rx) > 0.01 || Math.abs(ry) > 0.01);\n\n  if (gamepadAimActive) {\n    // Convert stick direction to isometric world direction\n    const aimDirX = rx * ISO_RIGHT_X + (-ry) * ISO_UP_X;\n    const aimDirZ = rx * ISO_RIGHT_Z + (-ry) * ISO_UP_Z;\n\n    // Place aim target at player + direction * distance\n    const pp = getPlayerPos();\n    const aimDist = 10; // arbitrary distance so atan2 calculation works\n    inputState.aimWorldPos.x = pp.x + aimDirX * aimDist;\n    inputState.aimWorldPos.y = 0;\n    inputState.aimWorldPos.z = pp.z + aimDirZ * aimDist;\n  }\n\n  // --- Buttons (edge-triggered) ---\n  // Standard gamepad mapping:\n  // 0 = A (South), 1 = B (East), 2 = X (West), 3 = Y (North)\n  // 4 = LB, 5 = RB, 6 = LT, 7 = RT\n  const buttons = gp.buttons;\n\n  // Dash: A button (0) or LB (4)\n  const dashBtn = (buttons[0] && buttons[0].pressed) || (buttons[4] && buttons[4].pressed);\n  if (dashBtn && !prevGamepadButtons.dash) inputState.dash = true;\n  prevGamepadButtons.dash = !!dashBtn;\n\n  // Ultimate: RB (5) or RT (7)\n  const ultBtn = (buttons[5] && buttons[5].pressed) || (buttons[7] && buttons[7].pressed);\n  if (ultBtn && !prevGamepadButtons.ult) inputState.ultimate = true;\n  prevGamepadButtons.ult = !!ultBtn;\n\n  // Interact: Y button (3) \u2014 door interaction\n  const interactBtn = buttons[3] && buttons[3].pressed;\n  if (interactBtn && !prevGamepadButtons.interact) inputState.interact = true;\n  prevGamepadButtons.interact = !!interactBtn;\n\n  // Bullet Time: LT (6)\n  const btBtn = buttons[6] && buttons[6].pressed;\n  if (btBtn && !prevGamepadButtons.bulletTime) inputState.bulletTime = true;\n  prevGamepadButtons.bulletTime = !!btBtn;\n\n  // Ultimate held (for charge release detection)\n  if (ultBtn) inputState.ultimateHeld = true;\n}\n\nexport function updateInput() {\n  // WASD \u2192 raw screen-space directions\n  let rawX = 0, rawY = 0;\n  if (keys['KeyD'] || keys['ArrowRight']) rawX += 1;\n  if (keys['KeyA'] || keys['ArrowLeft'])  rawX -= 1;\n  if (keys['KeyW'] || keys['ArrowUp'])    rawY += 1;\n  if (keys['KeyS'] || keys['ArrowDown'])  rawY -= 1;\n\n  // Map screen-space to isometric world-space\n  inputState.moveX = rawX * ISO_RIGHT_X + rawY * ISO_UP_X;\n  inputState.moveZ = rawX * ISO_RIGHT_Z + rawY * ISO_UP_Z;\n\n  // Normalize diagonal movement\n  const len = Math.sqrt(inputState.moveX * inputState.moveX + inputState.moveZ * inputState.moveZ);\n  if (len > 1) {\n    inputState.moveX /= len;\n    inputState.moveZ /= len;\n  }\n\n  // Check LMB hold for force push charge\n  _checkMouseHold();\n\n  // Continuous held state for charge abilities\n  // Merge keyboard + touch button hold + LMB hold (gamepad sets it in pollGamepad)\n  inputState.ultimateHeld = !!keys['KeyE'] || _touchUltHeld || inputState.chargeStarted;\n\n  // Mouse \u2192 world position on y=0 plane (only if not overridden by gamepad/touch/ability drag)\n  if ((!usingGamepad || !gamepadAimActive) && !touchAimActive && !_abilityAimActive) {\n    const worldPos = screenToWorld(inputState.mouseNDC.x, inputState.mouseNDC.y);\n    inputState.aimWorldPos.x = worldPos.x;\n    inputState.aimWorldPos.y = worldPos.y;\n    inputState.aimWorldPos.z = worldPos.z;\n  }\n\n  // Poll gamepad (blends with keyboard/mouse above)\n  pollGamepad();\n\n  // Poll touch joysticks (blends with keyboard/mouse/gamepad above)\n  pollTouchJoysticks();\n}\n\nexport function consumeInput() {\n  inputState.dash = false;\n  inputState.attack = false;\n  inputState.ultimate = false;\n  inputState.interact = false;\n  inputState.bulletTime = false;\n  inputState.bendMode = false;\n  inputState.jump = false;\n  inputState.launch = false;\n  inputState.chargeStarted = false;\n}\n\nexport function getInputState() { return inputState; }\n\n// Expose for touch-screen ability buttons\nlet _touchUltHeld = false;\nexport function triggerDash() { inputState.dash = true; }\nexport function triggerUltimate() { inputState.ultimate = true; }\nexport function setUltimateHeld(held: boolean) { _touchUltHeld = held; }\nexport function triggerAttack() { inputState.attack = true; }\nexport function triggerJump() { inputState.jump = true; }\nexport function triggerLaunch() { inputState.launch = true; }\nexport function setAttackHeld(held: boolean) { inputState.attackHeld = held; }\n\n// Cancel flag \u2014 consumed by game loop to cancel active verb / charge\nlet _cancelRequested = false;\nexport function triggerCancel() { _cancelRequested = true; }\nexport function consumeCancel(): boolean {\n  if (_cancelRequested) { _cancelRequested = false; return true; }\n  return false;\n}\n\n// Drag-to-aim: set aim world position from screen-space drag direction\nlet _abilityAimActive = false; // true while a mobile button drag is overriding aim\nexport function setAimFromScreenDrag(screenX: number, screenY: number) {\n  _abilityAimActive = true;\n  const aimDirX = screenX * ISO_RIGHT_X + screenY * ISO_UP_X;\n  const aimDirZ = screenX * ISO_RIGHT_Z + screenY * ISO_UP_Z;\n\n  const pp = getPlayerPos();\n  const aimDist = 10;\n  inputState.aimWorldPos.x = pp.x + aimDirX * aimDist;\n  inputState.aimWorldPos.y = 0;\n  inputState.aimWorldPos.z = pp.z + aimDirZ * aimDist;\n}\n\n// Override movement direction for dash drag-to-aim\nlet _abilityDirOverride: { x: number; z: number } | null = null;\nexport function setAbilityDirOverride(x: number, z: number) { _abilityDirOverride = { x, z }; }\nexport function clearAbilityDirOverride() { _abilityDirOverride = null; _abilityAimActive = false; }\nexport function getAbilityDirOverride() { return _abilityDirOverride; }\n\n/**\n * Mobile auto-aim: if on a touch device and the right joystick / ability drag\n * is NOT active, aim at the closest enemy automatically.\n * Called from game loop after updateInput(), before updatePlayer().\n */\nexport function autoAimClosestEnemy(enemies: any[]) {\n  // Only on touch devices, and only when no manual aim is active\n  if (!touchActive) return;\n  if (touchAimActive || _abilityAimActive) return;\n\n  if (!enemies || enemies.length === 0) return;\n\n  const pp = getPlayerPos();\n  const grabbed = getActiveEnemy();\n  let closest: any = null;\n  let closestDist = Infinity;\n\n  for (let i = 0; i < enemies.length; i++) {\n    const e = enemies[i];\n    if (e.fellInPit || e.health <= 0) continue;\n    // Skip the currently grabbed enemy \u2014 it's right next to the player\n    // and would cause spike to aim at itself instead of a ground target\n    if (e === grabbed) continue;\n    const dx = e.pos.x - pp.x;\n    const dz = e.pos.z - pp.z;\n    const dist = dx * dx + dz * dz; // squared distance is fine for comparison\n    if (dist < closestDist) {\n      closestDist = dist;\n      closest = e;\n    }\n  }\n\n  if (closest) {\n    inputState.aimWorldPos.x = closest.pos.x;\n    inputState.aimWorldPos.y = 0;\n    inputState.aimWorldPos.z = closest.pos.z;\n  }\n}\n", "// Room definitions for the Portfolio Demo\n// Each room showcases a different stage of design exploration\n// Rooms are rectangular (longer on Z) \u2014 player enters from +Z (bottom-left in iso),\n// progresses toward -Z (top-right in iso), exits through a door at the far end\n\nimport { Obstacle, Pit, SpawnPack, SpawnPackEnemy, RoomSpawnBudget, PlayerProfile, PhysicsObjectPlacement, PressurePlatePlacement } from '../types/index';\n\nexport type HighlightTarget = 'pits' | 'obstacles' | 'platforms';\n\nexport interface RoomHighlight {\n  target: HighlightTarget;\n  color?: number;      // override highlight color (default per target type)\n  delay?: number;      // ms after room load (default 800)\n  duration?: number;   // ms for the pulse (default 2000)\n}\n\nexport interface RoomDefinition {\n  name: string;\n  profile: PlayerProfile;\n  sandboxMode: boolean;\n  commentary: string;\n  intro?: string;\n  arenaHalfX: number;\n  arenaHalfZ: number;\n  obstacles: Obstacle[];\n  pits: Pit[];\n  spawnBudget: RoomSpawnBudget;\n  playerStart: { x: number; z: number };\n  enableWallSlamDamage?: boolean;\n  enableEnemyCollisionDamage?: boolean;\n  highlights?: RoomHighlight[];\n  isRestRoom?: boolean;\n  isVictoryRoom?: boolean;\n  heightZones?: Array<{ x: number; z: number; w: number; d: number; y: number }>;\n  frustumSize?: number;\n  physicsObjects?: PhysicsObjectPlacement[];\n  pressurePlates?: PressurePlatePlacement[];\n  lockedBends?: string[];\n}\n\n// \u2500\u2500\u2500 Helper: build packs of N enemies \u2500\u2500\u2500\n\nfunction pack(enemies: SpawnPackEnemy[], zone: SpawnPack['spawnZone'] = 'ahead'): SpawnPack {\n  return { enemies, spawnZone: zone };\n}\n\nfunction goblins(n: number): SpawnPackEnemy[] {\n  return Array.from({ length: n }, () => ({ type: 'goblin' }));\n}\n\n// \u2500\u2500\u2500 Room Definitions \u2500\u2500\u2500\n\nexport const ROOMS: RoomDefinition[] = [\n\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  // Room 1: \"The Origin\" \u2014 Feb 7 prototype, auto-fire projectiles, cylinder+sphere model\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  {\n    name: 'Origin \u2014 Feb 7th',\n    profile: 'origin',\n    sandboxMode: true,\n    commentary: \"Where I started: auto-fire, simple shapes, simple movement.\",\n    intro: \"This was the first hackathon build \u2014 Auto-fire projectiles, a cylinder-and-sphere player model, WASD movement. It's simplified to one enemy type here but there are more.\",\n    arenaHalfX: 9,\n    arenaHalfZ: 16,\n    obstacles: [\n      { x: -3, z: 3, w: 1.5, h: 2, d: 1.5 },\n      { x: 4, z: -4, w: 1.5, h: 2, d: 1.5 },\n    ],\n    pits: [],\n    spawnBudget: {\n      maxConcurrent: 3,\n      telegraphDuration: 1500,\n      packs: [\n        pack(goblins(2), 'ahead'),\n        pack(goblins(2), 'ahead'),\n        pack(goblins(2), 'sides'),\n      ],\n    },\n    playerStart: { x: 0, z: 12 },\n  },\n\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  // Room 2: \"The Foundation\" \u2014 goblins only, teach melee + dash + pit kills\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  {\n    name: 'Foundations \u2014 Feb 18',\n    profile: 'base',\n    sandboxMode: true,\n    commentary: \"How does adding displacement affect combat? What about hazards?\",\n    intro: \"Activate force-push with E or press-and-hold LMB. Dash past goblins and push them into pits.\",\n    arenaHalfX: 10,\n    arenaHalfZ: 20,\n    enableWallSlamDamage: false,\n    enableEnemyCollisionDamage: false,\n    highlights: [{ target: 'pits' }],\n    obstacles: [\n      { x: -4, z: 5, w: 1.5, h: 2, d: 1.5 },\n      { x: 4, z: -5, w: 1.5, h: 2, d: 1.5 },\n    ],\n    pits: [\n      { x: 6, z: -8, w: 3, d: 3 },\n      { x: -6, z: -2, w: 3, d: 3 },\n      { x: 3, z: 6, w: 3, d: 2.5 },\n    ],\n    spawnBudget: {\n      maxConcurrent: 4,\n      telegraphDuration: 1500,\n      packs: [\n        pack(goblins(2), 'ahead'),\n        pack(goblins(2), 'ahead'),\n        pack(goblins(3), 'sides'),\n      ],\n    },\n    playerStart: { x: 0, z: 16 },\n  },\n\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  // Room 2: \"Physics Playground\" \u2014 walls + pits, force push as spatial tool\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  {\n    name: 'Add More Physics \u2014 Feb 18',\n    profile: 'base',\n    sandboxMode: true,\n    commentary: \"Can we extend physics-first combat further?\",\n    intro: \"Can we extend physics more and lean into the isometric camera. Knocking enemies into each other and terrain is satisfying. Players have more options in second-to-second gameplay.\",\n    enableWallSlamDamage: true,\n    enableEnemyCollisionDamage: true,\n    arenaHalfX: 11,\n    arenaHalfZ: 22,\n    obstacles: [\n      { x: -6, z: 0, w: 2, h: 2, d: 2 },\n      { x: 6, z: 0, w: 2, h: 2, d: 2 },\n      { x: 0, z: -10, w: 4, h: 1.5, d: 1 },\n      { x: -3, z: 10, w: 1.5, h: 2, d: 1.5 },\n    ],\n    pits: [\n      { x: -8, z: -8, w: 3, d: 4 },\n      { x: 8, z: 5, w: 3, d: 3 },\n      { x: 0, z: -16, w: 4, d: 3 },\n    ],\n    spawnBudget: {\n      maxConcurrent: 5,\n      telegraphDuration: 1500,\n      packs: [\n        pack(goblins(2), 'ahead'),\n        pack(goblins(2), 'far'),\n        pack(goblins(3), 'ahead'),\n        pack(goblins(3), 'sides'),\n      ],\n    },\n    playerStart: { x: 0, z: 18 },\n  },\n\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  // Room 4: \"The Shadows\" \u2014 patrol maze, vision cones, detection puzzle\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  {\n    name: 'Tension & Sneak \u2014 Feb 19',\n    profile: 'assassin' as PlayerProfile,\n    sandboxMode: true,\n    commentary: \"How do we add tension? How can we slow the game down?\",\n    intro: \"What does an assassination or heist variation of the sandbox look like? How can we make the experience accessible? Bullet-time automatically activates when you get spotted or use Q to trigger it manually.\",\n    arenaHalfX: 14,\n    arenaHalfZ: 14,\n    obstacles: [\n      // Maze walls \u2014 creating lanes\n      { x: -5, z: 5, w: 8, h: 2, d: 1 },     // upper-left horizontal wall\n      { x: 5, z: -1, w: 8, h: 2, d: 1 },      // center-right horizontal wall\n      { x: -5, z: -7, w: 8, h: 2, d: 1 },     // lower-left horizontal wall\n      // Cover pillars at intersections\n      { x: 0, z: 8, w: 1.5, h: 2, d: 1.5 },   // top gap pillar\n      { x: -1, z: -4, w: 1.5, h: 2, d: 1.5 }, // center gap pillar\n    ],\n    pits: [\n      // Opportunistic push spots at corridor intersections\n      { x: 8, z: 5, w: 3, d: 3 },     // right side, near upper wall end\n      { x: -8, z: -1, w: 3, d: 3 },    // left side, center height\n      { x: 4, z: -5, w: 3, d: 2.5 },   // lower-right, between center and lower walls\n    ],\n    spawnBudget: {\n      maxConcurrent: 5,\n      telegraphDuration: 1500,\n      packs: [\n        // Pit 1 (x:8, z:5) \u2014 right side, 2 goblins on opposite corners\n        {\n          enemies: [\n            { type: 'goblin', fixedPos: { x: 11, z: 3 }, patrolWaypoints: [{ x: 11, z: 3 }, { x: 11, z: 7 }, { x: 5, z: 7 }, { x: 5, z: 3 }] },\n            { type: 'goblin', fixedPos: { x: 5, z: 7 }, patrolWaypoints: [{ x: 5, z: 7 }, { x: 5, z: 3 }, { x: 11, z: 3 }, { x: 11, z: 7 }] },\n          ],\n          spawnZone: 'ahead' as const,\n        },\n        // Pit 2 (x:-8, z:-1) \u2014 left side, 2 goblins on opposite corners\n        {\n          enemies: [\n            { type: 'goblin', fixedPos: { x: -5, z: -3 }, patrolWaypoints: [{ x: -5, z: -3 }, { x: -5, z: 1 }, { x: -11, z: 1 }, { x: -11, z: -3 }] },\n            { type: 'goblin', fixedPos: { x: -11, z: 1 }, patrolWaypoints: [{ x: -11, z: 1 }, { x: -11, z: -3 }, { x: -5, z: -3 }, { x: -5, z: 1 }] },\n          ],\n          spawnZone: 'ahead' as const,\n        },\n        // Pit 3 (x:4, z:-5) \u2014 lower center-right, 1 goblin\n        {\n          enemies: [\n            { type: 'goblin', fixedPos: { x: 7, z: -3 }, patrolWaypoints: [{ x: 7, z: -3 }, { x: 7, z: -7 }, { x: 1, z: -7 }, { x: 1, z: -3 }] },\n          ],\n          spawnZone: 'ahead' as const,\n        },\n      ],\n    },\n    playerStart: { x: -10, z: 10 },\n    enableWallSlamDamage: false,\n    enableEnemyCollisionDamage: false,\n    highlights: [{ target: 'pits' }],\n  },\n\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  // Room 5: \"The Workshop\" \u2014 rule-bending (enlarge/shrink physics objects)\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  {\n    name: 'Puzzles & Magic \u2014 Feb 19',\n    profile: 'rule-bending' as PlayerProfile,\n    sandboxMode: true,\n    commentary: \"What does magic look like? Enlarge a rock, shrink a crate...\",\n    intro: \"What if you could bend the rules of the world? How can we incorporate magic in a way that supports the sandbox?\\n\\nBuilding off of Bullet-time, use Q to enlarge the floating rock. This room explores layering puzzle gameplay in the sandbox.\",\n    arenaHalfX: 14,\n    arenaHalfZ: 14,\n    obstacles: [\n      // Left wall segment \u2014 creates wall slam opportunities\n      { x: -8, z: 0, w: 1, h: 2, d: 10 },\n      // Right wall segment\n      { x: 8, z: -4, w: 1, h: 2, d: 7 },\n    ],\n    pits: [\n      { x: 8, z: 7, w: 3, d: 3 },       // right-back pit\n      { x: -8, z: -7, w: 3, d: 3 },      // left-front pit\n    ],\n    physicsObjects: [\n      // Rock: enlarge to reach pressure plate mass threshold (2.0 \u2192 4.0)\n      { meshType: 'rock' as const, material: 'stone' as const, x: 0, z: 0, mass: 2.0, health: Infinity, radius: 0.6, suspended: true, suspendHeight: 3.0 },\n      // Crate: blocks the door at -Z end, too heavy to push (mass 5.0), shrink to move aside\n      { meshType: 'crate' as const, material: 'wood' as const, x: 0, z: -12, mass: 5.0, health: 80, radius: 1.5 },\n    ],\n    pressurePlates: [\n      // Pressure plate: center of room, needs mass >= 3.5 (enlarged rock = 4.0)\n      { x: 0, z: 0, radius: 1.2, massThreshold: 3.5 },\n    ],\n    spawnBudget: {\n      maxConcurrent: 6,\n      telegraphDuration: 1500,\n      packs: [\n        // Goblin loitering under the suspended boulder \u2014 enlarge the rock to crush it\n        { enemies: [{ type: 'goblin', fixedPos: { x: 0, z: 0 }, patrolWaypoints: [{ x: 0.5, z: 0.5 }, { x: -0.5, z: 0.5 }, { x: -0.5, z: -0.5 }, { x: 0.5, z: -0.5 }] }], spawnZone: 'ahead' as const },\n        { enemies: [{ type: 'goblin' }, { type: 'goblin' }, { type: 'goblin' }], spawnZone: 'ahead' as const },\n      ],\n    },\n    playerStart: { x: 0, z: 11 },\n    enableWallSlamDamage: true,\n    enableEnemyCollisionDamage: true,\n    highlights: [\n      { target: 'pits', color: 0xff4444 },\n    ],\n    lockedBends: ['shrink'],\n  },\n\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  // Room 6: \"The Arena\" \u2014 vertical combat: jump, launch, dunk, spike\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  {\n    name: 'Physics Playground \u2014 Feb 19',\n    profile: 'vertical' as PlayerProfile,\n    sandboxMode: true,\n    commentary: \"What if combat had a real Z-axis? Jump, launch, spike, and dunk. What if terrain had more levels of height?\",\n    intro: \"What if we also leaned into the Z-axis of the game? Use the launch button to send enemies into the air! Tap to spike them volleyball. Press and hold to bullet-time dunk. What if terrain had more levels of height?\",\n    arenaHalfX: 12,\n    arenaHalfZ: 12,\n    obstacles: [],\n    pits: [],\n    heightZones: [\n      { x: -6, z: -6, w: 4, d: 4, y: 1.5 },\n      { x: 6, z: 6, w: 4, d: 4, y: 1.5 },\n    ],\n    spawnBudget: {\n      maxConcurrent: 10,\n      telegraphDuration: 1500,\n      packs: [\n        pack(goblins(4), 'ahead'),\n        pack(goblins(3), 'sides'),\n      ],\n    },\n    playerStart: { x: 0, z: 5 },\n    enableWallSlamDamage: true,\n    enableEnemyCollisionDamage: true,\n    frustumSize: 9.6,\n    highlights: [{ target: 'platforms', color: 0x4488ff }],\n  },\n];\n", "// Ground shadows \u2014 flat dark circles projected onto the ground below entities.\n// Critical for height readability with isometric camera.\n// Shadow stays on ground, shrinks/fades as entity rises.\n\nimport { getScene } from './renderer';\nimport { getPlayerPos, getPlayerGroup } from '../entities/player';\nimport { PHYSICS } from '../config/physics';\nimport { getGroundHeight } from '../config/terrain';\nimport type { GameState } from '../types/index';\n\nlet playerShadow: any = null;\nconst enemyShadows: Map<any, any> = new Map();\nlet shadowGeo: any = null;\nlet shadowMat: any = null;\n\nfunction getShadowGeo() {\n  if (!shadowGeo) {\n    shadowGeo = new THREE.CircleGeometry(1, 16);\n  }\n  return shadowGeo;\n}\n\nfunction getShadowMat() {\n  if (!shadowMat) {\n    shadowMat = new THREE.MeshBasicMaterial({\n      color: 0x000000,\n      transparent: true,\n      opacity: 0.3,\n      depthWrite: false,\n    });\n  }\n  return shadowMat;\n}\n\nfunction createShadowMesh(radius: number): any {\n  const mesh = new THREE.Mesh(getShadowGeo(), getShadowMat().clone());\n  mesh.rotation.x = -Math.PI / 2; // Lay flat on ground\n  mesh.scale.set(radius * 0.8, radius * 0.8, 1);\n  mesh.renderOrder = -1; // Render below everything\n  return mesh;\n}\n\nfunction updateShadowForEntity(shadow: any, posX: number, posZ: number, posY: number, baseRadius: number) {\n  const groundHeight = getGroundHeight(posX, posZ);\n  const altitude = posY - groundHeight;\n\n  shadow.position.x = posX;\n  shadow.position.z = posZ;\n  shadow.position.y = groundHeight + 0.01; // Slightly above ground\n\n  // Scale: shrinks with altitude, min 30%\n  const scale = Math.max(0.3, 1 - altitude * 0.1) * baseRadius * 0.8;\n  shadow.scale.set(scale, scale, 1);\n\n  // Opacity: fades with altitude, min 10%\n  shadow.material.opacity = Math.max(0.1, 0.3 - altitude * 0.03);\n\n  // Only visible when entity is above ground\n  shadow.visible = altitude > PHYSICS.groundEpsilon || posY > 0;\n}\n\nexport function initGroundShadows() {\n  const scene = getScene();\n\n  // Player shadow\n  playerShadow = createShadowMesh(0.35); // PLAYER.size.radius\n  scene.add(playerShadow);\n}\n\nexport function updateGroundShadows(gameState: GameState) {\n  const scene = getScene();\n\n  // Update player shadow\n  if (playerShadow) {\n    const pp = getPlayerPos();\n    updateShadowForEntity(playerShadow, pp.x, pp.z, pp.y, 0.35);\n  }\n\n  // Update enemy shadows \u2014 create on demand, remove when dead\n  const activeEnemies = new Set<any>();\n  for (const enemy of gameState.enemies) {\n    if (enemy.health <= 0 && !enemyShadows.has(enemy)) continue;\n    activeEnemies.add(enemy);\n\n    let shadow = enemyShadows.get(enemy);\n    if (!shadow) {\n      shadow = createShadowMesh(enemy.config.size.radius);\n      scene.add(shadow);\n      enemyShadows.set(enemy, shadow);\n    }\n\n    if (enemy.health <= 0 || (enemy as any).fellInPit) {\n      shadow.visible = false;\n      continue;\n    }\n\n    updateShadowForEntity(shadow, enemy.pos.x, enemy.pos.z, enemy.pos.y, enemy.config.size.radius);\n  }\n\n  // Clean up shadows for removed enemies\n  for (const [enemy, shadow] of enemyShadows) {\n    if (!activeEnemies.has(enemy)) {\n      scene.remove(shadow);\n      shadow.material.dispose();\n      enemyShadows.delete(enemy);\n    }\n  }\n}\n\nexport function cleanupGroundShadows() {\n  const scene = getScene();\n  if (playerShadow) {\n    scene.remove(playerShadow);\n    playerShadow.material.dispose();\n    playerShadow = null;\n  }\n  for (const [, shadow] of enemyShadows) {\n    scene.remove(shadow);\n    shadow.material.dispose();\n  }\n  enemyShadows.clear();\n}\n", "// Spawn pacing config \u2014 tunable at runtime via tuning panel\n\nexport const SPAWN_CONFIG = {\n  telegraphDuration: 1500,   // ms \u2014 how long spawn warnings show before enemies appear\n  spawnCooldown: 500,        // ms \u2014 minimum delay between consecutive pack dispatches\n  maxConcurrentMult: 1.0,    // multiplier on per-room maxConcurrent\n  spawnAheadMin: 8,          // minimum distance ahead of player to spawn enemies (Z units)\n  spawnAheadMax: 15,         // maximum distance ahead of player to spawn enemies (Z units)\n};\n", "// Pure math utilities for melee combat \u2014 no THREE.js dependency\n// Extracted for testability\n\n/**\n * Check if a target is within a melee arc.\n * @param playerX Player X position\n * @param playerZ Player Z position\n * @param swingAngle Player facing angle (radians, atan2 convention: atan2(-dx,-dz))\n * @param targetX Target X position\n * @param targetZ Target Z position\n * @param range Max hit distance\n * @param arc Total arc width in radians\n */\nexport function isInMeleeArc(\n  playerX: number, playerZ: number, swingAngle: number,\n  targetX: number, targetZ: number, range: number, arc: number\n): boolean {\n  const dx = targetX - playerX;\n  const dz = targetZ - playerZ;\n  const distSq = dx * dx + dz * dz;\n  if (distSq > range * range) return false;\n  if (distSq < 0.001) return true; // on top of player = always hit\n\n  const angleToTarget = Math.atan2(-dx, -dz);\n  let angleDiff = angleToTarget - swingAngle;\n  while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;\n  while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;\n  return Math.abs(angleDiff) <= arc / 2;\n}\n", "import { getPlayerPos, isPlayerInvincible, isPlayerDashing, consumePushEvent, isMeleeSwinging, getMeleeSwingDir, getMeleeHitEnemies } from '../entities/player';\nimport { getLaunchedEntry } from './aerialVerbs';\nimport { getPlayerProjectiles, getEnemyProjectiles, releaseProjectile } from '../entities/projectile';\nimport { stunEnemy } from '../entities/enemy';\nimport { getIceEffects } from '../entities/mortarProjectile';\nimport { triggerHitReaction } from '../entities/enemyRig';\nimport { emit } from './events';\nimport { getCurrentRoom } from './roomManager';\nimport { screenShake, getScene } from './renderer';\nimport { PLAYER, MELEE } from '../config/player';\nimport { PHYSICS } from '../config/physics';\nimport { getGroundHeight } from '../config/terrain';\nimport { isInMeleeArc } from './meleemath';\nimport { getCollisionBounds, getPitBounds } from '../config/arena';\nimport { spawnDamageNumber } from '../ui/damageNumbers';\nimport { applyAoeEffect, isInRotatedRect, createAoeRing } from './aoeTelegraph';\nimport { AABB, GameState, Enemy } from '../types/index';\nimport type { Group, CylinderGeometry, SphereGeometry, Mesh, MeshBasicMaterial, Material } from 'three';\n\n// Cache collision bounds (invalidated when arena layout changes)\nlet collisionBounds: AABB[] | null = null;\nlet pitBounds: AABB[] | null = null;\nlet movementBounds: AABB[] | null = null;\n\n// Invalidate cached bounds \u2014 called by level editor when obstacles/pits change\nexport function invalidateCollisionBounds(): void {\n  collisionBounds = null;\n  pitBounds = null;\n  movementBounds = null;\n}\n\n// Effect ghosts \u2014 push afterimages + pit fall sinking ghosts\ninterface EffectGhost {\n  type: 'fade' | 'sink';\n  mesh: Group;\n  life: number;\n  maxLife: number;\n}\nconst effectGhosts: EffectGhost[] = [];\n\n// Shared unit geometries for ghost meshes (scaled per-instance)\nlet _ghostBodyGeo: CylinderGeometry | null = null;\nlet _ghostHeadGeo: SphereGeometry | null = null;\n\nfunction createGhostMesh(x: number, z: number, radius: number, height: number, color: number): Group {\n  if (!_ghostBodyGeo) {\n    _ghostBodyGeo = new THREE.CylinderGeometry(1, 1, 1, 6);\n    _ghostHeadGeo = new THREE.SphereGeometry(1, 6, 4);\n  }\n  const group = new THREE.Group();\n\n  const bodyMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.4 });\n  const body = new THREE.Mesh(_ghostBodyGeo, bodyMat);\n  const bodyH = height * 0.6;\n  body.scale.set(radius, bodyH, radius);\n  body.position.y = height * 0.3;\n  group.add(body);\n\n  const headMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.4 });\n  const headR = radius * 0.7;\n  const head = new THREE.Mesh(_ghostHeadGeo!, headMat);\n  head.scale.set(headR, headR, headR);\n  head.position.y = height * 0.75;\n  group.add(head);\n\n  group.position.set(x, 0, z);\n  getScene().add(group);\n  return group;\n}\n\nfunction spawnPushGhosts(enemy: Enemy, oldX: number, oldZ: number, newX: number, newZ: number): void {\n  const cfg = enemy.config;\n  const r = cfg.size.radius;\n  const h = cfg.size.height;\n  for (let t = 0.33; t < 1; t += 0.33) {\n    const gx = oldX + (newX - oldX) * t;\n    const gz = oldZ + (newZ - oldZ) * t;\n    const mesh = createGhostMesh(gx, gz, r, h, 0x44ffaa);\n    effectGhosts.push({ type: 'fade', mesh, life: 0, maxLife: 300 });\n  }\n}\n\nfunction spawnPitFallGhost(enemy: Enemy): void {\n  const cfg = enemy.config;\n  const r = cfg.size.radius;\n  const h = cfg.size.height;\n  const mesh = createGhostMesh(enemy.pos.x, enemy.pos.z, r, h, 0x8844ff);\n  mesh.children.forEach(child => {\n    ((child as Mesh).material as MeshBasicMaterial).opacity = 0.7;\n  });\n  effectGhosts.push({ type: 'sink', mesh, life: 0, maxLife: 500 });\n}\n\nexport function updateEffectGhosts(dt: number): void {\n  const dtMs = dt * 1000;\n  const scene = getScene();\n\n  for (let i = effectGhosts.length - 1; i >= 0; i--) {\n    const g = effectGhosts[i];\n    g.life += dtMs;\n    const t = Math.min(g.life / g.maxLife, 1);\n\n    if (g.type === 'fade') {\n      const alpha = 0.4 * (1 - t);\n      g.mesh.children.forEach(child => {\n        ((child as Mesh).material as MeshBasicMaterial).opacity = alpha;\n      });\n    } else if (g.type === 'sink') {\n      const scale = 1 - t;\n      g.mesh.scale.set(scale, scale, scale);\n      g.mesh.position.y = -1.5 * t;\n      const alpha = 0.7 * (1 - t * t);\n      g.mesh.children.forEach(child => {\n        ((child as Mesh).material as MeshBasicMaterial).opacity = alpha;\n      });\n    }\n\n    if (t >= 1) {\n      g.mesh.children.forEach(child => {\n        ((child as Mesh).material as Material).dispose();\n      });\n      scene.remove(g.mesh);\n      effectGhosts.splice(i, 1);\n    }\n  }\n}\n\nexport function clearEffectGhosts(): void {\n  const scene = getScene();\n  for (const g of effectGhosts) {\n    g.mesh.children.forEach(child => {\n      ((child as Mesh).material as Material).dispose();\n    });\n    scene.remove(g.mesh);\n  }\n  effectGhosts.length = 0;\n}\n\nexport function getBounds(): AABB[] {\n  if (!collisionBounds) collisionBounds = getCollisionBounds();\n  return collisionBounds;\n}\n\nexport function getPits(): AABB[] {\n  if (!pitBounds) pitBounds = getPitBounds();\n  return pitBounds;\n}\n\nfunction getMoveBounds(): AABB[] {\n  if (!movementBounds) movementBounds = [...getBounds(), ...getPits()];\n  return movementBounds;\n}\n\nfunction circleVsAABB(cx: number, cz: number, radius: number, box: AABB): { x: number; z: number } | null {\n  const closestX = Math.max(box.minX, Math.min(cx, box.maxX));\n  const closestZ = Math.max(box.minZ, Math.min(cz, box.maxZ));\n\n  const dx = cx - closestX;\n  const dz = cz - closestZ;\n  const distSq = dx * dx + dz * dz;\n\n  if (distSq < radius * radius) {\n    const dist = Math.sqrt(distSq);\n    if (dist === 0) {\n      const overlapLeft = cx - box.minX;\n      const overlapRight = box.maxX - cx;\n      const overlapTop = cz - box.minZ;\n      const overlapBottom = box.maxZ - cz;\n      const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);\n      if (minOverlap === overlapLeft) return { x: -(overlapLeft + radius), z: 0 };\n      if (minOverlap === overlapRight) return { x: overlapRight + radius, z: 0 };\n      if (minOverlap === overlapTop) return { x: 0, z: -(overlapTop + radius) };\n      return { x: 0, z: overlapBottom + radius };\n    }\n    const overlap = radius - dist;\n    return { x: (dx / dist) * overlap, z: (dz / dist) * overlap };\n  }\n  return null;\n}\n\nfunction pointVsAABB(px: number, pz: number, box: AABB): boolean {\n  return px >= box.minX && px <= box.maxX && pz >= box.minZ && pz <= box.maxZ;\n}\n\nexport function resolveTerrainCollision(x: number, z: number, radius: number, entityY = 0): { x: number; z: number } {\n  const bounds = getBounds();\n  let rx = x, rz = z;\n  for (const box of bounds) {\n    if (box.maxY !== undefined && entityY >= box.maxY) continue;\n    const push = circleVsAABB(rx, rz, radius, box);\n    if (push) {\n      rx += push.x;\n      rz += push.z;\n    }\n  }\n  return { x: rx, z: rz };\n}\n\nexport function pointHitsTerrain(px: number, pz: number): boolean {\n  const bounds = getBounds();\n  for (const box of bounds) {\n    if (pointVsAABB(px, pz, box)) return true;\n  }\n  return false;\n}\n\nexport function resolveMovementCollision(x: number, z: number, radius: number, entityY = 0): { x: number; z: number; wasDeflected: boolean } {\n  const bounds = getMoveBounds();\n  let rx = x, rz = z;\n  let wasDeflected = false;\n  for (const box of bounds) {\n    if (box.maxY !== undefined && entityY >= box.maxY) continue;\n    const push = circleVsAABB(rx, rz, radius, box);\n    if (push) {\n      rx += push.x;\n      rz += push.z;\n      wasDeflected = true;\n    }\n  }\n  return { x: rx, z: rz, wasDeflected };\n}\n\n// Enhanced terrain collision that returns wall normal info (for wall slam detection)\ninterface CollisionResult {\n  x: number;\n  z: number;\n  hitWall: boolean;\n  normalX: number;\n  normalZ: number;\n}\n\nfunction resolveTerrainCollisionEx(x: number, z: number, radius: number, entityY = 0): CollisionResult {\n  const bounds = getBounds();\n  let rx = x, rz = z;\n  let hitWall = false;\n  let totalNX = 0, totalNZ = 0;\n\n  for (const box of bounds) {\n    if (box.maxY !== undefined && entityY >= box.maxY) continue;\n    const push = circleVsAABB(rx, rz, radius, box);\n    if (push) {\n      rx += push.x;\n      rz += push.z;\n      hitWall = true;\n      // Accumulate push direction as wall normal\n      const len = Math.sqrt(push.x * push.x + push.z * push.z);\n      if (len > 0.001) {\n        totalNX += push.x / len;\n        totalNZ += push.z / len;\n      }\n    }\n  }\n\n  // Normalize accumulated normal\n  const nLen = Math.sqrt(totalNX * totalNX + totalNZ * totalNZ);\n  if (nLen > 0.001) {\n    totalNX /= nLen;\n    totalNZ /= nLen;\n  }\n\n  return { x: rx, z: rz, hitWall, normalX: totalNX, normalZ: totalNZ };\n}\n\n// \u2500\u2500\u2500 Velocity Integration + Wall Slam \u2500\u2500\u2500\n\nexport function applyVelocities(dt: number, gameState: GameState): void {\n  for (const enemy of gameState.enemies) {\n    if (enemy.health <= 0) continue;\n    if ((enemy as any).isLeaping) continue;\n    if ((enemy as any).isCarrierPayload) continue;\n\n    const vel = (enemy as any).vel;\n    if (!vel) continue;\n\n    // Ensure vel.y exists (backwards compat with old enemy data)\n    if (vel.y === undefined) vel.y = 0;\n\n    const speed = Math.sqrt(vel.x * vel.x + vel.z * vel.z);\n    const hasXZVelocity = speed >= PHYSICS.minVelocity;\n\n    if (!hasXZVelocity && vel.y === 0 && enemy.pos.y <= PHYSICS.groundEpsilon) {\n      vel.x = 0;\n      vel.z = 0;\n      continue;\n    }\n\n    // \u2500\u2500\u2500 XZ Movement (stepped to prevent wall tunneling) \u2500\u2500\u2500\n    if (hasXZVelocity) {\n      const moveDist = speed * dt;\n      const enemyRadius = enemy.config.size.radius;\n      const moveSteps = Math.ceil(moveDist / enemyRadius);\n      const subDt = dt / Math.max(moveSteps, 1);\n\n      let fellInPit = false;\n      let result: CollisionResult = { x: enemy.pos.x, z: enemy.pos.z, hitWall: false, normalX: 0, normalZ: 0 };\n\n      for (let s = 0; s < moveSteps; s++) {\n        enemy.pos.x += vel.x * subDt;\n        enemy.pos.z += vel.z * subDt;\n\n        // Check for pit fall (only if grounded \u2014 airborne enemies fly over pits)\n        const isGrounded = enemy.pos.y <= PHYSICS.groundEpsilon;\n        if (isGrounded && pointInPit(enemy.pos.x, enemy.pos.z)) {\n          fellInPit = true;\n          break;\n        }\n\n        result = resolveTerrainCollisionEx(enemy.pos.x, enemy.pos.z, enemyRadius, enemy.pos.y);\n        enemy.pos.x = result.x;\n        enemy.pos.z = result.z;\n        if (result.hitWall) break; // Stop stepping on wall hit \u2014 wall slam will handle the rest\n      }\n\n      // Pit fall \u2014 enemy was knocked into a pit by velocity\n      if (fellInPit) {\n        spawnPitFallGhost(enemy);\n        emit({ type: 'pitFall', position: { x: enemy.pos.x, z: enemy.pos.z }, isPlayer: false });\n        createAoeRing(enemy.pos.x, enemy.pos.z, 2.5, 500, 0x8844ff);\n        enemy.health = 0;\n        (enemy as any).fellInPit = true;\n        enemy.stunTimer = 9999;\n        spawnDamageNumber(enemy.pos.x, enemy.pos.z, 'FELL!', '#8844ff');\n        screenShake(4, 200);\n        vel.x = 0;\n        vel.y = 0;\n        vel.z = 0;\n        continue; // Skip wall slam + friction \u2014 enemy is gone\n      }\n\n      // Wall slam detection\n      if (result.hitWall && speed > PHYSICS.wallSlamMinSpeed) {\n        const room = getCurrentRoom();\n        const wallSlamEnabled = room?.enableWallSlamDamage ?? true;\n\n        if (wallSlamEnabled) {\n          const slamDamage = Math.round((speed - PHYSICS.wallSlamMinSpeed) * PHYSICS.wallSlamDamage);\n          applyDamageToEnemy(enemy, slamDamage, gameState);\n          stunEnemy(enemy, PHYSICS.wallSlamStun);\n\n          // Feedback\n          emit({ type: 'wallSlam', enemy, speed, damage: slamDamage, position: { x: enemy.pos.x, z: enemy.pos.z } });\n          spawnDamageNumber(enemy.pos.x, enemy.pos.z, slamDamage, '#ff8844');\n          screenShake(PHYSICS.wallSlamShake, 120);\n\n          // Flash enemy\n          enemy.flashTimer = 120;\n          if ((enemy as any).bodyMesh) (enemy as any).bodyMesh.material.emissive.setHex(0xff8844);\n          if ((enemy as any).headMesh) (enemy as any).headMesh.material.emissive.setHex(0xff8844);\n\n          // Impact ring at slam point (terrain flash)\n          createAoeRing(enemy.pos.x, enemy.pos.z, 1.5, 300, 0xff8844);\n        }\n\n        // Reflect velocity off wall normal (always \u2014 physics still works, just no damage)\n        const dot = vel.x * result.normalX + vel.z * result.normalZ;\n        vel.x = (vel.x - 2 * dot * result.normalX) * PHYSICS.wallSlamBounce;\n        vel.z = (vel.z - 2 * dot * result.normalZ) * PHYSICS.wallSlamBounce;\n      }\n    } else {\n      vel.x = 0;\n      vel.z = 0;\n    }\n\n    // \u2500\u2500\u2500 Y-axis Integration (gravity + ground clamping) \u2500\u2500\u2500\n    const launchedEntry = getLaunchedEntry(enemy);\n    const gravMult = launchedEntry?.gravityMult ?? 1;\n    if (enemy.pos.y > PHYSICS.groundEpsilon || vel.y > 0) {\n      // Apply Y velocity\n      enemy.pos.y += vel.y * dt;\n      // Apply gravity (scaled by launch registry override)\n      vel.y -= PHYSICS.gravity * gravMult * dt;\n      vel.y = Math.max(vel.y, -PHYSICS.terminalVelocity);\n    }\n\n    // Ground clamping\n    const groundHeight = getGroundHeight(enemy.pos.x, enemy.pos.z);\n    if (enemy.pos.y < groundHeight) {\n      enemy.pos.y = groundHeight;\n      vel.y = 0;\n    }\n\n    // Sync mesh position (includes Y now)\n    (enemy as any).mesh.position.copy(enemy.pos);\n\n    // Apply XZ friction only when grounded (airborne = no XZ friction)\n    const isGroundedNow = enemy.pos.y <= groundHeight + PHYSICS.groundEpsilon;\n    if (isGroundedNow && speed >= PHYSICS.minVelocity) {\n      const newSpeed = speed - PHYSICS.friction * dt;\n      if (newSpeed <= PHYSICS.minVelocity) {\n        vel.x = 0;\n        vel.z = 0;\n      } else {\n        const scale = newSpeed / speed;\n        vel.x *= scale;\n        vel.z *= scale;\n      }\n    }\n  }\n}\n\n// \u2500\u2500\u2500 PhysicsObject Velocity Integration \u2500\u2500\u2500\n\nexport function applyObjectVelocities(dt: number, gameState: GameState): void {\n  for (const obj of gameState.physicsObjects) {\n    if (obj.destroyed) continue;\n    if (obj.suspended) continue;\n\n    const vel = obj.vel;\n    const speed = Math.sqrt(vel.x * vel.x + vel.z * vel.z);\n    if (speed < PHYSICS.minVelocity) {\n      vel.x = 0;\n      vel.z = 0;\n      continue;\n    }\n\n    // Stepped movement to prevent wall tunneling\n    const moveDist = speed * dt;\n    const moveSteps = Math.ceil(moveDist / obj.radius);\n    const subDt = dt / Math.max(moveSteps, 1);\n    let result: CollisionResult = { x: obj.pos.x, z: obj.pos.z, hitWall: false, normalX: 0, normalZ: 0 };\n\n    let fellInPit = false;\n    for (let s = 0; s < moveSteps; s++) {\n      obj.pos.x += vel.x * subDt;\n      obj.pos.z += vel.z * subDt;\n\n      if (pointInPit(obj.pos.x, obj.pos.z)) {\n        fellInPit = true;\n        break;\n      }\n\n      result = resolveTerrainCollisionEx(obj.pos.x, obj.pos.z, obj.radius);\n      obj.pos.x = result.x;\n      obj.pos.z = result.z;\n\n      if (result.hitWall) {\n        // Slide along wall: remove velocity component into the wall normal\n        const dot = vel.x * result.normalX + vel.z * result.normalZ;\n        if (dot < 0) {\n          vel.x -= dot * result.normalX;\n          vel.z -= dot * result.normalZ;\n        }\n        const slideSpeed = Math.sqrt(vel.x * vel.x + vel.z * vel.z);\n        if (slideSpeed < PHYSICS.minVelocity) break;\n      }\n\n      // Check collision with other physics objects during stepping.\n      // This prevents a fast-moving object from tunneling through another.\n      let hitObject = false;\n      for (const other of gameState.physicsObjects) {\n        if (other === obj || other.destroyed) continue;\n        const odx = obj.pos.x - other.pos.x;\n        const odz = obj.pos.z - other.pos.z;\n        const oDistSq = odx * odx + odz * odz;\n        const oMinDist = obj.radius + other.radius;\n        if (oDistSq < oMinDist * oMinDist && oDistSq > 0.0001) {\n          // Push this object back out and stop stepping\n          const oDist = Math.sqrt(oDistSq);\n          const oOverlap = oMinDist - oDist;\n          const onx = odx / oDist;\n          const onz = odz / oDist;\n          obj.pos.x += onx * oOverlap;\n          obj.pos.z += onz * oOverlap;\n\n          // Remove velocity component into the other object\n          const vDot = vel.x * (-onx) + vel.z * (-onz);\n          if (vDot > 0) {\n            vel.x += vDot * onx;\n            vel.z += vDot * onz;\n          }\n          hitObject = true;\n          break;\n        }\n      }\n      if (hitObject) break;\n    }\n\n    // Sync mesh position\n    if (obj.mesh) {\n      obj.mesh.position.set(obj.pos.x, 0, obj.pos.z);\n    }\n\n    // Pit fall\n    if (fellInPit) {\n      obj.destroyed = true;\n      obj.fellInPit = true;\n      emit({ type: 'objectPitFall', object: obj, position: { x: obj.pos.x, z: obj.pos.z } });\n      if (obj.mesh) obj.mesh.visible = false;\n      vel.x = 0;\n      vel.z = 0;\n      continue;\n    }\n\n    // Wall slam \u2014 uses original speed (before wall slide) for damage calculation\n    if (result.hitWall && speed > PHYSICS.objectWallSlamMinSpeed) {\n      const slamDamage = Math.round((speed - PHYSICS.objectWallSlamMinSpeed) * PHYSICS.objectWallSlamDamage);\n\n      // Damage the object itself (skip if indestructible)\n      if (isFinite(obj.health)) {\n        obj.health -= slamDamage;\n        if (obj.health <= 0) {\n          obj.health = 0;\n          obj.destroyed = true;\n          if (obj.mesh) obj.mesh.visible = false;\n          emit({ type: 'objectDestroyed', object: obj, position: { x: obj.pos.x, z: obj.pos.z } });\n        }\n      }\n\n      emit({ type: 'objectWallSlam', object: obj, speed, damage: slamDamage, position: { x: obj.pos.x, z: obj.pos.z } });\n      screenShake(PHYSICS.objectWallSlamShake, 120);\n\n      // Apply bounce damping to remaining (slid) velocity \u2014 energy is lost on wall impact\n      const bounce = obj.restitution ?? PHYSICS.objectWallSlamBounce;\n      vel.x *= bounce;\n      vel.z *= bounce;\n    }\n\n    // Friction \u2014 based on current velocity (may have been modified by wall slide/bounce)\n    const currentSpeed = Math.sqrt(vel.x * vel.x + vel.z * vel.z);\n    if (currentSpeed > PHYSICS.minVelocity) {\n      const newSpeed = currentSpeed - PHYSICS.objectFriction * dt;\n      if (newSpeed <= PHYSICS.minVelocity) {\n        vel.x = 0;\n        vel.z = 0;\n      } else {\n        const scale = newSpeed / currentSpeed;\n        vel.x *= scale;\n        vel.z *= scale;\n      }\n    } else {\n      vel.x = 0;\n      vel.z = 0;\n    }\n  }\n}\n\n// \u2500\u2500\u2500 Enemy-Enemy Collision + Momentum Transfer \u2500\u2500\u2500\n\nexport function resolveEnemyCollisions(gameState: GameState): void {\n  const enemies = gameState.enemies;\n  const len = enemies.length;\n\n  for (let i = 0; i < len; i++) {\n    const a = enemies[i];\n    if (a.health <= 0) continue;\n    if ((a as any).isLeaping) continue;\n    if ((a as any).isCarrierPayload) continue;\n    // Skip airborne enemies from XZ collision resolution\n    if (a.pos.y > PHYSICS.groundEpsilon) continue;\n\n    for (let j = i + 1; j < len; j++) {\n      const b = enemies[j];\n      if (b.health <= 0) continue;\n      if ((b as any).isLeaping) continue;\n      // Skip airborne enemies from XZ collision resolution\n      if (b.pos.y > PHYSICS.groundEpsilon) continue;\n\n      const dx = b.pos.x - a.pos.x;\n      const dz = b.pos.z - a.pos.z;\n      const distSq = dx * dx + dz * dz;\n      const radA = a.config.size.radius;\n      const radB = b.config.size.radius;\n      const minDist = radA + radB;\n\n      if (distSq >= minDist * minDist) continue;\n\n      const dist = Math.sqrt(distSq);\n      if (dist < 0.01) continue; // degenerate overlap\n\n      const overlap = minDist - dist;\n      const nx = dx / dist;\n      const nz = dz / dist;\n\n      // Mass-weighted separation\n      const massA = a.config.mass ?? 1.0;\n      const massB = b.config.mass ?? 1.0;\n      const totalMass = massA + massB;\n      const ratioA = massB / totalMass; // lighter = moves more\n      const ratioB = massA / totalMass;\n\n      // Push apart\n      a.pos.x -= nx * overlap * ratioA;\n      a.pos.z -= nz * overlap * ratioA;\n      b.pos.x += nx * overlap * ratioB;\n      b.pos.z += nz * overlap * ratioB;\n\n      // Momentum transfer (only if at least one has velocity)\n      const velA = (a as any).vel;\n      const velB = (b as any).vel;\n      if (!velA || !velB) continue;\n\n      const relVelX = velA.x - velB.x;\n      const relVelZ = velA.z - velB.z;\n      const relVelDotN = relVelX * nx + relVelZ * nz;\n\n      if (relVelDotN <= 0) continue; // moving apart, skip\n\n      // 2D elastic collision with restitution\n      const e = PHYSICS.enemyBounce;\n      const impulse = (1 + e) * relVelDotN / totalMass;\n\n      velA.x -= impulse * massB * nx;\n      velA.z -= impulse * massB * nz;\n      velB.x += impulse * massA * nx;\n      velB.z += impulse * massA * nz;\n\n      // Impact damage (if relative speed above threshold)\n      const relSpeed = Math.sqrt(relVelX * relVelX + relVelZ * relVelZ);\n      const room = getCurrentRoom();\n      const collisionDmgEnabled = room?.enableEnemyCollisionDamage ?? true;\n      if (collisionDmgEnabled && relSpeed > PHYSICS.impactMinSpeed) {\n        const dmg = Math.round((relSpeed - PHYSICS.impactMinSpeed) * PHYSICS.impactDamage);\n        const midX = (a.pos.x + b.pos.x) / 2;\n        const midZ = (a.pos.z + b.pos.z) / 2;\n\n        // Lighter enemy takes more damage\n        const dmgA = Math.round(dmg * ratioA);\n        const dmgB = Math.round(dmg * ratioB);\n\n        if (dmgA > 0) {\n          applyDamageToEnemy(a, dmgA, gameState);\n          a.flashTimer = 100;\n          if ((a as any).bodyMesh) (a as any).bodyMesh.material.emissive.setHex(0xffaa44);\n          if ((a as any).headMesh) (a as any).headMesh.material.emissive.setHex(0xffaa44);\n        }\n        if (dmgB > 0) {\n          applyDamageToEnemy(b, dmgB, gameState);\n          b.flashTimer = 100;\n          if ((b as any).bodyMesh) (b as any).bodyMesh.material.emissive.setHex(0xffaa44);\n          if ((b as any).headMesh) (b as any).headMesh.material.emissive.setHex(0xffaa44);\n        }\n\n        stunEnemy(a, PHYSICS.impactStun);\n        stunEnemy(b, PHYSICS.impactStun);\n\n        spawnDamageNumber(midX, midZ, dmg, '#ffaa44');\n        screenShake(2, 80);\n\n        emit({\n          type: 'enemyImpact',\n          enemyA: a, enemyB: b,\n          speed: relSpeed, damage: dmg,\n          position: { x: midX, z: midZ }\n        });\n      }\n\n      // Sync mesh positions\n      (a as any).mesh.position.copy(a.pos);\n      (b as any).mesh.position.copy(b.pos);\n    }\n  }\n}\n\n// \u2500\u2500\u2500 PhysicsObject Collisions (Object-Object + Object-Enemy) \u2500\u2500\u2500\n\nexport function resolveObjectCollisions(gameState: GameState): void {\n  const objects = gameState.physicsObjects;\n  const enemies = gameState.enemies;\n\n  // Object-Object collisions \u2014 run multiple iterations to handle chain/wall cases\n  for (let iter = 0; iter < 3; iter++) {\n    for (let i = 0; i < objects.length; i++) {\n      const a = objects[i];\n      if (a.destroyed) continue;\n      if (a.suspended) continue;\n\n      for (let j = i + 1; j < objects.length; j++) {\n        const b = objects[j];\n        if (b.destroyed) continue;\n        if (b.suspended) continue;\n\n        const dx = b.pos.x - a.pos.x;\n        const dz = b.pos.z - a.pos.z;\n        const distSq = dx * dx + dz * dz;\n        const minDist = a.radius + b.radius;\n\n        if (distSq >= minDist * minDist) continue;\n\n        const dist = Math.sqrt(distSq);\n        if (dist < 0.01) continue;\n\n        const overlap = minDist - dist;\n        const nx = dx / dist;\n        const nz = dz / dist;\n\n        // Check which objects are terrain-blocked (can't move in separation direction)\n        const aTerrainCheck = resolveTerrainCollisionEx(\n          a.pos.x - nx * 0.05, a.pos.z - nz * 0.05, a.radius);\n        const bTerrainCheck = resolveTerrainCollisionEx(\n          b.pos.x + nx * 0.05, b.pos.z + nz * 0.05, b.radius);\n        const aBlocked = aTerrainCheck.hitWall;\n        const bBlocked = bTerrainCheck.hitWall;\n\n        // Distribute separation: blocked objects get 0 share\n        let ratioA: number, ratioB: number;\n        if (aBlocked && !bBlocked) {\n          ratioA = 0; ratioB = 1;\n        } else if (!aBlocked && bBlocked) {\n          ratioA = 1; ratioB = 0;\n        } else {\n          const totalMass = a.mass + b.mass;\n          ratioA = b.mass / totalMass;\n          ratioB = a.mass / totalMass;\n        }\n\n        a.pos.x -= nx * overlap * ratioA;\n        a.pos.z -= nz * overlap * ratioA;\n        b.pos.x += nx * overlap * ratioB;\n        b.pos.z += nz * overlap * ratioB;\n\n        // Momentum transfer (only on first iteration to avoid double-counting)\n        if (iter === 0) {\n          const totalMass = a.mass + b.mass;\n          const relVelX = a.vel.x - b.vel.x;\n          const relVelZ = a.vel.z - b.vel.z;\n          const relVelDotN = relVelX * nx + relVelZ * nz;\n          if (relVelDotN > 0) {\n            const e = PHYSICS.objectWallSlamBounce;\n            const impulse = (1 + e) * relVelDotN / totalMass;\n\n            a.vel.x -= impulse * b.mass * nx;\n            a.vel.z -= impulse * b.mass * nz;\n            b.vel.x += impulse * a.mass * nx;\n            b.vel.z += impulse * a.mass * nz;\n          }\n        }\n\n        // Sync meshes\n        if (a.mesh) a.mesh.position.set(a.pos.x, 0, a.pos.z);\n        if (b.mesh) b.mesh.position.set(b.pos.x, 0, b.pos.z);\n      }\n    }\n  }\n\n  // Object-Enemy collisions\n  for (const obj of objects) {\n    if (obj.destroyed) continue;\n    if (obj.suspended) continue;\n\n    for (const enemy of enemies) {\n      if (enemy.health <= 0) continue;\n      if ((enemy as any).isLeaping) continue;\n\n      const dx = enemy.pos.x - obj.pos.x;\n      const dz = enemy.pos.z - obj.pos.z;\n      const distSq = dx * dx + dz * dz;\n      const radObj = obj.radius;\n      const radEnemy = enemy.config.size.radius;\n      const minDist = radObj + radEnemy;\n\n      if (distSq >= minDist * minDist) continue;\n\n      const dist = Math.sqrt(distSq);\n      if (dist < 0.01) continue;\n\n      const overlap = minDist - dist;\n      const nx = dx / dist;\n      const nz = dz / dist;\n\n      const massObj = obj.mass;\n      const massEnemy = enemy.config.mass ?? 1.0;\n      const totalMass = massObj + massEnemy;\n      const ratioObj = massEnemy / totalMass;\n      const ratioEnemy = massObj / totalMass;\n\n      // Separate\n      obj.pos.x -= nx * overlap * ratioObj;\n      obj.pos.z -= nz * overlap * ratioObj;\n      enemy.pos.x += nx * overlap * ratioEnemy;\n      enemy.pos.z += nz * overlap * ratioEnemy;\n\n      // Momentum transfer\n      const velEnemy = (enemy as any).vel;\n      if (!velEnemy) continue;\n\n      const relVelX = obj.vel.x - velEnemy.x;\n      const relVelZ = obj.vel.z - velEnemy.z;\n      const relVelDotN = relVelX * nx + relVelZ * nz;\n      if (relVelDotN <= 0) continue;\n\n      const e = obj.restitution ?? PHYSICS.enemyBounce;\n      const impulse = (1 + e) * relVelDotN / totalMass;\n\n      obj.vel.x -= impulse * massEnemy * nx;\n      obj.vel.z -= impulse * massEnemy * nz;\n      velEnemy.x += impulse * massObj * nx;\n      velEnemy.z += impulse * massObj * nz;\n\n      // Impact damage to enemy (if relative speed high enough)\n      const relSpeed = Math.sqrt(relVelX * relVelX + relVelZ * relVelZ);\n      if (relSpeed > PHYSICS.objectImpactMinSpeed) {\n        const dmg = Math.round((relSpeed - PHYSICS.objectImpactMinSpeed) * PHYSICS.objectImpactDamage);\n        if (dmg > 0) {\n          applyDamageToEnemy(enemy, dmg, gameState);\n          enemy.flashTimer = 100;\n          if ((enemy as any).bodyMesh) (enemy as any).bodyMesh.material.emissive.setHex(0xffaa44);\n          if ((enemy as any).headMesh) (enemy as any).headMesh.material.emissive.setHex(0xffaa44);\n          spawnDamageNumber(enemy.pos.x, enemy.pos.z, dmg, '#ffaa44');\n          screenShake(2, 80);\n\n          emit({\n            type: 'objectImpact',\n            objectA: obj, objectB: enemy,\n            speed: relSpeed, damage: dmg,\n            position: { x: (obj.pos.x + enemy.pos.x) / 2, z: (obj.pos.z + enemy.pos.z) / 2 }\n          });\n        }\n      }\n\n      // Sync mesh positions\n      if (obj.mesh) obj.mesh.position.set(obj.pos.x, 0, obj.pos.z);\n      (enemy as any).mesh.position.copy(enemy.pos);\n    }\n  }\n}\n\n// \u2500\u2500\u2500 Physics Object Body Collisions \u2500\u2500\u2500\n// Prevents player and enemies from walking through physics objects.\n// Objects act as solid cylindrical blockers. The entity is always the one\n// pushed out (objects only move via force push velocity, not body collision).\n\nexport function resolvePhysicsObjectBodyCollisions(gameState: GameState): void {\n  const objects = gameState.physicsObjects;\n  const playerPos = getPlayerPos();\n  const playerR = PLAYER.size.radius;\n\n  for (const obj of objects) {\n    if (obj.destroyed) continue;\n    if (obj.suspended) continue;\n\n    // \u2500\u2500\u2500 Player vs Object \u2500\u2500\u2500\n    const pdx = playerPos.x - obj.pos.x;\n    const pdz = playerPos.z - obj.pos.z;\n    const pDistSq = pdx * pdx + pdz * pdz;\n    const pMinDist = playerR + obj.radius;\n\n    if (pDistSq < pMinDist * pMinDist && pDistSq > 0.0001) {\n      const pDist = Math.sqrt(pDistSq);\n      const pOverlap = pMinDist - pDist;\n      // Push player out entirely (object stays put)\n      playerPos.x += (pdx / pDist) * pOverlap;\n      playerPos.z += (pdz / pDist) * pOverlap;\n    }\n\n    // \u2500\u2500\u2500 Enemy vs Object \u2500\u2500\u2500\n    for (const enemy of gameState.enemies) {\n      if (enemy.health <= 0) continue;\n      if ((enemy as any).isLeaping) continue;\n\n      const edx = enemy.pos.x - obj.pos.x;\n      const edz = enemy.pos.z - obj.pos.z;\n      const eDistSq = edx * edx + edz * edz;\n      const eRadEnemy = enemy.config.size.radius;\n      const eMinDist = eRadEnemy + obj.radius;\n\n      if (eDistSq < eMinDist * eMinDist && eDistSq > 0.0001) {\n        const eDist = Math.sqrt(eDistSq);\n        const eOverlap = eMinDist - eDist;\n        // Push enemy out entirely (object stays put)\n        enemy.pos.x += (edx / eDist) * eOverlap;\n        enemy.pos.z += (edz / eDist) * eOverlap;\n      }\n    }\n  }\n}\n\nexport function pointInPit(px: number, pz: number): boolean {\n  const pits = getPits();\n  for (const pit of pits) {\n    if (px >= pit.minX && px <= pit.maxX && pz >= pit.minZ && pz <= pit.maxZ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function checkPitFalls(gameState: GameState): void {\n  const playerPos = getPlayerPos();\n\n  if (!isPlayerDashing() && !isPlayerInvincible()) {\n    if (pointInPit(playerPos.x, playerPos.z)) {\n      gameState.playerHealth = 0;\n      gameState.phase = 'gameOver';\n      screenShake(5, 200);\n      emit({ type: 'pitFall', position: { x: playerPos.x, z: playerPos.z }, isPlayer: true });\n      spawnDamageNumber(playerPos.x, playerPos.z, 'FELL!', '#ff4466');\n    }\n  }\n\n  for (const enemy of gameState.enemies) {\n    if (enemy.health <= 0) continue;\n    if ((enemy as any).isLeaping) continue;\n    if (pointInPit(enemy.pos.x, enemy.pos.z)) {\n      spawnPitFallGhost(enemy);\n      emit({ type: 'pitFall', position: { x: enemy.pos.x, z: enemy.pos.z }, isPlayer: false });\n      createAoeRing(enemy.pos.x, enemy.pos.z, 2.5, 500, 0x8844ff);\n\n      enemy.health = 0;\n      (enemy as any).fellInPit = true;\n      enemy.stunTimer = 9999;\n      spawnDamageNumber(enemy.pos.x, enemy.pos.z, 'FELL!', '#8844ff');\n      screenShake(4, 200);\n    }\n  }\n}\n\nfunction applyDamageToEnemy(enemy: Enemy, damage: number, gameState: GameState): void {\n  if ((enemy as any).shieldActive && (enemy as any).shieldHealth > 0) {\n    (enemy as any).shieldHealth -= damage;\n    if ((enemy as any).shieldHealth <= 0) {\n      const overkill = -(enemy as any).shieldHealth;\n      (enemy as any).shieldHealth = 0;\n      (enemy as any).shieldActive = false;\n      onShieldBreak(enemy, gameState);\n      if (overkill > 0) {\n        enemy.health -= overkill;\n      }\n    }\n  } else {\n    enemy.health -= damage;\n  }\n  // Trigger squash/bounce hit reaction\n  if ((enemy as any).hitReaction) {\n    triggerHitReaction((enemy as any).hitReaction);\n  }\n}\n\nfunction onShieldBreak(enemy: Enemy, gameState: GameState): void {\n  const shieldCfg = enemy.config.shield;\n  if (!shieldCfg) return;\n\n  if ((enemy as any).shieldMesh) {\n    (enemy as any).shieldMesh.visible = false;\n    (enemy as any).mesh.remove((enemy as any).shieldMesh);\n    (enemy as any).shieldMesh.material.dispose();\n    (enemy as any).shieldMesh = null;\n  }\n\n  stunEnemy(enemy, shieldCfg.stunDuration);\n  spawnDamageNumber(enemy.pos.x, enemy.pos.z, 'BREAK', '#88eeff');\n\n  applyAoeEffect({\n    x: enemy.pos.x,\n    z: enemy.pos.z,\n    radius: shieldCfg.stunRadius,\n    durationMs: shieldCfg.breakRingDuration || 400,\n    color: 0x88eeff,\n    label: 'STUNNED',\n    effectFn: (e) => stunEnemy(e, shieldCfg.stunDuration),\n    gameState,\n    excludeEnemy: enemy,\n  });\n\n  emit({ type: 'shieldBreak', enemy, position: { x: enemy.pos.x, z: enemy.pos.z } });\n\n  (enemy as any).knockbackResist = 0;\n\n  if ((enemy as any).bodyMesh) {\n    (enemy as any).bodyMesh.material.transparent = true;\n    (enemy as any).bodyMesh.material.opacity = 0.5;\n  }\n  if ((enemy as any).headMesh) {\n    (enemy as any).headMesh.material.transparent = true;\n    (enemy as any).headMesh.material.opacity = 0.5;\n  }\n\n  screenShake(4, 200);\n}\n\nfunction checkMeleeHits(gameState: GameState): void {\n  if (!isMeleeSwinging()) return;\n\n  const playerPos = getPlayerPos();\n  const swingDir = getMeleeSwingDir();\n  const hitEnemies = getMeleeHitEnemies();\n\n  for (const enemy of gameState.enemies) {\n    if (enemy.health <= 0) continue;\n    if ((enemy as any).fellInPit) continue;\n    if (hitEnemies.has(enemy)) continue; // already hit this swing\n\n    if (!isInMeleeArc(playerPos.x, playerPos.z, swingDir, enemy.pos.x, enemy.pos.z, MELEE.range, MELEE.arc)) {\n      continue;\n    }\n\n    // Hit!\n    hitEnemies.add(enemy);\n\n    const wasShielded = (enemy as any).shieldActive;\n    applyDamageToEnemy(enemy, MELEE.damage, gameState);\n\n    // No melee knockback \u2014 force push handles displacement.\n    // Hit stun, flash, and screen shake remain for feedback.\n\n    // Feedback\n    emit({ type: 'enemyHit', enemy, damage: MELEE.damage, position: { x: enemy.pos.x, z: enemy.pos.z }, wasShielded });\n    emit({ type: 'meleeHit', enemy, damage: MELEE.damage, position: { x: enemy.pos.x, z: enemy.pos.z } });\n\n    const dmgColor = wasShielded ? '#88eeff' : '#ff8844';\n    spawnDamageNumber(enemy.pos.x, enemy.pos.z, MELEE.damage, dmgColor);\n\n    enemy.flashTimer = 100;\n    (enemy as any).bodyMesh.material.emissive.setHex(0xffffff);\n    if ((enemy as any).headMesh) (enemy as any).headMesh.material.emissive.setHex(0xffffff);\n\n    screenShake(MELEE.screenShake, 80);\n  }\n\n}\n\nexport function checkCollisions(gameState: GameState): void {\n  const playerPos = getPlayerPos();\n  const playerR = PLAYER.size.radius;\n\n  if (!isPlayerDashing()) {\n    const resolved = resolveMovementCollision(playerPos.x, playerPos.z, playerR, playerPos.y);\n    playerPos.x = resolved.x;\n    playerPos.z = resolved.z;\n  }\n\n  for (const enemy of gameState.enemies) {\n    if ((enemy as any).isLeaping) continue;\n    if ((enemy as any).fellInPit) continue; // Don't push dead-in-pit enemies back out\n\n    // Enemies with active velocity skip pit collision \u2014 they're allowed to be\n    // knocked into pits. The pit fall is detected in applyVelocities().\n    // Enemies walking under AI control still collide with pits as a safety net.\n    const vel = (enemy as any).vel;\n    const hasVelocity = vel && (vel.x * vel.x + vel.z * vel.z) > PHYSICS.minVelocity * PHYSICS.minVelocity;\n    const bounds = hasVelocity ? getBounds() : getMoveBounds();\n    let rx = enemy.pos.x, rz = enemy.pos.z;\n    let wasDeflected = false;\n    for (const box of bounds) {\n      // Skip obstacles the enemy is above (airborne or on higher platform)\n      if (box.maxY !== undefined && enemy.pos.y >= box.maxY) continue;\n      const push = circleVsAABB(rx, rz, enemy.config.size.radius, box);\n      if (push) {\n        rx += push.x;\n        rz += push.z;\n        wasDeflected = true;\n      }\n    }\n    enemy.pos.x = rx;\n    enemy.pos.z = rz;\n    (enemy as any).wasDeflected = wasDeflected;\n    (enemy as any).mesh.position.copy(enemy.pos);\n  }\n\n  const playerProj = getPlayerProjectiles();\n  for (let i = playerProj.length - 1; i >= 0; i--) {\n    const p = playerProj[i];\n    if (!p.mesh.visible) continue;\n\n    if (pointHitsTerrain(p.mesh.position.x, p.mesh.position.z)) {\n      releaseProjectile(p);\n      continue;\n    }\n\n    for (const enemy of gameState.enemies) {\n      const dx = p.mesh.position.x - enemy.pos.x;\n      const dz = p.mesh.position.z - enemy.pos.z;\n      const distSq = dx * dx + dz * dz;\n      const hitR = enemy.config.size.radius + PLAYER.projectile.size;\n\n      if (distSq < hitR * hitR) {\n        const wasShielded = (enemy as any).shieldActive;\n        applyDamageToEnemy(enemy, p.damage, gameState);\n        releaseProjectile(p);\n\n        emit({ type: 'enemyHit', enemy, damage: p.damage, position: { x: enemy.pos.x, z: enemy.pos.z }, wasShielded });\n\n        const dmgColor = wasShielded ? '#88eeff' : '#44ff88';\n        spawnDamageNumber(enemy.pos.x, enemy.pos.z, p.damage, dmgColor);\n\n        enemy.flashTimer = 80;\n        (enemy as any).bodyMesh.material.emissive.setHex(0xffffff);\n        if ((enemy as any).headMesh) (enemy as any).headMesh.material.emissive.setHex(0xffffff);\n\n        break;\n      }\n    }\n  }\n\n  const enemyProj = getEnemyProjectiles();\n  for (let i = enemyProj.length - 1; i >= 0; i--) {\n    const p = enemyProj[i];\n    if (!p.mesh.visible) continue;\n\n    if (pointHitsTerrain(p.mesh.position.x, p.mesh.position.z)) {\n      releaseProjectile(p);\n      continue;\n    }\n\n    if (!isPlayerInvincible()) {\n      const dx = p.mesh.position.x - playerPos.x;\n      const dz = p.mesh.position.z - playerPos.z;\n      const distSq = dx * dx + dz * dz;\n      const hitR = playerR + 0.1;\n\n      if (distSq < hitR * hitR) {\n        gameState.playerHealth -= p.damage;\n        releaseProjectile(p);\n        screenShake(3, 100);\n\n        emit({ type: 'playerHit', damage: p.damage, position: { x: playerPos.x, z: playerPos.z } });\n        spawnDamageNumber(playerPos.x, playerPos.z, p.damage, '#ff4466');\n\n        if (gameState.playerHealth <= 0) {\n          gameState.playerHealth = 0;\n          gameState.phase = 'gameOver';\n        }\n        break;\n      }\n    }\n  }\n\n  if (!isPlayerInvincible()) {\n    const now = performance.now();\n    for (const enemy of gameState.enemies) {\n      if (enemy.behavior === 'kite') continue;\n      if (enemy.config.melee) continue; // melee enemies use state machine, not contact damage\n      if (enemy.stunTimer > 0) continue;\n\n      const dx = enemy.pos.x - playerPos.x;\n      const dz = enemy.pos.z - playerPos.z;\n      const distSq = dx * dx + dz * dz;\n      const hitR = playerR + enemy.config.size.radius;\n\n      if (distSq < hitR * hitR) {\n        const attackCooldown = enemy.config.attackRate || 1000;\n        if (now - (enemy as any).lastAttackTime > attackCooldown) {\n          const chargeMult = (enemy.config.tank && enemy.config.tank.chargeDamageMult) || 1.5;\n          const dmg = (enemy as any).isCharging ? enemy.config.damage * chargeMult : enemy.config.damage;\n          gameState.playerHealth -= dmg;\n          (enemy as any).lastAttackTime = now;\n          screenShake((enemy as any).isCharging ? 5 : 2, (enemy as any).isCharging ? 150 : 80);\n\n          emit({ type: 'playerHit', damage: dmg, position: { x: playerPos.x, z: playerPos.z } });\n          spawnDamageNumber(playerPos.x, playerPos.z, dmg, '#ff4466');\n\n          if (gameState.playerHealth <= 0) {\n            gameState.playerHealth = 0;\n            gameState.phase = 'gameOver';\n          }\n        }\n      }\n    }\n  }\n\n  // Melee hit detection\n  checkMeleeHits(gameState);\n\n  const pushEvt = consumePushEvent();\n  if (pushEvt) {\n    const dirX = pushEvt.dirX;\n    const dirZ = pushEvt.dirZ;\n    // Perpendicular direction (lateral axis in push-local space)\n    const perpX = -dirZ;\n    const perpZ = dirX;\n    // Player position = rectangle center minus half-length along push direction\n    const halfLen = pushEvt.length / 2;\n    const playerX = pushEvt.x - dirX * halfLen;\n    const playerZ = pushEvt.z - dirZ * halfLen;\n\n    // 1. Collect all enemies AND physics objects in push rectangle\n    const candidates: { enemy: any; obj: any; forward: number; lateral: number }[] = [];\n\n    // Enemies\n    for (const enemy of gameState.enemies) {\n      if (enemy.health <= 0) continue;\n      if ((enemy as any).isLeaping) continue;\n      const enemyRadius = enemy.config.size.radius;\n      if (isInRotatedRect(enemy.pos.x, enemy.pos.z, pushEvt.x, pushEvt.z,\n                           pushEvt.width, pushEvt.length, pushEvt.rotation, enemyRadius)) {\n        const dx = enemy.pos.x - playerX;\n        const dz = enemy.pos.z - playerZ;\n        const forward = dx * dirX + dz * dirZ;  // distance along push axis\n        const lateral = dx * perpX + dz * perpZ; // offset perpendicular to push\n        candidates.push({ enemy, obj: null, forward, lateral });\n      }\n    }\n\n    // Physics objects\n    for (const obj of gameState.physicsObjects) {\n      if (obj.destroyed) continue;\n      if (obj.suspended) continue;\n      if (isInRotatedRect(obj.pos.x, obj.pos.z, pushEvt.x, pushEvt.z,\n                           pushEvt.width, pushEvt.length, pushEvt.rotation, obj.radius)) {\n        const dx = obj.pos.x - playerX;\n        const dz = obj.pos.z - playerZ;\n        const forward = dx * dirX + dz * dirZ;\n        const lateral = dx * perpX + dz * perpZ;\n        candidates.push({ enemy: null, obj, forward, lateral });\n      }\n    }\n\n    // 2. Sort by forward distance (nearest to player first)\n    candidates.sort((a, b) => a.forward - b.forward);\n\n    // 3. Apply knockback with wave occlusion\n    const pushedLaterals: number[] = [];\n    const blockRadius = PHYSICS.pushWaveBlockRadius;\n\n    for (const { enemy, obj, lateral } of candidates) {\n      // Check if blocked by any already-pushed target\n      let blocked = false;\n      for (const pushedLat of pushedLaterals) {\n        if (Math.abs(lateral - pushedLat) < blockRadius) {\n          blocked = true;\n          break;\n        }\n      }\n      if (blocked) continue;\n\n      if (enemy) {\n        // Enemy push (existing behavior)\n        const iceEffects = getIceEffects(enemy.pos.x, enemy.pos.z, false);\n        const kbMult = 1 - ((enemy as any).knockbackResist ?? enemy.config.knockbackResist ?? 0);\n        const kbDist = pushEvt.force * kbMult * iceEffects.knockbackMult;\n\n        if (kbDist > 0) {\n          const v0 = Math.sqrt(2 * PHYSICS.friction * kbDist);\n          (enemy as any).vel.x = dirX * v0;\n          (enemy as any).vel.z = dirZ * v0;\n        }\n        emit({ type: 'enemyPushed', enemy, position: { x: enemy.pos.x, z: enemy.pos.z } });\n\n        enemy.flashTimer = 100;\n        (enemy as any).bodyMesh.material.emissive.setHex(0x44ffaa);\n        if ((enemy as any).headMesh) (enemy as any).headMesh.material.emissive.setHex(0x44ffaa);\n\n        spawnDamageNumber(enemy.pos.x, enemy.pos.z, 'PUSH', '#44ffaa');\n      } else if (obj) {\n        // Object push: velocity = sqrt(2 * friction * (force / mass))\n        const kbDist = pushEvt.force / obj.mass;\n        if (kbDist > 0) {\n          const v0 = Math.sqrt(2 * PHYSICS.objectFriction * kbDist);\n          obj.vel.x = dirX * v0;\n          obj.vel.z = dirZ * v0;\n\n          // Nudge object off wall before velocity\n          const nudgeResult = resolveTerrainCollisionEx(obj.pos.x, obj.pos.z, obj.radius);\n          if (nudgeResult.hitWall) {\n            obj.pos.x = nudgeResult.x + nudgeResult.normalX * 0.1;\n            obj.pos.z = nudgeResult.z + nudgeResult.normalZ * 0.1;\n            if (obj.mesh) obj.mesh.position.set(obj.pos.x, 0, obj.pos.z);\n          }\n        }\n        emit({ type: 'objectPushed', object: obj, position: { x: obj.pos.x, z: obj.pos.z } });\n        spawnDamageNumber(obj.pos.x, obj.pos.z, 'PUSH', '#44ffaa');\n      }\n\n      pushedLaterals.push(lateral);\n    }\n  }\n\n}\n", "// Particle System \u2014 lightweight pool-based emitter for game effects\n// Config-driven bursts: hit sparks, death puffs, dash trails, etc.\n// Pre-allocates a fixed pool of mesh particles. No runtime allocation.\n// Subscribes to event bus for automatic particle spawning.\n\nimport { on } from './events';\nimport type { GameEvent } from './events';\nimport { MELEE } from '../config/player';\n\n// \u2500\u2500\u2500 Config Types \u2500\u2500\u2500\n\nexport interface ParticleConfig {\n  count: number;       // particles per burst (4-12 typical)\n  lifetime: number;    // seconds\n  speed: number;       // initial velocity (world units/sec)\n  spread: number;      // cone half-angle in radians (Math.PI = sphere)\n  size: number;        // world units\n  color: number;       // hex color\n  fadeOut: boolean;     // alpha decay over lifetime\n  gravity: number;     // downward acceleration (0 = floaty, 9.8 = heavy)\n  shape: 'box' | 'sphere';\n}\n\n// \u2500\u2500\u2500 Pre-defined Presets \u2500\u2500\u2500\n\nexport const HIT_SPARK: ParticleConfig = {\n  count: 5,\n  lifetime: 0.25,\n  speed: 6,\n  spread: Math.PI * 0.8,\n  size: 0.06,\n  color: 0xffffaa,\n  fadeOut: true,\n  gravity: 4,\n  shape: 'box',\n};\n\nexport const DEATH_PUFF: ParticleConfig = {\n  count: 8,\n  lifetime: 0.4,\n  speed: 3,\n  spread: Math.PI,\n  size: 0.08,\n  color: 0xffffff, // will be overridden with enemy color\n  fadeOut: true,\n  gravity: 1,\n  shape: 'sphere',\n};\n\nexport const DASH_TRAIL: ParticleConfig = {\n  count: 3,\n  lifetime: 0.3,\n  speed: 1.5,\n  spread: Math.PI * 0.3,\n  size: 0.05,\n  color: 0x44ff88,\n  fadeOut: true,\n  gravity: 0,\n  shape: 'box',\n};\n\nexport const SHIELD_BREAK_BURST: ParticleConfig = {\n  count: 10,\n  lifetime: 0.35,\n  speed: 8,\n  spread: Math.PI,\n  size: 0.07,\n  color: 0x88eeff,\n  fadeOut: true,\n  gravity: 3,\n  shape: 'box',\n};\n\nexport const PUSH_BURST: ParticleConfig = {\n  count: 4,\n  lifetime: 0.2,\n  speed: 5,\n  spread: Math.PI * 0.5,\n  size: 0.05,\n  color: 0x44ffaa,\n  fadeOut: true,\n  gravity: 2,\n  shape: 'box',\n};\n\nexport const CHARGE_BLAST: ParticleConfig = {\n  count: 12,\n  lifetime: 0.3,\n  speed: 10,\n  spread: Math.PI * 0.4,\n  size: 0.08,\n  color: 0x44ffaa,\n  fadeOut: true,\n  gravity: 2,\n  shape: 'sphere',\n};\n\nexport const ENEMY_IMPACT_SPARK: ParticleConfig = {\n  count: 6,\n  lifetime: 0.25,\n  speed: 5,\n  spread: Math.PI,\n  size: 0.06,\n  color: 0xffaa44,\n  fadeOut: true,\n  gravity: 4,\n  shape: 'sphere',\n};\n\nexport const WALL_SLAM_SPARK: ParticleConfig = {\n  count: 8,\n  lifetime: 0.3,\n  speed: 7,\n  spread: Math.PI * 0.6,\n  size: 0.07,\n  color: 0xff8844,\n  fadeOut: true,\n  gravity: 5,\n  shape: 'box',\n};\n\nexport const DOOR_UNLOCK_BURST: ParticleConfig = {\n  count: 12,\n  lifetime: 0.5,\n  speed: 6,\n  spread: Math.PI * 0.5,\n  size: 0.08,\n  color: 0x88bbff,\n  fadeOut: true,\n  gravity: -2,   // float upward\n  shape: 'sphere',\n};\n\n// \u2500\u2500\u2500 Vertical Combat Presets \u2500\u2500\u2500\n\nexport const JUMP_DUST: ParticleConfig = {\n  count: 4,\n  lifetime: 0.2,\n  speed: 3,\n  spread: Math.PI,\n  size: 0.05,\n  color: 0xbbaa88,\n  fadeOut: true,\n  gravity: 2,\n  shape: 'sphere',\n};\n\nexport const LAND_DUST: ParticleConfig = {\n  count: 6,\n  lifetime: 0.3,\n  speed: 4,\n  spread: Math.PI,\n  size: 0.06,\n  color: 0xbbaa88,\n  fadeOut: true,\n  gravity: 3,\n  shape: 'sphere',\n};\n\nexport const LAUNCH_BURST: ParticleConfig = {\n  count: 6,\n  lifetime: 0.3,\n  speed: 7,\n  spread: Math.PI * 0.4,\n  size: 0.06,\n  color: 0xffaa00,\n  fadeOut: true,\n  gravity: -2,   // float upward with the launch\n  shape: 'box',\n};\n\nexport const AERIAL_SPIKE: ParticleConfig = {\n  count: 8,\n  lifetime: 0.25,\n  speed: 8,\n  spread: Math.PI * 0.6,\n  size: 0.07,\n  color: 0x44ddff,\n  fadeOut: true,\n  gravity: 6,\n  shape: 'box',\n};\n\nexport const SLAM_IMPACT: ParticleConfig = {\n  count: 10,\n  lifetime: 0.35,\n  speed: 8,\n  spread: Math.PI,\n  size: 0.07,\n  color: 0xff8800,\n  fadeOut: true,\n  gravity: 4,\n  shape: 'box',\n};\n\nexport const DUNK_GRAB_SPARK: ParticleConfig = {\n  count: 5,\n  lifetime: 0.2,\n  speed: 5,\n  spread: Math.PI * 0.5,\n  size: 0.05,\n  color: 0xff44ff,\n  fadeOut: true,\n  gravity: 0,\n  shape: 'sphere',\n};\n\nexport const DUNK_IMPACT_BURST: ParticleConfig = {\n  count: 14,\n  lifetime: 0.4,\n  speed: 10,\n  spread: Math.PI,\n  size: 0.08,\n  color: 0xff2244,\n  fadeOut: true,\n  gravity: 5,\n  shape: 'box',\n};\n\n// \u2500\u2500\u2500 Pool \u2500\u2500\u2500\n\nconst POOL_SIZE = 80;\n\ninterface Particle {\n  mesh: any;       // THREE.Mesh\n  active: boolean;\n  life: number;    // seconds elapsed\n  maxLife: number;\n  vx: number;\n  vy: number;\n  vz: number;\n  gravity: number;\n  fadeOut: boolean;\n  material: any;   // THREE.MeshBasicMaterial (for opacity)\n  baseScale: number; // initial size for non-cumulative shrink\n}\n\nconst pool: Particle[] = [];\nlet sceneRef: any = null;\n\n// Shared geometries\nlet boxGeo: any = null;\nlet sphereGeo: any = null;\n\nexport function initParticles(scene: any): void {\n  sceneRef = scene;\n\n  // Create shared geometries\n  boxGeo = new THREE.BoxGeometry(1, 1, 1);\n  sphereGeo = new THREE.SphereGeometry(0.5, 4, 3);\n\n  // Pre-allocate pool\n  for (let i = 0; i < POOL_SIZE; i++) {\n    const mat = new THREE.MeshBasicMaterial({\n      color: 0xffffff,\n      transparent: true,\n      opacity: 1,\n      depthWrite: false,\n    });\n    const mesh = new THREE.Mesh(boxGeo, mat);\n    mesh.visible = false;\n    scene.add(mesh);\n\n    pool.push({\n      mesh,\n      active: false,\n      life: 0,\n      maxLife: 1,\n      vx: 0, vy: 0, vz: 0,\n      gravity: 0,\n      fadeOut: true,\n      material: mat,\n      baseScale: 1,\n    });\n  }\n\n  // Init arc decal pools\n  initArcDecals(scene);\n  initEnemyArcDecals(scene);\n\n  // Subscribe to events\n  wireEventBus();\n}\n\n// \u2500\u2500\u2500 Melee Arc Decal Pool \u2500\u2500\u2500\n\nconst ARC_DECAL_POOL_SIZE = 3;\nconst ARC_DECAL_LIFETIME = 0.25; // seconds\n\ninterface ArcDecal {\n  mesh: any;       // THREE.Mesh\n  active: boolean;\n  life: number;    // seconds elapsed\n}\n\nconst arcDecalPool: ArcDecal[] = [];\nlet arcDecalGeo: any = null;\n\nfunction initArcDecals(scene: any): void {\n  // CircleGeometry(radius, segments, thetaStart, thetaLength) creates a sector\n  // thetaStart is in the XY plane. After rotateX(-PI/2), XY\u2192XZ.\n  // Default arc center at thetaStart=0 points along +X. We offset by +PI/2\n  // so the arc center points along +Y (pre-rotation) = +Z (post-rotation),\n  // which aligns with Three.js rotation.y convention.\n  arcDecalGeo = new THREE.CircleGeometry(1, 24, Math.PI / 2 - MELEE.arc / 2, MELEE.arc);\n  arcDecalGeo.rotateX(-Math.PI / 2); // lay flat on ground\n\n  for (let i = 0; i < ARC_DECAL_POOL_SIZE; i++) {\n    const mat = new THREE.MeshBasicMaterial({\n      color: 0xffffff,\n      transparent: true,\n      opacity: 0,\n      side: THREE.DoubleSide,\n      depthWrite: false,\n    });\n    const mesh = new THREE.Mesh(arcDecalGeo, mat);\n    mesh.visible = false;\n    scene.add(mesh);\n\n    arcDecalPool.push({ mesh, active: false, life: 0 });\n  }\n}\n\nfunction spawnArcDecal(x: number, z: number, dirX: number, dirZ: number): void {\n  // Find inactive decal in pool\n  let decal: ArcDecal | null = null;\n  for (const d of arcDecalPool) {\n    if (!d.active) { decal = d; break; }\n  }\n  if (!decal) return; // pool exhausted\n\n  decal.active = true;\n  decal.life = 0;\n  decal.mesh.visible = true;\n  decal.mesh.position.set(x, 0.05, z);\n\n  // Scale to match current melee range\n  const r = MELEE.range;\n  decal.mesh.scale.set(r * 0.3, 1, r * 0.3); // start small, will grow\n\n  // Rotate to face swing direction\n  // direction = { -sin(angle), -cos(angle) } from player.ts\n  // Recover the original rotation.y angle: atan2(-dirX, -dirZ)\n  // Arc geometry is pre-rotated so its center aligns with +Z (rotation.y = 0)\n  decal.mesh.rotation.y = Math.atan2(-dirX, -dirZ);\n\n  decal.mesh.material.opacity = 0.4;\n}\n\nfunction updateArcDecals(dt: number): void {\n  for (const d of arcDecalPool) {\n    if (!d.active) continue;\n\n    d.life += dt;\n    if (d.life >= ARC_DECAL_LIFETIME) {\n      d.active = false;\n      d.mesh.visible = false;\n      continue;\n    }\n\n    const t = d.life / ARC_DECAL_LIFETIME;\n    // easeOutQuad\n    const ease = 1 - (1 - t) * (1 - t);\n\n    // Scale: 0.3 \u2192 1.0 of melee range\n    const r = MELEE.range;\n    const s = r * (0.3 + 0.7 * ease);\n    d.mesh.scale.set(s, 1, s);\n\n    // Opacity: 0.4 \u2192 0\n    d.mesh.material.opacity = 0.4 * (1 - ease);\n  }\n}\n\nfunction clearArcDecals(): void {\n  for (const d of arcDecalPool) {\n    d.active = false;\n    d.mesh.visible = false;\n  }\n}\n\n// \u2500\u2500\u2500 Enemy Telegraph Arc Decal Pool \u2500\u2500\u2500\n\nconst ENEMY_ARC_POOL_SIZE = 6;  // up to 6 simultaneous enemy telegraphs\n\ninterface EnemyArcDecal {\n  mesh: any;       // THREE.Mesh\n  active: boolean;\n  life: number;    // seconds elapsed\n  maxLife: number;  // total duration (telegraph + attack)\n}\n\nconst enemyArcPool: EnemyArcDecal[] = [];\n\nfunction initEnemyArcDecals(scene: any): void {\n  for (let i = 0; i < ENEMY_ARC_POOL_SIZE; i++) {\n    // Start with a placeholder geometry \u2014 replaced per-spawn with correct arc/range\n    const geo = new THREE.CircleGeometry(1, 24, 0, Math.PI);\n    geo.rotateX(-Math.PI / 2);\n    const mat = new THREE.MeshBasicMaterial({\n      color: 0xff4400,\n      transparent: true,\n      opacity: 0,\n      side: THREE.DoubleSide,\n      depthWrite: false,\n    });\n    const mesh = new THREE.Mesh(geo, mat);\n    mesh.visible = false;\n    scene.add(mesh);\n\n    enemyArcPool.push({ mesh, active: false, life: 0, maxLife: 1 });\n  }\n}\n\nfunction spawnEnemyArcDecal(x: number, z: number, facingAngle: number, hitArc: number, hitRange: number, durationMs: number): void {\n  // Find inactive decal in pool\n  let decal: EnemyArcDecal | null = null;\n  for (const d of enemyArcPool) {\n    if (!d.active) { decal = d; break; }\n  }\n  if (!decal) return;\n\n  // Replace geometry with correct arc shape for this enemy\n  // CircleGeometry arc is in XY plane, centered on +X axis\n  // Offset by PI/2 so arc center aligns with +Z (matches rotation.y convention)\n  const newGeo = new THREE.CircleGeometry(hitRange, 24, Math.PI / 2 - hitArc / 2, hitArc);\n  newGeo.rotateX(-Math.PI / 2);\n  decal.mesh.geometry.dispose();\n  decal.mesh.geometry = newGeo;\n\n  decal.active = true;\n  decal.life = 0;\n  decal.maxLife = durationMs / 1000;\n  decal.mesh.visible = true;\n  decal.mesh.position.set(x, 0.05, z);\n  decal.mesh.scale.set(1, 1, 1);\n  decal.mesh.rotation.set(0, facingAngle, 0);\n  decal.mesh.material.opacity = 0.35;\n}\n\nfunction updateEnemyArcDecals(dt: number): void {\n  for (const d of enemyArcPool) {\n    if (!d.active) continue;\n\n    d.life += dt;\n    if (d.life >= d.maxLife) {\n      d.active = false;\n      d.mesh.visible = false;\n      continue;\n    }\n\n    const t = d.life / d.maxLife;\n\n    // Pulsing opacity during telegraph, then fade in last 20%\n    if (t < 0.8) {\n      // Pulse between 0.2 and 0.35\n      const pulse = 0.275 + 0.075 * Math.sin(d.life * 12);\n      d.mesh.material.opacity = pulse;\n    } else {\n      // Fade out in last 20%\n      const fadeT = (t - 0.8) / 0.2;\n      d.mesh.material.opacity = 0.35 * (1 - fadeT);\n    }\n  }\n}\n\nfunction clearEnemyArcDecals(): void {\n  for (const d of enemyArcPool) {\n    d.active = false;\n    d.mesh.visible = false;\n  }\n}\n\n// \u2500\u2500\u2500 Burst API \u2500\u2500\u2500\n\nexport function burst(\n  position: { x: number; y?: number; z: number },\n  config: ParticleConfig,\n  direction?: { x: number; z: number }\n): void {\n  if (!sceneRef) return;\n\n  const y = position.y ?? 0.5; // default to waist height\n\n  for (let i = 0; i < config.count; i++) {\n    const p = acquireParticle();\n    if (!p) break; // pool exhausted\n\n    // Set geometry based on shape\n    p.mesh.geometry = config.shape === 'sphere' ? sphereGeo : boxGeo;\n\n    // Size\n    const s = config.size * (0.7 + Math.random() * 0.6); // slight variation\n    p.mesh.scale.set(s, s, s);\n    p.baseScale = s;\n\n    // Color\n    p.material.color.setHex(config.color);\n    p.material.opacity = 1;\n\n    // Position\n    p.mesh.position.set(\n      position.x + (Math.random() - 0.5) * 0.1,\n      y + (Math.random() - 0.5) * 0.1,\n      position.z + (Math.random() - 0.5) * 0.1\n    );\n\n    // Velocity \u2014 spread around direction (or random sphere)\n    let vx: number, vy: number, vz: number;\n    if (direction) {\n      // Spread around given direction\n      const angle = Math.atan2(direction.x, direction.z) + (Math.random() - 0.5) * config.spread;\n      const elevAngle = (Math.random() - 0.3) * config.spread * 0.5;\n      vx = Math.sin(angle) * Math.cos(elevAngle);\n      vy = Math.sin(elevAngle) + Math.random() * 0.3;\n      vz = Math.cos(angle) * Math.cos(elevAngle);\n    } else {\n      // Random sphere\n      const theta = Math.random() * Math.PI * 2;\n      const phi = Math.random() * config.spread;\n      vx = Math.sin(phi) * Math.cos(theta);\n      vy = Math.cos(phi) * 0.5 + Math.random() * 0.5;\n      vz = Math.sin(phi) * Math.sin(theta);\n    }\n\n    const speed = config.speed * (0.6 + Math.random() * 0.8);\n    p.vx = vx * speed;\n    p.vy = vy * speed;\n    p.vz = vz * speed;\n\n    p.gravity = config.gravity;\n    p.fadeOut = config.fadeOut;\n    p.life = 0;\n    p.maxLife = config.lifetime * (0.7 + Math.random() * 0.6);\n    p.active = true;\n    p.mesh.visible = true;\n  }\n}\n\n// \u2500\u2500\u2500 Update \u2500\u2500\u2500\n\nexport function updateParticles(dt: number): void {\n  updateArcDecals(dt);\n  updateEnemyArcDecals(dt);\n\n  for (const p of pool) {\n    if (!p.active) continue;\n\n    p.life += dt;\n    if (p.life >= p.maxLife) {\n      p.active = false;\n      p.mesh.visible = false;\n      continue;\n    }\n\n    // Physics\n    p.vy -= p.gravity * dt;\n    p.mesh.position.x += p.vx * dt;\n    p.mesh.position.y += p.vy * dt;\n    p.mesh.position.z += p.vz * dt;\n\n    // Floor collision\n    if (p.mesh.position.y < 0.02) {\n      p.mesh.position.y = 0.02;\n      p.vy = 0;\n      p.vx *= 0.8; // friction\n      p.vz *= 0.8;\n    }\n\n    // Fade\n    if (p.fadeOut) {\n      const t = p.life / p.maxLife;\n      p.material.opacity = 1 - t * t; // quadratic fade\n    }\n\n    // Shrink slightly near end of life (absolute, not cumulative)\n    const lifeRatio = p.life / p.maxLife;\n    if (lifeRatio > 0.7) {\n      const shrink = 1 - (lifeRatio - 0.7) / 0.3;\n      p.mesh.scale.setScalar(p.baseScale * shrink);\n    }\n  }\n}\n\n// \u2500\u2500\u2500 Pool Management \u2500\u2500\u2500\n\nfunction acquireParticle(): Particle | null {\n  for (const p of pool) {\n    if (!p.active) return p;\n  }\n  return null; // pool exhausted \u2014 just skip\n}\n\nexport function clearParticles(): void {\n  for (const p of pool) {\n    p.active = false;\n    p.mesh.visible = false;\n  }\n  clearArcDecals();\n  clearEnemyArcDecals();\n}\n\n// \u2500\u2500\u2500 Event Bus Integration \u2500\u2500\u2500\n\nfunction wireEventBus(): void {\n  on('enemyHit', (e: GameEvent) => {\n    if (e.type === 'enemyHit') {\n      burst(\n        { x: e.position.x, y: 0.5, z: e.position.z },\n        HIT_SPARK\n      );\n    }\n  });\n\n  on('enemyDied', (e: GameEvent) => {\n    if (e.type === 'enemyDied') {\n      // Use enemy color for death puff\n      const color = e.enemy.config?.color ?? DEATH_PUFF.color;\n      burst(\n        { x: e.position.x, y: 0.4, z: e.position.z },\n        { ...DEATH_PUFF, color }\n      );\n    }\n  });\n\n  on('playerDash', (e: GameEvent) => {\n    if (e.type === 'playerDash') {\n      burst(\n        { x: e.position.x, y: 0.4, z: e.position.z },\n        DASH_TRAIL,\n        { x: -e.direction.x, z: -e.direction.z }\n      );\n    }\n  });\n\n  on('shieldBreak', (e: GameEvent) => {\n    if (e.type === 'shieldBreak') {\n      burst(\n        { x: e.position.x, y: 0.6, z: e.position.z },\n        SHIELD_BREAK_BURST\n      );\n    }\n  });\n\n  on('chargeFired', (e: GameEvent) => {\n    if (e.type === 'chargeFired') {\n      burst(\n        { x: e.position.x, y: 0.5, z: e.position.z },\n        { ...CHARGE_BLAST, count: Math.round(6 + e.chargeT * 6) },\n        { x: e.direction.x, z: e.direction.z }\n      );\n    }\n  });\n\n  on('enemyPushed', (e: GameEvent) => {\n    if (e.type === 'enemyPushed') {\n      burst(\n        { x: e.position.x, y: 0.3, z: e.position.z },\n        PUSH_BURST\n      );\n    }\n  });\n\n  on('meleeSwing', (e: GameEvent) => {\n    if (e.type === 'meleeSwing') {\n      burst(\n        { x: e.position.x, y: 0.6, z: e.position.z },\n        { ...DASH_TRAIL, count: 2, speed: 3, lifetime: 0.15, color: 0xffffff },\n        { x: e.direction.x, z: e.direction.z }\n      );\n      // Ground arc decal showing melee hit area\n      spawnArcDecal(e.position.x, e.position.z, e.direction.x, e.direction.z);\n    }\n  });\n\n  on('wallSlam', (e: GameEvent) => {\n    if (e.type === 'wallSlam') {\n      burst(\n        { x: e.position.x, y: 0.3, z: e.position.z },\n        { ...WALL_SLAM_SPARK, count: Math.round(4 + (e.speed / 5) * 4) }\n      );\n    }\n  });\n\n  on('enemyImpact', (e: GameEvent) => {\n    if (e.type === 'enemyImpact') {\n      burst(\n        { x: e.position.x, y: 0.4, z: e.position.z },\n        { ...ENEMY_IMPACT_SPARK, count: Math.round(3 + (e.speed / 5) * 3) }\n      );\n    }\n  });\n\n  on('enemyMeleeTelegraph', (e: GameEvent) => {\n    if (e.type === 'enemyMeleeTelegraph') {\n      spawnEnemyArcDecal(\n        e.position.x, e.position.z,\n        e.facingAngle, e.hitArc, e.hitRange,\n        e.duration\n      );\n    }\n  });\n\n  on('doorUnlocked', (e: GameEvent) => {\n    if (e.type === 'doorUnlocked') {\n      // Burst particles at the door location (top of far wall)\n      // We don't have the exact position here, so emit upward from center-far\n      burst({ x: 0, y: 2, z: 0 }, DOOR_UNLOCK_BURST);\n    }\n  });\n\n  // \u2500\u2500\u2500 Vertical Combat Events \u2500\u2500\u2500\n\n  on('playerJump', (e: GameEvent) => {\n    if (e.type === 'playerJump') {\n      burst({ x: e.position.x, y: 0.1, z: e.position.z }, JUMP_DUST);\n    }\n  });\n\n  on('playerLand', (e: GameEvent) => {\n    if (e.type === 'playerLand') {\n      const intensity = Math.min(e.fallSpeed / 10, 2);\n      burst(\n        { x: e.position.x, y: 0.1, z: e.position.z },\n        { ...LAND_DUST, count: Math.round(3 + intensity * 4) }\n      );\n    }\n  });\n\n  on('enemyLaunched', (e: GameEvent) => {\n    if (e.type === 'enemyLaunched') {\n      burst(\n        { x: e.position.x, y: 0.3, z: e.position.z },\n        LAUNCH_BURST\n      );\n    }\n  });\n\n  on('aerialStrike', (e: GameEvent) => {\n    if (e.type === 'aerialStrike') {\n      burst(\n        { x: e.position.x, y: 0.5, z: e.position.z },\n        AERIAL_SPIKE\n      );\n    }\n  });\n\n  on('playerSlam', (e: GameEvent) => {\n    if (e.type === 'playerSlam') {\n      burst(\n        { x: e.position.x, y: 0.1, z: e.position.z },\n        { ...SLAM_IMPACT, count: Math.round(8 + (e.fallSpeed / 15) * 4) }\n      );\n    }\n  });\n\n  on('dunkGrab', (e: GameEvent) => {\n    if (e.type === 'dunkGrab') {\n      burst(\n        { x: e.position.x, y: 0.8, z: e.position.z },\n        DUNK_GRAB_SPARK\n      );\n    }\n  });\n\n  on('dunkImpact', (e: GameEvent) => {\n    if (e.type === 'dunkImpact') {\n      burst(\n        { x: e.position.x, y: 0.1, z: e.position.z },\n        DUNK_IMPACT_BURST\n      );\n    }\n  });\n}\n", "// Telegraph system \u2014 visual warnings before enemies spawn\n// Ground ring + fill circle + type indicator per spawn point\n\nimport { ENEMY_TYPES } from '../config/enemies';\n\nlet sceneRef: any;\n\n// Shared geometries (created once, reused across all telegraphs)\nlet ringGeo: any, fillGeo: any;\nconst typeGeos: Record<string, any> = {};  // keyed by enemy type name\n\n// Type indicator shapes\nconst TYPE_LABELS: Record<string, string> = {\n  goblin: 'G',\n  skeletonArcher: 'A',\n  stoneGolem: 'T',\n  iceMortarImp: 'I',\n};\n\nexport function initTelegraph(scene: any) {\n  sceneRef = scene;\n\n  // Ring: inner 0.6, outer 0.8, flat on ground\n  ringGeo = new THREE.RingGeometry(0.6, 0.8, 24);\n  ringGeo.rotateX(-Math.PI / 2);\n\n  // Fill circle: radius 0.6\n  fillGeo = new THREE.CircleGeometry(0.6, 24);\n  fillGeo.rotateX(-Math.PI / 2);\n\n  // Type indicators \u2014 small shapes\n  // Goblin: triangle (cone 3 sides)\n  typeGeos.goblin = new THREE.ConeGeometry(0.2, 0.4, 3);\n  // Archer: diamond (box rotated)\n  typeGeos.skeletonArcher = new THREE.BoxGeometry(0.25, 0.25, 0.25);\n  // Golem: hexagon (cylinder 6 sides, flat)\n  typeGeos.stoneGolem = new THREE.CylinderGeometry(0.25, 0.25, 0.1, 6);\n  // Imp: sphere (mortar projectile shape)\n  typeGeos.iceMortarImp = new THREE.SphereGeometry(0.2, 8, 8);\n}\n\nexport function createTelegraph(x: number, z: number, typeName: string) {\n  const color = ENEMY_TYPES[typeName] ? ENEMY_TYPES[typeName].color : 0xffffff;\n  const group = new THREE.Group();\n  group.position.set(x, 0, z);\n\n  // Ground ring\n  const ringMat = new THREE.MeshBasicMaterial({\n    color: color,\n    transparent: true,\n    opacity: 0.6,\n    side: THREE.DoubleSide,\n    depthWrite: false,\n  });\n  const ring = new THREE.Mesh(ringGeo, ringMat);\n  ring.position.y = 0.03;\n  group.add(ring);\n\n  // Fill circle\n  const fillMat = new THREE.MeshBasicMaterial({\n    color: color,\n    transparent: true,\n    opacity: 0,\n    side: THREE.DoubleSide,\n    depthWrite: false,\n  });\n  const fill = new THREE.Mesh(fillGeo, fillMat);\n  fill.position.y = 0.02;\n  group.add(fill);\n\n  // Type indicator \u2014 floating shape\n  const typeGeo = typeGeos[typeName] || typeGeos.goblin;\n  const typeMat = new THREE.MeshStandardMaterial({\n    color: color,\n    emissive: color,\n    emissiveIntensity: 0.6,\n    transparent: true,\n    opacity: 0.8,\n  });\n  const typeIndicator = new THREE.Mesh(typeGeo, typeMat);\n  typeIndicator.position.y = 1.2;\n  if (typeName === 'skeletonArcher') {\n    typeIndicator.rotation.y = Math.PI / 4; // diamond rotation\n  }\n  group.add(typeIndicator);\n\n  sceneRef.add(group);\n\n  return {\n    group,\n    ring,\n    ringMat,\n    fill,\n    fillMat,\n    typeIndicator,\n    typeMat,\n    baseColor: color,\n    time: 0,\n  };\n}\n\n// progress: 0 = just appeared, 1 = about to spawn\nexport function updateTelegraph(telegraph: any, progress: number, dt: number) {\n  telegraph.time += dt;\n\n  // Fill circle: opacity ramps up with progress\n  telegraph.fillMat.opacity = progress * 0.4;\n\n  // Ring: pulse frequency increases with progress (2Hz \u2192 10Hz)\n  const freq = 2 + progress * 8;\n  const pulse = 0.5 + 0.5 * Math.sin(telegraph.time * freq * Math.PI * 2);\n\n  // Ring opacity: base 0.3 + pulse\n  telegraph.ringMat.opacity = 0.3 + pulse * 0.5;\n\n  // Ring scale: gentle breathing\n  const scale = 1.0 + 0.1 * Math.sin(telegraph.time * freq * Math.PI * 2);\n  telegraph.ring.scale.set(scale, 1, scale);\n\n  // Flash white when close to spawning (>80%)\n  if (progress > 0.8) {\n    const flash = Math.sin(telegraph.time * 20) > 0.5;\n    telegraph.ringMat.color.setHex(flash ? 0xffffff : telegraph.baseColor);\n    telegraph.fillMat.color.setHex(flash ? 0xffffff : telegraph.baseColor);\n  }\n\n  // Type indicator: gentle bob\n  telegraph.typeIndicator.position.y = 1.2 + 0.15 * Math.sin(telegraph.time * 2);\n  telegraph.typeIndicator.rotation.y += dt * 1.5;\n}\n\nexport function removeTelegraph(telegraph: any) {\n  if (telegraph.group.parent) {\n    sceneRef.remove(telegraph.group);\n  }\n  // Dispose cloned materials\n  telegraph.ringMat.dispose();\n  telegraph.fillMat.dispose();\n  telegraph.typeMat.dispose();\n}\n", "// Room Highlights \u2014 brief pulse on key arena features when entering a room\n// Spawns glowing outlines + vertical corner pillars + gradient wall planes\n// Reusable: pits (Foundation), obstacles/rocks (rule-bending), platforms (vertical)\n\nimport { getScene } from './renderer';\nimport { PITS, OBSTACLES } from '../config/arena';\nimport { HEIGHT_ZONES } from '../config/terrain';\nimport type { RoomHighlight } from '../config/rooms';\n\nconst DEFAULT_DELAY = 800;\nconst DEFAULT_DURATION = 2000;\nconst PILLAR_HEIGHT = 1.25;\nconst PILLAR_THICKNESS = 0.04;\n\n// Active state (cleared on new room load)\nlet activeTimers: number[] = [];\nlet activeRafs: number[] = [];\nlet activeMeshes: any[] = [];\n\nexport function clearHighlights() {\n  for (const id of activeTimers) clearTimeout(id);\n  activeTimers = [];\n  for (const id of activeRafs) cancelAnimationFrame(id);\n  activeRafs = [];\n  const scene = getScene();\n  for (const obj of activeMeshes) {\n    scene.remove(obj);\n    if (obj.geometry) obj.geometry.dispose();\n    if (obj.material) obj.material.dispose();\n  }\n  activeMeshes = [];\n}\n\nexport function triggerRoomHighlights(highlights: RoomHighlight[]) {\n  clearHighlights();\n\n  for (const hl of highlights) {\n    const delay = hl.delay ?? DEFAULT_DELAY;\n    const duration = hl.duration ?? DEFAULT_DURATION;\n\n    const timerId = window.setTimeout(() => {\n      const rects = getRectsForTarget(hl.target, hl.color);\n      for (const rect of rects) {\n        spawnHighlight(rect, duration);\n      }\n    }, delay);\n\n    activeTimers.push(timerId);\n  }\n}\n\ninterface HighlightRect {\n  x: number;\n  z: number;\n  w: number;\n  d: number;\n  color: number;\n  y?: number;  // base elevation (default 0)\n}\n\n// Default colors per target type\nconst TARGET_COLORS: Record<string, number> = {\n  pits: 0xff4466,\n  obstacles: 0x6688ff,\n  platforms: 0x4488ff,\n};\n\nfunction getRectsForTarget(target: string, colorOverride?: number): HighlightRect[] {\n  const color = colorOverride ?? TARGET_COLORS[target] ?? 0xffffff;\n  switch (target) {\n    case 'pits':\n      return PITS.map(p => ({ x: p.x, z: p.z, w: p.w, d: p.d, color }));\n    case 'obstacles':\n      return OBSTACLES.map(o => ({ x: o.x, z: o.z, w: o.w, d: o.d, color }));\n    case 'platforms':\n      return HEIGHT_ZONES.map(hz => ({ x: hz.x, z: hz.z, w: hz.w, d: hz.d, color }));\n    default:\n      return [];\n  }\n}\n\nfunction spawnHighlight(rect: HighlightRect, duration: number) {\n  const scene = getScene();\n  const allParts: any[] = [];\n  const baseY = rect.y ?? 0;\n\n  // --- Base outline (flat on ground / platform surface) ---\n  const margin = 0.3;\n  const planeGeo = new THREE.PlaneGeometry(rect.w + margin, rect.d + margin);\n  const edgesGeo = new THREE.EdgesGeometry(planeGeo);\n  planeGeo.dispose();\n\n  const baseMat = new THREE.LineBasicMaterial({\n    color: rect.color,\n    transparent: true,\n    opacity: 0,\n    depthWrite: false,\n  });\n  const baseRing = new THREE.LineSegments(edgesGeo, baseMat);\n  baseRing.rotation.x = -Math.PI / 2;\n  baseRing.position.set(rect.x, baseY + 0.06, rect.z);\n  scene.add(baseRing);\n  allParts.push(baseRing);\n\n  // --- Vertical corner pillars ---\n  const hw = rect.w / 2;\n  const hd = rect.d / 2;\n  const corners = [\n    { x: rect.x - hw, z: rect.z - hd },\n    { x: rect.x + hw, z: rect.z - hd },\n    { x: rect.x + hw, z: rect.z + hd },\n    { x: rect.x - hw, z: rect.z + hd },\n  ];\n\n  const pillarGeo = new THREE.BoxGeometry(PILLAR_THICKNESS, PILLAR_HEIGHT, PILLAR_THICKNESS);\n  const pillars: any[] = [];\n\n  for (const corner of corners) {\n    const pillarMat = new THREE.MeshBasicMaterial({\n      color: rect.color,\n      transparent: true,\n      opacity: 0,\n      depthWrite: false,\n    });\n    const pillar = new THREE.Mesh(pillarGeo, pillarMat);\n    pillar.position.set(corner.x, baseY + PILLAR_HEIGHT / 2, corner.z);\n    scene.add(pillar);\n    allParts.push(pillar);\n    pillars.push(pillar);\n  }\n\n  // --- Gradient glow wall planes between pillars ---\n  // 4 walls: connect adjacent corners (0\u21921, 1\u21922, 2\u21923, 3\u21920)\n  const wallPlanes: any[] = [];\n\n  for (let i = 0; i < 4; i++) {\n    const c0 = corners[i];\n    const c1 = corners[(i + 1) % 4];\n\n    // Wall width = distance between corners\n    const dx = c1.x - c0.x;\n    const dz = c1.z - c0.z;\n    const wallWidth = Math.sqrt(dx * dx + dz * dz);\n\n    // PlaneGeometry: width \u00D7 height, with 1\u00D78 segments for vertical gradient\n    const wallGeo = new THREE.PlaneGeometry(wallWidth, PILLAR_HEIGHT, 1, 8);\n\n    // Apply vertical alpha gradient: full opacity at bottom, fading to 0 at top\n    const posAttr = wallGeo.getAttribute('position');\n    const colors = new Float32Array(posAttr.count * 4);\n    const r = ((rect.color >> 16) & 0xff) / 255;\n    const g = ((rect.color >> 8) & 0xff) / 255;\n    const b = (rect.color & 0xff) / 255;\n\n    for (let v = 0; v < posAttr.count; v++) {\n      const y = posAttr.getY(v);\n      // y ranges from -PILLAR_HEIGHT/2 (bottom) to +PILLAR_HEIGHT/2 (top)\n      const normalizedY = (y + PILLAR_HEIGHT / 2) / PILLAR_HEIGHT; // 0 at bottom, 1 at top\n      const vertAlpha = 1 - normalizedY * normalizedY; // quadratic falloff toward top\n      colors[v * 4] = r;\n      colors[v * 4 + 1] = g;\n      colors[v * 4 + 2] = b;\n      colors[v * 4 + 3] = vertAlpha;\n    }\n    wallGeo.setAttribute('color', new THREE.BufferAttribute(colors, 4));\n\n    const wallMat = new THREE.MeshBasicMaterial({\n      vertexColors: true,\n      transparent: true,\n      opacity: 0,\n      depthWrite: false,\n      side: THREE.DoubleSide,\n    });\n\n    const wallMesh = new THREE.Mesh(wallGeo, wallMat);\n\n    // Position at midpoint between corners, at half pillar height\n    wallMesh.position.set(\n      (c0.x + c1.x) / 2,\n      baseY + PILLAR_HEIGHT / 2,\n      (c0.z + c1.z) / 2,\n    );\n\n    // Rotate so plane width (X-axis) aligns with wall direction (dx, dz)\n    // PlaneGeometry width is along X; rotation.y maps X \u2192 (cos\u03B8, 0, -sin\u03B8)\n    // We need cos\u03B8 = dx/len, -sin\u03B8 = dz/len \u2192 \u03B8 = atan2(-dz, dx)\n    wallMesh.rotation.y = Math.atan2(-dz, dx);\n\n    scene.add(wallMesh);\n    allParts.push(wallMesh);\n    wallPlanes.push(wallMesh);\n  }\n\n  // Track for cleanup\n  activeMeshes.push(...allParts);\n\n  // --- Animate ---\n  const startTime = performance.now();\n\n  function animate() {\n    const elapsed = performance.now() - startTime;\n    const t = Math.min(elapsed / duration, 1);\n\n    // Alpha envelope: ramp up 0-10%, hold 10-45%, fade out 45-100%\n    let alpha: number;\n    if (t < 0.1) {\n      alpha = t / 0.1;\n    } else if (t < 0.45) {\n      alpha = 1;\n    } else {\n      alpha = 1 - ((t - 0.45) / 0.55);\n    }\n    alpha = Math.max(0, alpha);\n\n    // Base outline\n    baseMat.opacity = alpha * 0.9;\n\n    // Pillars + walls: rise up from ground, then sink back down\n    // Height envelope: grow 0-15%, full 15-50%, shrink 50-100%\n    let heightT: number;\n    if (t < 0.15) {\n      heightT = t / 0.15;\n    } else if (t < 0.5) {\n      heightT = 1;\n    } else {\n      heightT = 1 - ((t - 0.5) / 0.5);\n    }\n    heightT = Math.max(0, heightT);\n    // Ease out for smooth feel\n    const easedHeight = 1 - (1 - heightT) * (1 - heightT);\n\n    for (const pillar of pillars) {\n      pillar.material.opacity = alpha * 0.7;\n      pillar.scale.y = Math.max(0.01, easedHeight);\n      pillar.position.y = baseY + (PILLAR_HEIGHT * easedHeight) / 2;\n    }\n\n    // Wall planes scale + fade with pillars\n    for (const wall of wallPlanes) {\n      wall.material.opacity = alpha * 0.35;\n      wall.scale.y = Math.max(0.01, easedHeight);\n      wall.position.y = baseY + (PILLAR_HEIGHT * easedHeight) / 2;\n    }\n\n    if (t < 1) {\n      const rafId = requestAnimationFrame(animate);\n      activeRafs.push(rafId);\n    } else {\n      // Cleanup\n      for (const part of allParts) {\n        scene.remove(part);\n        if (part.geometry) part.geometry.dispose();\n        if (part.material) part.material.dispose();\n      }\n      edgesGeo.dispose();\n      pillarGeo.dispose();\n      for (const part of allParts) {\n        const idx = activeMeshes.indexOf(part);\n        if (idx >= 0) activeMeshes.splice(idx, 1);\n      }\n    }\n  }\n\n  const rafId = requestAnimationFrame(animate);\n  activeRafs.push(rafId);\n}\n", "// Door config \u2014 tunable at runtime via tuning panel\n\nexport const DOOR_CONFIG = {\n  unlockDuration: 1000,    // ms \u2014 door unlock animation duration\n  interactRadius: 3.5,     // units \u2014 proximity for showing prompt (deprecated: walkthrough replaces interact)\n  walkthroughHalfX: 1.5,   // units \u2014 half-width of walkthrough volume (inside door frame pillars at \u00B12)\n  walkthroughHalfZ: 1.0,   // units \u2014 half-depth of walkthrough volume (thin strip crossing threshold)\n  restPause: 2000,         // ms \u2014 how long before rest room door opens\n};\n", "// Door System \u2014 visual door at the far end of each room (-Z wall)\n// States: locked \u2192 unlocking \u2192 open\n// Player walks through the open door to enter next room (tight AABB collision volume)\n\nimport { DOOR_CONFIG } from '../config/door';\nimport { emit } from './events';\n\n// Door state\ntype DoorState = 'locked' | 'unlocking' | 'open' | 'none';\n\nlet doorState: DoorState = 'none';\nlet doorGroup: any = null;\nlet doorFrameMesh: any = null;\nlet doorPanelMesh: any = null;\nlet doorGlowMesh: any = null;\nlet doorAnimTimer = 0;\nlet doorRoomIndex = 0;\nlet sceneRef: any = null;\n\n// Door position (centered on far wall at -Z)\nlet doorX = 0;\nlet doorZ = 0;\n\n// Prompt UI element\nlet promptEl: HTMLElement | null = null;\nlet promptVisible = false;\n\nexport function initDoor(scene: any) {\n  sceneRef = scene;\n\n  // Create or find the door prompt element\n  promptEl = document.getElementById('door-prompt');\n  if (!promptEl) {\n    promptEl = document.createElement('div');\n    promptEl.id = 'door-prompt';\n    promptEl.style.cssText = `\n      position: fixed;\n      bottom: 25%;\n      left: 50%;\n      transform: translateX(-50%);\n      color: #88bbff;\n      font-family: 'Courier New', monospace;\n      font-size: 16px;\n      font-weight: bold;\n      text-align: center;\n      pointer-events: none;\n      opacity: 0;\n      transition: opacity 0.2s ease;\n      text-shadow: 0 0 10px rgba(136, 187, 255, 0.6);\n      z-index: 50;\n    `;\n    promptEl.textContent = 'Next Room \u2192';\n    document.body.appendChild(promptEl);\n  }\n}\n\nexport function createDoor(arenaHalfX: number, arenaHalfZ: number, roomIndex: number) {\n  removeDoor();\n\n  doorState = 'locked';\n  doorRoomIndex = roomIndex;\n  doorAnimTimer = 0;\n\n  // Door is centered near the far wall (-Z = top-right in iso)\n  // Offset 1 unit inward so the door frame is visible in front of the wall\n  doorX = 0;\n  doorZ = -arenaHalfZ + 1;\n\n  doorGroup = new THREE.Group();\n  doorGroup.position.set(doorX, 0, doorZ);\n\n  // Door frame \u2014 two pillars and a lintel (contrasting color from arena walls)\n  const frameMat = new THREE.MeshStandardMaterial({\n    color: 0x4a4a6a,\n    emissive: 0x4466aa,\n    emissiveIntensity: 0.5,\n    roughness: 0.5,\n  });\n\n  // Left pillar \u2014 thicker and taller than walls so it reads as a doorway\n  const leftPillar = new THREE.Mesh(\n    new THREE.BoxGeometry(0.6, 4, 0.6),\n    frameMat\n  );\n  leftPillar.position.set(-2, 2, 0);\n  doorGroup.add(leftPillar);\n\n  // Right pillar\n  const rightPillar = new THREE.Mesh(\n    new THREE.BoxGeometry(0.6, 4, 0.6),\n    frameMat\n  );\n  rightPillar.position.set(2, 2, 0);\n  doorGroup.add(rightPillar);\n\n  // Lintel (top bar)\n  const lintel = new THREE.Mesh(\n    new THREE.BoxGeometry(4.6, 0.5, 0.6),\n    frameMat\n  );\n  lintel.position.set(0, 4.25, 0);\n  doorGroup.add(lintel);\n\n  doorFrameMesh = doorGroup; // for reference\n\n  // Door panel \u2014 the part that animates (wider to fill frame)\n  const panelMat = new THREE.MeshStandardMaterial({\n    color: 0x1a1a2e,\n    emissive: 0x334466,\n    emissiveIntensity: 0.2,\n    transparent: true,\n    opacity: 0.9,\n    roughness: 0.5,\n  });\n  doorPanelMesh = new THREE.Mesh(\n    new THREE.BoxGeometry(3.4, 3.6, 0.25),\n    panelMat\n  );\n  doorPanelMesh.position.set(0, 1.8, 0);\n  doorGroup.add(doorPanelMesh);\n\n  // Glow plane \u2014 behind the door, visible when open (on the +Z side facing player)\n  const glowMat = new THREE.MeshBasicMaterial({\n    color: 0x88bbff,\n    transparent: true,\n    opacity: 0,\n    side: THREE.DoubleSide,\n  });\n  doorGlowMesh = new THREE.Mesh(\n    new THREE.PlaneGeometry(3.4, 3.6),\n    glowMat\n  );\n  doorGlowMesh.position.set(0, 1.8, 0.2); // glow on the +Z side (facing player approach)\n  doorGroup.add(doorGlowMesh);\n\n  sceneRef.add(doorGroup);\n}\n\nexport function unlockDoor() {\n  if (doorState !== 'locked') return;\n  doorState = 'unlocking';\n  doorAnimTimer = 0;\n}\n\n/**\n * Update door state and check for walkthrough or interact.\n * @returns true if the player entered the door (trigger room transition)\n */\nexport function updateDoor(dt: number, playerPos: any, interact?: boolean): boolean {\n  if (doorState === 'none' || !doorGroup) return false;\n\n  if (doorState === 'unlocking') {\n    doorAnimTimer += dt * 1000;\n    const progress = Math.min(doorAnimTimer / DOOR_CONFIG.unlockDuration, 1);\n\n    // Door panel slides up\n    doorPanelMesh.position.y = 1.8 + progress * 4;\n    doorPanelMesh.material.opacity = 0.9 * (1 - progress);\n\n    // Glow appears\n    doorGlowMesh.material.opacity = progress * 0.6;\n\n    // Frame emissive ramps up\n    doorGroup.children.forEach((child: any) => {\n      if (child.material && child !== doorPanelMesh && child !== doorGlowMesh) {\n        child.material.emissiveIntensity = 0.5 + progress * 0.8;\n      }\n    });\n\n    if (progress >= 1) {\n      doorState = 'open';\n      emit({ type: 'doorUnlocked', roomIndex: doorRoomIndex });\n    }\n  }\n\n  if (doorState === 'open') {\n    // Pulsing glow\n    doorAnimTimer += dt * 1000;\n    const pulse = 0.4 + 0.2 * Math.sin(doorAnimTimer * 0.003 * Math.PI * 2);\n    doorGlowMesh.material.opacity = pulse;\n\n    // Walkthrough collision volume \u2014 tight AABB inside the door frame\n    if (playerPos) {\n      const dx = Math.abs(playerPos.x - doorX);\n      const dz = Math.abs(playerPos.z - doorZ);\n      const insideDoor = dx < DOOR_CONFIG.walkthroughHalfX && dz < DOOR_CONFIG.walkthroughHalfZ;\n\n      // Show prompt when nearby (larger radius), enter when inside door frame\n      const nearDoor = dx < DOOR_CONFIG.walkthroughHalfX + 1.5 && dz < DOOR_CONFIG.walkthroughHalfZ + 2;\n\n      if (insideDoor || (nearDoor && interact)) {\n        hidePrompt();\n        emit({ type: 'doorEntered', roomIndex: doorRoomIndex });\n        doorState = 'none';\n        return true; // trigger room transition\n      } else if (nearDoor) {\n        showPrompt();\n      } else {\n        hidePrompt();\n      }\n    }\n  } else {\n    hidePrompt();\n  }\n\n  return false;\n}\n\nfunction showPrompt() {\n  if (promptEl && !promptVisible) {\n    promptVisible = true;\n    promptEl.style.opacity = '1';\n  }\n}\n\nfunction hidePrompt() {\n  if (promptEl && promptVisible) {\n    promptVisible = false;\n    promptEl.style.opacity = '0';\n  }\n}\n\nexport function removeDoor() {\n  hidePrompt();\n  if (doorGroup && sceneRef) {\n    sceneRef.remove(doorGroup);\n    // Dispose geometries and materials\n    doorGroup.traverse((child: any) => {\n      if (child.geometry) child.geometry.dispose();\n      if (child.material) child.material.dispose();\n    });\n  }\n  doorGroup = null;\n  doorPanelMesh = null;\n  doorGlowMesh = null;\n  doorFrameMesh = null;\n  doorState = 'none';\n}\n\nexport function getDoorState(): DoorState {\n  return doorState;\n}\n\nexport function isDoorOpen(): boolean {\n  return doorState === 'open';\n}\n", "import { PhysicsObject, PhysicsObjectPlacement } from '../types/index';\n\nlet nextId = 1;\n\nexport function resetPhysicsObjectIds(): void {\n  nextId = 1;\n}\n\nexport function createPhysicsObject(placement: PhysicsObjectPlacement): PhysicsObject {\n  return {\n    id: nextId++,\n    pos: { x: placement.x, z: placement.z },\n    vel: { x: 0, z: 0 },\n    radius: placement.radius,\n    mass: placement.mass,\n    health: placement.health,\n    maxHealth: placement.health,\n    material: placement.material,\n    meshType: placement.meshType,\n    scale: placement.scale ?? 1,\n    restitution: undefined,\n    mesh: null,\n    destroyed: false,\n    fellInPit: false,\n    suspended: placement.suspended ?? false,\n    suspendHeight: placement.suspendHeight ?? 0,\n    tetherMesh: null,\n  };\n}\n\n// \u2500\u2500\u2500 Mesh Creation \u2500\u2500\u2500\n\nconst MATERIAL_COLORS: Record<string, { color: number; emissive: number }> = {\n  stone: { color: 0x888899, emissive: 0x334455 },\n  wood:  { color: 0x8B6914, emissive: 0x443322 },\n  metal: { color: 0xaaaacc, emissive: 0x556677 },\n  ice:   { color: 0x88ccff, emissive: 0x4488aa },\n};\n\nexport function createPhysicsObjectMesh(obj: PhysicsObject, scene: any): void {\n  const group = new THREE.Group();\n  const colors = MATERIAL_COLORS[obj.material] || MATERIAL_COLORS.stone;\n  const mat = new THREE.MeshStandardMaterial({\n    color: colors.color,\n    emissive: colors.emissive,\n    emissiveIntensity: 0.3,\n    roughness: 0.7,\n  });\n\n  let geo;\n  switch (obj.meshType) {\n    case 'rock':\n      geo = new THREE.SphereGeometry(obj.radius * obj.scale, 8, 6);\n      break;\n    case 'crate': {\n      // Squat cylinder with 6 sides \u2014 reads as a chunky crate/drum shape\n      // while having a circular footprint that exactly matches circle collision.\n      // No corner-beyond-radius mismatch possible.\n      const r = obj.radius * obj.scale;\n      geo = new THREE.CylinderGeometry(r, r, r * 1.4, 6);\n      break;\n    }\n    case 'barrel':\n      // Max ground-plane radius = bottom radius = obj.radius * obj.scale\n      geo = new THREE.CylinderGeometry(\n        obj.radius * obj.scale * 0.8,\n        obj.radius * obj.scale,\n        obj.radius * obj.scale * 1.5,\n        8\n      );\n      break;\n    case 'pillar':\n      // Max ground-plane radius = bottom radius = obj.radius * obj.scale\n      geo = new THREE.CylinderGeometry(\n        obj.radius * obj.scale * 0.6,\n        obj.radius * obj.scale,\n        obj.radius * obj.scale * 2.5,\n        6\n      );\n      break;\n  }\n\n  const mesh = new THREE.Mesh(geo, mat);\n  mesh.position.y = obj.radius * obj.scale * 0.5; // sit on ground\n  group.add(mesh);\n\n  group.position.set(obj.pos.x, 0, obj.pos.z);\n  // Store the base geometry size so bend visuals can scale relative to it\n  group.userData._baseGeoSize = obj.radius * obj.scale;\n  scene.add(group);\n  obj.mesh = group;\n\n  // Suspended objects float at height with a tether line\n  if (obj.suspended && obj.suspendHeight > 0) {\n    group.position.y = obj.suspendHeight;\n\n    // Glowing tether line from rock down to ground\n    const tetherGeo = new THREE.CylinderGeometry(0.03, 0.03, obj.suspendHeight, 4);\n    const tetherMat = new THREE.MeshBasicMaterial({\n      color: 0x88bbff,\n      transparent: true,\n      opacity: 0.6,\n    });\n    const tether = new THREE.Mesh(tetherGeo, tetherMat);\n    tether.position.set(obj.pos.x, obj.suspendHeight / 2, obj.pos.z);\n    scene.add(tether);\n    obj.tetherMesh = tether;\n  }\n}\n\nexport function applyBendVisuals(obj: PhysicsObject, tintColor: number): void {\n  if (!obj.mesh) return;\n  // Scale mesh so visual matches collision radius.\n  // Geometry was built at baseGeoSize = originalRadius * originalScale.\n  // We want the visual to reflect the new radius.\n  const base = obj.mesh.userData._baseGeoSize || 1;\n  const s = obj.radius / base;\n  obj.mesh.scale.set(s, s, s);\n  obj.mesh.traverse((child: any) => {\n    if (child.isMesh && child.material) {\n      child.material.emissive.setHex(tintColor);\n      child.material.emissiveIntensity = 0.6;\n    }\n  });\n}\n\nexport function clearBendVisuals(obj: PhysicsObject): void {\n  if (!obj.mesh) return;\n  obj.mesh.scale.set(1, 1, 1);\n  const colors = MATERIAL_COLORS[obj.material] || MATERIAL_COLORS.stone;\n  obj.mesh.traverse((child: any) => {\n    if (child.isMesh && child.material) {\n      child.material.emissive.setHex(colors.emissive);\n      child.material.emissiveIntensity = 0.3;\n    }\n  });\n}\n\nexport function clearPhysicsObjects(gameState: any, scene: any): void {\n  for (const obj of gameState.physicsObjects) {\n    if (obj.tetherMesh) {\n      scene.remove(obj.tetherMesh);\n      obj.tetherMesh.geometry.dispose();\n      obj.tetherMesh.material.dispose();\n    }\n    if (obj.mesh) {\n      scene.remove(obj.mesh);\n      obj.mesh.traverse((child: any) => {\n        if (child.geometry) child.geometry.dispose();\n        if (child.material) child.material.dispose();\n      });\n    }\n  }\n  gameState.physicsObjects = [];\n}\n\nexport function updateTetherVisuals(gameState: any): void {\n  const t = performance.now() / 1000;\n  for (const obj of gameState.physicsObjects) {\n    if (!obj.suspended || !obj.tetherMesh) continue;\n    const pulse = 0.4 + 0.3 * Math.sin(t * 3);\n    obj.tetherMesh.material.opacity = pulse;\n  }\n}", "export interface BendEffect {\n  param: 'scale' | 'mass' | 'radius';\n  operation: 'multiply' | 'set';\n  value: number;\n}\n\nexport interface RuleBend {\n  id: string;\n  name: string;\n  description: string;\n  icon: string;\n  property: 'size' | 'adhesion' | 'durability';\n  pole: 'positive' | 'negative';\n  effects: BendEffect[];\n  tintColor: number;\n}\n\nexport const BENDS: RuleBend[] = [\n  {\n    id: 'enlarge',\n    name: 'Enlarge',\n    description: 'Scale up \u2014 bigger, heavier, more impact',\n    icon: '\u2B06',\n    property: 'size',\n    pole: 'positive',\n    effects: [\n      { param: 'scale', operation: 'multiply', value: 2.5 },\n      { param: 'mass', operation: 'multiply', value: 2 },\n      { param: 'radius', operation: 'multiply', value: 2 },\n    ],\n    tintColor: 0x4488ff,\n  },\n  {\n    id: 'shrink',\n    name: 'Shrink',\n    description: 'Scale down \u2014 tiny, light, flies on any push',\n    icon: '\u2B07',\n    property: 'size',\n    pole: 'negative',\n    effects: [\n      { param: 'scale', operation: 'multiply', value: 0.3 },\n      { param: 'mass', operation: 'multiply', value: 0.3 },\n      { param: 'radius', operation: 'multiply', value: 0.3 },\n    ],\n    tintColor: 0xffcc44,\n  },\n];\n\nexport function getBendById(id: string): RuleBend | undefined {\n  return BENDS.find(b => b.id === id);\n}", "import { getBendById } from '../config/bends';\n\nexport interface ActiveBend {\n  bendId: string;\n  targetType: 'physicsObject' | 'obstacle';\n  targetId: number;\n  target: any;\n  originalValues: Record<string, number>;\n}\n\nexport interface ApplyResult {\n  success: boolean;\n  reason?: 'no_bends_remaining' | 'opposite_pole' | 'already_applied' | 'invalid_bend' | 'invalid_target';\n}\n\nexport function createBendSystem(maxBends: number) {\n  let activeBends: ActiveBend[] = [];\n  let remaining = maxBends;\n  const max = maxBends;\n\n  function applyBend(bendId: string, targetType: 'physicsObject' | 'obstacle', target: any): ApplyResult {\n    const bend = getBendById(bendId);\n    if (!bend) return { success: false, reason: 'invalid_bend' };\n\n    if (remaining <= 0) return { success: false, reason: 'no_bends_remaining' };\n\n    const targetId = target.id ?? 0;\n\n    // Check if same bend already applied to this target\n    const existing = activeBends.find(ab => ab.targetId === targetId && ab.targetType === targetType);\n    if (existing) {\n      if (existing.bendId === bendId) {\n        return { success: false, reason: 'already_applied' };\n      }\n      // Check opposite pole\n      const existingBend = getBendById(existing.bendId);\n      if (existingBend && existingBend.property === bend.property) {\n        return { success: false, reason: 'opposite_pole' };\n      }\n    }\n\n    // Save original values before mutation\n    const originalValues: Record<string, number> = {};\n    for (const fx of bend.effects) {\n      originalValues[fx.param] = target[fx.param];\n    }\n\n    // Apply effects\n    for (const fx of bend.effects) {\n      if (fx.operation === 'multiply') {\n        target[fx.param] *= fx.value;\n      } else if (fx.operation === 'set') {\n        target[fx.param] = fx.value;\n      }\n    }\n\n    activeBends.push({\n      bendId,\n      targetType,\n      targetId,\n      target,\n      originalValues,\n    });\n\n    remaining--;\n    return { success: true };\n  }\n\n  function resetAll(): void {\n    for (const ab of activeBends) {\n      for (const [param, value] of Object.entries(ab.originalValues)) {\n        ab.target[param] = value;\n      }\n    }\n    activeBends = [];\n    remaining = max;\n  }\n\n  function getActiveBends(): ActiveBend[] {\n    return [...activeBends];\n  }\n\n  function bendsRemaining(): number {\n    return remaining;\n  }\n\n  function hasBendOnTarget(targetType: string, targetId: number): string | null {\n    const found = activeBends.find(ab => ab.targetType === targetType && ab.targetId === targetId);\n    return found ? found.bendId : null;\n  }\n\n  return { applyBend, resetAll, getActiveBends, bendsRemaining, hasBendOnTarget };\n}", "import { BENDS, RuleBend } from '../config/bends';\n\n// \u2500\u2500\u2500 State \u2500\u2500\u2500\n\nlet containerEl: HTMLDivElement | null = null;\nlet optionEls: HTMLDivElement[] = [];\nlet visible = false;\nlet selectedBendId: string | null = null;\nlet onBendSelectedCallback: ((bendId: string) => void) | null = null;\nlet lockedBendIds: Set<string> = new Set();\n\n// \u2500\u2500\u2500 Constants \u2500\u2500\u2500\n\nconst MENU_SIZE = 200;       // overall container size\nconst OPTION_SIZE = 72;      // each option circle\nconst OPTION_DISTANCE = 60;  // distance from center\n\n// \u2500\u2500\u2500 Init \u2500\u2500\u2500\n\nexport function initRadialMenu(): void {\n  // Container \u2014 centered overlay, hidden by default\n  containerEl = document.createElement('div');\n  containerEl.id = 'radial-menu';\n  containerEl.style.cssText = `\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    width: ${MENU_SIZE}px;\n    height: ${MENU_SIZE}px;\n    margin-left: ${-MENU_SIZE / 2}px;\n    margin-top: ${-MENU_SIZE / 2}px;\n    pointer-events: none;\n    z-index: 200;\n    display: none;\n  `;\n\n  // Center label\n  const centerLabel = document.createElement('div');\n  centerLabel.style.cssText = `\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    font-family: 'Courier New', monospace;\n    font-size: 10px;\n    color: rgba(200, 200, 220, 0.7);\n    letter-spacing: 2px;\n    text-transform: uppercase;\n    pointer-events: none;\n    white-space: nowrap;\n  `;\n  centerLabel.textContent = 'BEND';\n  containerEl.appendChild(centerLabel);\n\n  // Build option circles arranged in a line (2 options = left and right)\n  const angleStep = (2 * Math.PI) / BENDS.length;\n  const startAngle = Math.PI; // left \u2014 so 2 options go left/right\n\n  for (let i = 0; i < BENDS.length; i++) {\n    const bend = BENDS[i];\n    const angle = startAngle + i * angleStep;\n    const x = Math.cos(angle) * OPTION_DISTANCE;\n    const y = Math.sin(angle) * OPTION_DISTANCE;\n\n    const optEl = createOptionElement(bend, x, y);\n    containerEl.appendChild(optEl);\n    optionEls.push(optEl);\n  }\n\n  document.body.appendChild(containerEl);\n}\n\nfunction createOptionElement(bend: RuleBend, offsetX: number, offsetY: number): HTMLDivElement {\n  const el = document.createElement('div');\n  el.dataset.bendId = bend.id;\n  const colorHex = '#' + bend.tintColor.toString(16).padStart(6, '0');\n\n  el.style.cssText = `\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: ${OPTION_SIZE}px;\n    height: ${OPTION_SIZE}px;\n    margin-left: ${-OPTION_SIZE / 2 + offsetX}px;\n    margin-top: ${-OPTION_SIZE / 2 + offsetY}px;\n    border-radius: 50%;\n    background: rgba(20, 20, 40, 0.9);\n    border: 2px solid ${colorHex}44;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    pointer-events: auto;\n    transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;\n    user-select: none;\n  `;\n\n  // Icon\n  const iconEl = document.createElement('div');\n  iconEl.style.cssText = `\n    font-size: 20px;\n    line-height: 1;\n    pointer-events: none;\n  `;\n  iconEl.textContent = bend.icon;\n  el.appendChild(iconEl);\n\n  // Name\n  const nameEl = document.createElement('div');\n  nameEl.style.cssText = `\n    font-family: 'Courier New', monospace;\n    font-size: 9px;\n    color: ${colorHex};\n    letter-spacing: 1px;\n    text-transform: uppercase;\n    margin-top: 4px;\n    pointer-events: none;\n  `;\n  nameEl.textContent = bend.name;\n  el.appendChild(nameEl);\n\n  // Hover\n  el.addEventListener('mouseenter', () => {\n    if (selectedBendId === bend.id) return;\n    el.style.borderColor = colorHex + 'aa';\n    el.style.transform = 'scale(1.1)';\n  });\n  el.addEventListener('mouseleave', () => {\n    if (selectedBendId === bend.id) return;\n    el.style.borderColor = colorHex + '44';\n    el.style.transform = 'scale(1)';\n  });\n\n  // Click = select (mousedown to prevent attack input from firing)\n  el.addEventListener('mousedown', (e) => {\n    e.stopPropagation();\n    e.preventDefault();\n    if (lockedBendIds.has(bend.id)) return; // locked \u2014 ignore click\n    selectBend(bend.id);\n  });\n\n  return el;\n}\n\nfunction selectBend(bendId: string): void {\n  selectedBendId = bendId;\n\n  // Update visual state\n  for (const optEl of optionEls) {\n    const id = optEl.dataset.bendId || '';\n    const bend = BENDS.find(b => b.id === id);\n    if (!bend) continue;\n    const colorHex = '#' + bend.tintColor.toString(16).padStart(6, '0');\n\n    if (id === bendId) {\n      optEl.style.borderColor = colorHex;\n      optEl.style.boxShadow = `0 0 16px ${colorHex}88, inset 0 0 8px ${colorHex}44`;\n      optEl.style.transform = 'scale(1.15)';\n    } else {\n      optEl.style.borderColor = colorHex + '22';\n      optEl.style.boxShadow = 'none';\n      optEl.style.transform = 'scale(0.9)';\n      optEl.style.opacity = '0.5';\n    }\n  }\n\n  if (onBendSelectedCallback) {\n    onBendSelectedCallback(bendId);\n  }\n}\n\n// \u2500\u2500\u2500 Public API \u2500\u2500\u2500\n\nexport function showRadialMenu(): void {\n  if (!containerEl) return;\n  visible = true;\n  selectedBendId = null;\n  containerEl.style.display = 'block';\n\n  // Reset option visuals (locked bends grayed out)\n  for (const optEl of optionEls) {\n    const id = optEl.dataset.bendId || '';\n    const bend = BENDS.find(b => b.id === id);\n    if (!bend) continue;\n    const colorHex = '#' + bend.tintColor.toString(16).padStart(6, '0');\n\n    if (lockedBendIds.has(id)) {\n      optEl.style.borderColor = '#44444466';\n      optEl.style.boxShadow = 'none';\n      optEl.style.transform = 'scale(0.85)';\n      optEl.style.opacity = '0.3';\n      optEl.style.pointerEvents = 'none';\n      optEl.style.filter = 'grayscale(1)';\n    } else {\n      optEl.style.borderColor = colorHex + '44';\n      optEl.style.boxShadow = 'none';\n      optEl.style.transform = 'scale(1)';\n      optEl.style.opacity = '1';\n      optEl.style.pointerEvents = 'auto';\n      optEl.style.filter = 'none';\n    }\n  }\n}\n\nexport function hideRadialMenu(): void {\n  if (!containerEl) return;\n  visible = false;\n  // NOTE: do NOT clear selectedBendId here \u2014 targeting mode needs it after menu hides\n  containerEl.style.display = 'none';\n}\n\nexport function isRadialMenuVisible(): boolean {\n  return visible;\n}\n\nexport function getSelectedBendId(): string | null {\n  return selectedBendId;\n}\n\nexport function setOnBendSelected(callback: (bendId: string) => void): void {\n  onBendSelectedCallback = callback;\n}\n\nexport function updateLockedBends(ids: string[]): void {\n  lockedBendIds = new Set(ids);\n}\n\nexport function unlockBendUI(bendId: string): void {\n  lockedBendIds.delete(bendId);\n\n  // Flash the unlocked option\n  const optEl = optionEls.find(el => el.dataset.bendId === bendId);\n  if (!optEl) return;\n  const bend = BENDS.find(b => b.id === bendId);\n  if (!bend) return;\n  const colorHex = '#' + bend.tintColor.toString(16).padStart(6, '0');\n\n  // Restore interactive styling\n  optEl.style.pointerEvents = 'auto';\n  optEl.style.filter = 'none';\n  optEl.style.opacity = '1';\n  optEl.style.transform = 'scale(1)';\n  optEl.style.borderColor = colorHex;\n\n  // Unlock flash animation \u2014 bright glow then settle\n  optEl.style.boxShadow = `0 0 24px ${colorHex}, 0 0 48px ${colorHex}88`;\n  optEl.style.transform = 'scale(1.3)';\n  setTimeout(() => {\n    optEl.style.boxShadow = 'none';\n    optEl.style.transform = 'scale(1)';\n    optEl.style.borderColor = colorHex + '44';\n  }, 800);\n}\n\nexport function clearSelectedBend(): void {\n  selectedBendId = null;\n\n  // Reset option visuals\n  for (const optEl of optionEls) {\n    const id = optEl.dataset.bendId || '';\n    const bend = BENDS.find(b => b.id === id);\n    if (!bend) continue;\n    const colorHex = '#' + bend.tintColor.toString(16).padStart(6, '0');\n    optEl.style.borderColor = colorHex + '44';\n    optEl.style.boxShadow = 'none';\n    optEl.style.transform = 'scale(1)';\n    optEl.style.opacity = '1';\n  }\n}", "// Bend Mode \u2014 player-triggered rule-bending targeting mode\n// Press Q to toggle. Shows radial menu for bend selection,\n// then click a physics object to apply the bend.\n\nimport { createBendSystem } from './bendSystem';\nimport { getBendById } from '../config/bends';\nimport { activateBulletTime, isBulletTimeActive, toggleBulletTime } from './bulletTime';\nimport { showRadialMenu, hideRadialMenu, isRadialMenuVisible, getSelectedBendId, clearSelectedBend, updateLockedBends, unlockBendUI } from '../ui/radialMenu';\nimport { applyBendVisuals, clearBendVisuals } from '../entities/physicsObject';\nimport { getCamera } from './renderer';\nimport { emit, on } from './events';\nimport { screenShake } from './renderer';\n\n// \u2500\u2500\u2500 State \u2500\u2500\u2500\n\nlet bendSystem = createBendSystem(3);\nlet active = false;\nlet targeting = false;     // bend selected, waiting for click on target\nlet maxBends = 3;\n\n// \u2500\u2500\u2500 Highlight State \u2500\u2500\u2500\n// Tracks which objects are currently highlighted so we can restore them\n\nlet highlightedObjects: Set<any> = new Set();\nlet hoveredObject: any = null;\nlet highlightPulseTime = 0;  // accumulates for pulsing animation\nlet lockedBends: Set<string> = new Set();\n\n// \u2500\u2500\u2500 Init \u2500\u2500\u2500\n\nexport function initBendMode(): void {\n  maxBends = 3;\n  bendSystem = createBendSystem(maxBends);\n\n  // Pressure plate unlocks all locked bends\n  on('pressurePlateActivated', () => {\n    if (lockedBends.size === 0) return;\n    const unlocking = [...lockedBends];\n    for (const bendId of unlocking) {\n      unlockBend(bendId);\n    }\n  });\n}\n\n// \u2500\u2500\u2500 Toggle \u2500\u2500\u2500\n\nexport function toggleBendMode(): void {\n  if (active) {\n    deactivateBendMode();\n  } else {\n    activateBendMode();\n  }\n}\n\nfunction activateBendMode(): void {\n  if (bendSystem.bendsRemaining() <= 0) return;\n  active = true;\n  targeting = false;\n\n  // Activate bullet time for slow-mo\n  if (!isBulletTimeActive()) {\n    activateBulletTime();\n  }\n\n  showRadialMenu();\n  updateTargetingCursor();\n  emit({ type: 'bendModeActivated' });\n}\n\nfunction deactivateBendMode(): void {\n  active = false;\n  targeting = false;\n  hideRadialMenu();\n  clearSelectedBend();\n  unhighlightAllObjects();\n  updateTargetingCursor();\n\n  // Deactivate bullet time\n  if (isBulletTimeActive()) {\n    toggleBulletTime();\n  }\n\n  emit({ type: 'bendModeDeactivated' });\n}\n\n// \u2500\u2500\u2500 Targeting \u2500\u2500\u2500\n\nexport function enterTargeting(): void {\n  if (!active) return;\n  targeting = true;\n  // Hide radial menu \u2014 bend is selected, now click a target\n  hideRadialMenu();\n  updateTargetingCursor();\n}\n\n// \u2500\u2500\u2500 Targeting Cursor \u2500\u2500\u2500\n// Shows a visible \"click a target\" indicator when in targeting mode\n\nlet targetingIndicator: HTMLDivElement | null = null;\n\nfunction ensureTargetingIndicator(): void {\n  if (targetingIndicator) return;\n  targetingIndicator = document.createElement('div');\n  targetingIndicator.id = 'bend-targeting';\n  targetingIndicator.style.cssText = `\n    position: fixed;\n    top: 55%;\n    left: 50%;\n    transform: translateX(-50%);\n    font-family: 'Courier New', monospace;\n    font-size: 12px;\n    color: rgba(100, 180, 255, 0.9);\n    letter-spacing: 3px;\n    text-transform: uppercase;\n    text-shadow: 0 0 10px rgba(100, 140, 255, 0.6);\n    pointer-events: none;\n    z-index: 200;\n    display: none;\n  `;\n  document.body.appendChild(targetingIndicator);\n}\n\nfunction updateTargetingCursor(): void {\n  ensureTargetingIndicator();\n  if (!targetingIndicator) return;\n\n  if (active && targeting) {\n    const bendId = getSelectedBendId();\n    const label = bendId === 'enlarge' ? 'ENLARGE' : bendId === 'shrink' ? 'SHRINK' : 'BEND';\n    targetingIndicator.textContent = `[ ${label} ] click target`;\n    targetingIndicator.style.display = 'block';\n    document.body.style.cursor = 'crosshair';\n  } else if (active && !targeting) {\n    targetingIndicator.style.display = 'none';\n    document.body.style.cursor = 'default';\n  } else {\n    targetingIndicator.style.display = 'none';\n    document.body.style.cursor = 'default';\n  }\n}\n\nexport function isBendModeActive(): boolean {\n  return active;\n}\n\nexport function isBendTargeting(): boolean {\n  return targeting;\n}\n\n// \u2500\u2500\u2500 Object Highlights \u2500\u2500\u2500\n// When bend mode is active, all targetable objects pulse with an outline glow.\n// The hovered object gets a brighter highlight.\n\nfunction highlightTargetableObjects(gameState: any): void {\n  for (const obj of gameState.physicsObjects) {\n    if (obj.destroyed || obj.fellInPit || !obj.mesh) continue;\n    if (highlightedObjects.has(obj)) continue;\n\n    // Store original emissive values before highlight\n    obj.mesh.traverse((child: any) => {\n      if (child.isMesh && child.material) {\n        if (!child.userData._origEmissiveHex) {\n          child.userData._origEmissiveHex = child.material.emissive.getHex();\n          child.userData._origEmissiveIntensity = child.material.emissiveIntensity;\n        }\n      }\n    });\n\n    highlightedObjects.add(obj);\n  }\n}\n\nfunction unhighlightAllObjects(): void {\n  for (const obj of highlightedObjects) {\n    if (!obj.mesh) continue;\n    obj.mesh.traverse((child: any) => {\n      if (child.isMesh && child.material && child.userData._origEmissiveHex !== undefined) {\n        child.material.emissive.setHex(child.userData._origEmissiveHex);\n        child.material.emissiveIntensity = child.userData._origEmissiveIntensity;\n        delete child.userData._origEmissiveHex;\n        delete child.userData._origEmissiveIntensity;\n      }\n    });\n  }\n  highlightedObjects.clear();\n  hoveredObject = null;\n}\n\nfunction updateHighlightPulse(dt: number): void {\n  highlightPulseTime += dt;\n  // Pulse intensity: sine wave between 0.5 and 1.0\n  const pulse = 0.5 + 0.5 * Math.sin(highlightPulseTime * 4);\n  const baseIntensity = 0.3 + pulse * 0.5;     // 0.3 \u2192 0.8\n  const hoverIntensity = 0.6 + pulse * 0.6;    // 0.6 \u2192 1.2\n  const highlightColor = 0x6699ff; // soft blue\n\n  for (const obj of highlightedObjects) {\n    if (!obj.mesh) continue;\n    const isHovered = obj === hoveredObject;\n    obj.mesh.traverse((child: any) => {\n      if (child.isMesh && child.material) {\n        child.material.emissive.setHex(isHovered ? 0x88ccff : highlightColor);\n        child.material.emissiveIntensity = isHovered ? hoverIntensity : baseIntensity;\n      }\n    });\n  }\n}\n\n// \u2500\u2500\u2500 Hover Detection \u2500\u2500\u2500\n// Called each frame during targeting to detect which object the cursor is over\n\nexport function updateBendHover(mouseNDC: { x: number; y: number }, gameState: any): void {\n  if (!active || !targeting) {\n    if (hoveredObject) hoveredObject = null;\n    return;\n  }\n\n  const camera = getCamera();\n  const raycaster = new THREE.Raycaster();\n  raycaster.setFromCamera(new THREE.Vector2(mouseNDC.x, mouseNDC.y), camera);\n\n  const meshes: any[] = [];\n  const meshToObj: Map<any, any> = new Map();\n\n  for (const obj of gameState.physicsObjects) {\n    if (obj.destroyed || obj.fellInPit || !obj.mesh) continue;\n    meshes.push(obj.mesh);\n    meshToObj.set(obj.mesh, obj);\n  }\n\n  const intersects = raycaster.intersectObjects(meshes, true);\n  let newHovered: any = null;\n\n  if (intersects.length > 0) {\n    for (const hit of intersects) {\n      let current = hit.object;\n      while (current) {\n        if (meshToObj.has(current)) {\n          newHovered = meshToObj.get(current);\n          break;\n        }\n        current = current.parent;\n      }\n      if (newHovered) break;\n    }\n  }\n\n  hoveredObject = newHovered;\n}\n\n// \u2500\u2500\u2500 Per-Frame Update \u2500\u2500\u2500\n// Call from game loop to update highlights and hover\n\nexport function updateBendMode(dt: number, gameState: any): void {\n  if (active) {\n    highlightTargetableObjects(gameState);\n    updateHighlightPulse(dt);\n  }\n}\n\n// \u2500\u2500\u2500 Click-to-Apply \u2500\u2500\u2500\n\nexport function handleBendClick(mouseNDC: { x: number; y: number }, gameState: any): void {\n  if (!active || !targeting) return;\n\n  const selectedBend = getSelectedBendId();\n  if (!selectedBend) return;\n\n  // Raycast against physics object meshes\n  const camera = getCamera();\n  const raycaster = new THREE.Raycaster();\n  raycaster.setFromCamera(new THREE.Vector2(mouseNDC.x, mouseNDC.y), camera);\n\n  // Collect all physics object meshes\n  const meshes: any[] = [];\n  const meshToObj: Map<any, any> = new Map();\n\n  for (const obj of gameState.physicsObjects) {\n    if (obj.destroyed || obj.fellInPit || !obj.mesh) continue;\n    meshes.push(obj.mesh);\n    meshToObj.set(obj.mesh, obj);\n  }\n\n  // Test all meshes (recursive for groups)\n  const intersects = raycaster.intersectObjects(meshes, true);\n\n  if (intersects.length > 0) {\n    // Find which physics object was hit\n    let hitObj: any = null;\n    for (const hit of intersects) {\n      // Walk up to find the group that's in our map\n      let current = hit.object;\n      while (current) {\n        if (meshToObj.has(current)) {\n          hitObj = meshToObj.get(current);\n          break;\n        }\n        current = current.parent;\n      }\n      if (hitObj) break;\n    }\n\n    if (hitObj) {\n      tryApplyBendToTarget(hitObj, 'physicsObject');\n    }\n  }\n}\n\nexport function tryApplyBendToTarget(target: any, targetType: 'physicsObject' | 'obstacle'): void {\n  const selectedBend = getSelectedBendId();\n  if (!selectedBend) return;\n\n  if (lockedBends.has(selectedBend)) {\n    emit({ type: 'bendFailed', bendId: selectedBend, reason: 'locked' });\n    return;\n  }\n\n  const result = bendSystem.applyBend(selectedBend, targetType, target);\n\n  if (result.success) {\n    // Remove from highlight set so highlight pulse doesn't overwrite bend visuals\n    highlightedObjects.delete(target);\n    // Clean up stored originals (bend visuals now own the emissive)\n    if (target.mesh) {\n      target.mesh.traverse((child: any) => {\n        if (child.isMesh) {\n          delete child.userData._origEmissiveHex;\n          delete child.userData._origEmissiveIntensity;\n        }\n      });\n    }\n\n    // Apply visuals\n    const bend = getBendById(selectedBend);\n    if (bend) {\n      applyBendVisuals(target, bend.tintColor);\n    }\n\n    // Drop suspended objects\n    if (target.suspended) {\n      target.suspended = false;\n\n      // Remove tether visual\n      if (target.tetherMesh) {\n        target.tetherMesh.geometry.dispose();\n        target.tetherMesh.material.dispose();\n        const tetherScene = target.tetherMesh.parent;\n        if (tetherScene) tetherScene.remove(target.tetherMesh);\n        target.tetherMesh = null;\n      }\n\n      // Animate drop: move mesh from suspend height to ground\n      const mesh = target.mesh;\n      if (mesh) {\n        const startY = target.suspendHeight;\n        const dropDuration = 400; // ms\n        const startTime = performance.now();\n        const dropAnim = () => {\n          const elapsed = performance.now() - startTime;\n          const t = Math.min(elapsed / dropDuration, 1);\n          // Ease-in (accelerating fall)\n          const eased = t * t;\n          mesh.position.y = startY * (1 - eased);\n          if (t < 1) {\n            requestAnimationFrame(dropAnim);\n          } else {\n            mesh.position.y = 0;\n            // Impact feedback\n            screenShake(5, 300);\n            emit({ type: 'objectDropped', position: { x: target.pos.x, z: target.pos.z } });\n          }\n        };\n        requestAnimationFrame(dropAnim);\n      }\n    }\n\n    // Emit event\n    emit({\n      type: 'bendApplied',\n      bendId: selectedBend,\n      targetType,\n      targetId: target.id ?? 0,\n      position: { x: target.pos.x, z: target.pos.z },\n    });\n\n    // Exit targeting \u2014 go back to radial menu if bends remaining\n    targeting = false;\n    clearSelectedBend();\n\n    if (bendSystem.bendsRemaining() > 0) {\n      showRadialMenu();\n    } else {\n      deactivateBendMode();\n    }\n  } else {\n    emit({\n      type: 'bendFailed',\n      bendId: selectedBend,\n      reason: result.reason || 'unknown',\n    });\n  }\n}\n\n// \u2500\u2500\u2500 Locked Bends \u2500\u2500\u2500\n\nexport function setLockedBends(ids: string[]): void {\n  lockedBends = new Set(ids);\n  updateLockedBends(ids);\n}\n\nexport function isBendLocked(bendId: string): boolean {\n  return lockedBends.has(bendId);\n}\n\nfunction unlockBend(bendId: string): void {\n  lockedBends.delete(bendId);\n  updateLockedBends([...lockedBends]);\n  unlockBendUI(bendId);\n\n  // Announce\n  const announceEl = document.getElementById('wave-announce');\n  if (announceEl) {\n    const label = bendId.toUpperCase();\n    announceEl.textContent = `${label} UNLOCKED`;\n    announceEl.classList.add('visible');\n    setTimeout(() => announceEl.classList.remove('visible'), 2000);\n  }\n\n  // Screen shake for emphasis\n  screenShake(3, 200);\n}\n\n// \u2500\u2500\u2500 Queries \u2500\u2500\u2500\n\nexport function getBendsRemaining(): number {\n  return bendSystem.bendsRemaining();\n}\n\nexport function getActiveBends() {\n  return bendSystem.getActiveBends();\n}\n\nexport function getMaxBends(): number {\n  return maxBends;\n}\n\n// \u2500\u2500\u2500 Reset \u2500\u2500\u2500\n\nexport function resetBendMode(): void {\n  // Restore all bent objects to original values + visuals\n  const activeBends = bendSystem.getActiveBends();\n  for (const ab of activeBends) {\n    if (ab.target && ab.target.mesh) {\n      clearBendVisuals(ab.target);\n    }\n  }\n\n  bendSystem.resetAll();\n  active = false;\n  targeting = false;\n  unhighlightAllObjects();\n  highlightPulseTime = 0;\n  hideRadialMenu();\n  clearSelectedBend();\n  lockedBends.clear();\n  updateLockedBends([]);\n}", "// Pressure Plate \u2014 floor zone that activates when a heavy enough object rests on it\n// Triggers a ceremony (glow pulse, particle burst, audio) on activation.\n\nimport { PressurePlate, PressurePlatePlacement, GameState } from '../types/index';\nimport { emit } from './events';\nimport { screenShake } from './renderer';\n\n// \u2500\u2500\u2500 Create \u2500\u2500\u2500\n\nexport function createPressurePlate(placement: PressurePlatePlacement): PressurePlate {\n  return {\n    x: placement.x,\n    z: placement.z,\n    radius: placement.radius,\n    massThreshold: placement.massThreshold,\n    activated: false,\n    mesh: null,\n  };\n}\n\n// \u2500\u2500\u2500 Mesh \u2500\u2500\u2500\n\nexport function createPressurePlateMesh(plate: PressurePlate, scene: any): void {\n  const group = new THREE.Group();\n\n  // Glowing ring on the ground\n  const ringGeo = new THREE.RingGeometry(plate.radius * 0.6, plate.radius, 32);\n  const ringMat = new THREE.MeshBasicMaterial({\n    color: 0x44ff88,\n    transparent: true,\n    opacity: 0.4,\n    side: THREE.DoubleSide,\n  });\n  const ring = new THREE.Mesh(ringGeo, ringMat);\n  ring.rotation.x = -Math.PI / 2; // lay flat\n  ring.position.y = 0.02;         // just above ground\n  group.add(ring);\n\n  // Inner disc\n  const discGeo = new THREE.CircleGeometry(plate.radius * 0.6, 32);\n  const discMat = new THREE.MeshBasicMaterial({\n    color: 0x226644,\n    transparent: true,\n    opacity: 0.3,\n    side: THREE.DoubleSide,\n  });\n  const disc = new THREE.Mesh(discGeo, discMat);\n  disc.rotation.x = -Math.PI / 2;\n  disc.position.y = 0.01;\n  group.add(disc);\n\n  group.position.set(plate.x, 0, plate.z);\n  scene.add(group);\n  plate.mesh = group;\n}\n\n// \u2500\u2500\u2500 Update \u2500\u2500\u2500\n\nexport function updatePressurePlates(gameState: GameState): void {\n  for (const plate of gameState.pressurePlates) {\n    if (plate.activated) continue;\n\n    // Check if any physics object with enough mass is resting on the plate\n    for (const obj of gameState.physicsObjects) {\n      if (obj.destroyed || obj.fellInPit) continue;\n\n      // Check overlap (circle vs circle)\n      const dx = obj.pos.x - plate.x;\n      const dz = obj.pos.z - plate.z;\n      const distSq = dx * dx + dz * dz;\n      const maxDist = plate.radius + obj.radius;\n\n      if (distSq > maxDist * maxDist) continue;\n\n      // Check mass threshold\n      if (obj.mass < plate.massThreshold) continue;\n\n      // Check velocity is near zero (object must be \"resting\")\n      const speed = Math.sqrt(obj.vel.x * obj.vel.x + obj.vel.z * obj.vel.z);\n      if (speed > 0.5) continue;\n\n      // Activate!\n      plate.activated = true;\n      activatePlateCeremony(plate);\n      break;\n    }\n  }\n\n  // Pulse inactive plates\n  for (const plate of gameState.pressurePlates) {\n    if (plate.activated || !plate.mesh) continue;\n    const t = performance.now() / 1000;\n    const pulse = 0.3 + 0.15 * Math.sin(t * 2.5);\n    const ring = plate.mesh.children[0];\n    if (ring && ring.material) {\n      ring.material.opacity = pulse;\n    }\n  }\n}\n\nfunction activatePlateCeremony(plate: PressurePlate): void {\n  if (!plate.mesh) return;\n\n  // Brighten the plate\n  plate.mesh.children.forEach((child: any) => {\n    if (child.material) {\n      child.material.color.setHex(0x88ffcc);\n      child.material.opacity = 0.8;\n    }\n  });\n\n  // Screen shake\n  screenShake(4, 300);\n\n  // Emit event for audio/particles\n  emit({\n    type: 'pressurePlateActivated',\n    position: { x: plate.x, z: plate.z },\n  });\n}\n\n// \u2500\u2500\u2500 Cleanup \u2500\u2500\u2500\n\nexport function clearPressurePlates(gameState: GameState, scene: any): void {\n  for (const plate of gameState.pressurePlates) {\n    if (plate.mesh) {\n      scene.remove(plate.mesh);\n      plate.mesh.traverse((child: any) => {\n        if (child.geometry) child.geometry.dispose();\n        if (child.material) child.material.dispose();\n      });\n    }\n  }\n  gameState.pressurePlates = [];\n}\n", "// Room Intro Modal \u2014 shows room context before gameplay begins\n// Semi-transparent overlay with room name, description, and Continue button\n\nimport type { RoomDefinition } from '../config/rooms';\n\nlet overlayEl: HTMLElement | null = null;\nlet nameEl: HTMLElement | null = null;\nlet textEl: HTMLElement | null = null;\nlet continueBtn: HTMLElement | null = null;\nlet currentCleanup: (() => void) | null = null;\n\nexport function initRoomIntro(): void {\n  overlayEl = document.getElementById('room-intro');\n  nameEl = document.getElementById('room-intro-name');\n  textEl = document.getElementById('room-intro-text');\n  continueBtn = document.getElementById('room-intro-continue');\n}\n\nexport function showRoomIntro(room: RoomDefinition, onContinue: () => void): void {\n  if (!overlayEl || !nameEl || !textEl || !continueBtn) return;\n\n  // Clean up any previous listener\n  if (currentCleanup) {\n    currentCleanup();\n    currentCleanup = null;\n  }\n\n  nameEl.textContent = room.name;\n  textEl.textContent = room.intro ?? room.commentary;\n\n  // Show overlay (hidden \u2192 visible with fade)\n  overlayEl.classList.remove('hidden');\n  // Force reflow so the opacity transition triggers\n  void overlayEl.offsetWidth;\n  overlayEl.classList.add('visible');\n\n  const handleContinue = () => {\n    cleanup();\n    hideRoomIntro();\n    onContinue();\n  };\n\n  const handleClick = () => handleContinue();\n  const handleTouch = (e: Event) => {\n    e.preventDefault();\n    handleContinue();\n  };\n\n  continueBtn.addEventListener('click', handleClick);\n  continueBtn.addEventListener('touchend', handleTouch);\n\n  const cleanup = () => {\n    continueBtn!.removeEventListener('click', handleClick);\n    continueBtn!.removeEventListener('touchend', handleTouch);\n    currentCleanup = null;\n  };\n\n  currentCleanup = cleanup;\n}\n\nexport function hideRoomIntro(): void {\n  if (!overlayEl) return;\n  overlayEl.classList.remove('visible');\n  // After fade-out transition, hide completely\n  setTimeout(() => {\n    if (overlayEl) overlayEl.classList.add('hidden');\n  }, 300);\n}\n", "// Room Manager \u2014 loads rooms, incremental pack spawning, door integration\n// Replaces the old wave-based system with escalating pack dispatch\n// Player enters from +Z (bottom-left in iso), progresses toward -Z (top-right)\n// Door is at -Z end; unlocks when room is cleared, requires interact to enter\n\nimport { ROOMS, RoomDefinition } from '../config/rooms';\nimport { setHeightZones } from '../config/terrain';\nimport { resetAerialVerbs } from './aerialVerbs';\nimport { clearAllTags } from './tags';\nimport { clearCarriers } from './entityCarrier';\nimport { cleanupGroundShadows, initGroundShadows } from './groundShadows';\nimport { clearVisionCones } from './visionCone';\nimport { clearLaunchPillars } from '../effects/launchPillar';\nimport { clearLaunchIndicator } from '../effects/launchIndicator';\nimport { setProfile } from './profileManager';\nimport { setArenaConfig, ARENA_HALF_X, ARENA_HALF_Z } from '../config/arena';\nimport { SPAWN_CONFIG } from '../config/spawn';\nimport { spawnEnemy, clearEnemies } from '../entities/enemy';\nimport { getPlayerPos, setPlayerVisual } from '../entities/player';\nimport { setPlayerPosition } from '../entities/player';\nimport { getInputState } from './input';\nimport { releaseAllProjectiles } from '../entities/projectile';\nimport { clearMortarProjectiles, clearIcePatches } from '../entities/mortarProjectile';\nimport { clearAoeTelegraphs } from './aoeTelegraph';\nimport { clearDamageNumbers } from '../ui/damageNumbers';\nimport { clearEffectGhosts } from './physics';\nimport { clearParticles } from './particles';\nimport { invalidateCollisionBounds, getBounds, getPits } from './physics';\nimport { rebuildArenaVisuals, setFrustumSize } from './renderer';\nimport { emit, on } from './events';\nimport { createTelegraph, updateTelegraph, removeTelegraph, initTelegraph } from './telegraph';\nimport { triggerRoomHighlights, clearHighlights } from './roomHighlights';\nimport { initDoor, createDoor, unlockDoor, updateDoor, removeDoor } from './door';\nimport { DOOR_CONFIG } from '../config/door';\nimport { SpawnPack } from '../types/index';\nimport { createPhysicsObject, createPhysicsObjectMesh, clearPhysicsObjects, resetPhysicsObjectIds } from '../entities/physicsObject';\nimport { resetBendMode, setLockedBends } from './bendMode';\nimport { createPressurePlate, createPressurePlateMesh, clearPressurePlates } from './pressurePlate';\nimport { initRoomIntro, showRoomIntro } from '../ui/roomIntro';\n\n// \u2500\u2500\u2500 State \u2500\u2500\u2500\n\nlet currentRoomIndex = 0;\nlet packIndex = 0;           // next pack to dispatch\nlet totalKills = 0;          // enemies killed in this room\nlet roomBudgetTotal = 0;     // total enemies in all packs for this room\nlet roomCleared = false;\nlet spawnCooldownTimer = 0;  // ms remaining before next pack can dispatch\nlet finalWaveAnnounced = false;\nlet restRoomTimer = 0;       // timer for rest room door auto-open\n\n// Active telegraphs \u2014 packs being telegraphed before enemies materialize\ninterface ActiveTelegraphGroup {\n  telegraphs: any[];          // telegraph visual objects (one per enemy)\n  pack: SpawnPack;\n  positions: { x: number; z: number }[];\n  timer: number;              // ms remaining\n  duration: number;           // total telegraph duration\n  packIdx: number;\n}\nlet activeTelegraphs: ActiveTelegraphGroup[] = [];\n\nlet announceEl: HTMLElement | null = null;\nlet sceneRef: any = null;\nlet onContinueCallback: (() => void) | null = null;\n\n// \u2500\u2500\u2500 Public API \u2500\u2500\u2500\n\nexport function initRoomManager(scene: any, onIntroComplete?: () => void) {\n  sceneRef = scene;\n  onContinueCallback = onIntroComplete ?? null;\n  announceEl = document.getElementById('wave-announce');\n  initTelegraph(scene);\n  initDoor(scene);\n  initRoomIntro();\n\n  // Track enemy deaths for spawn dispatch\n  on('enemyDied', () => {\n    totalKills++;\n  });\n}\n\nexport function loadRoom(index: number, gameState: any) {\n  if (index >= ROOMS.length) {\n    showAnnounce('VICTORY!');\n    return;\n  }\n\n  const room = ROOMS[index];\n  currentRoomIndex = index;\n  packIndex = 0;\n  totalKills = 0;\n  roomCleared = false;\n  spawnCooldownTimer = 0;\n  finalWaveAnnounced = false;\n  activeTelegraphs = [];\n\n  // Count total enemies in budget\n  roomBudgetTotal = room.spawnBudget.packs.reduce(\n    (sum, p) => sum + p.enemies.length, 0\n  );\n\n  restRoomTimer = 0;\n\n  // Clear everything from previous room\n  clearHighlights();\n  clearEnemies(gameState)\n  releaseAllProjectiles();\n  clearMortarProjectiles();\n  clearIcePatches();\n  clearAoeTelegraphs();\n  clearDamageNumbers();\n  clearEffectGhosts();\n  clearParticles();\n  removeDoor();\n  resetAerialVerbs();\n  clearAllTags();\n  clearCarriers();\n  clearLaunchPillars();\n  clearLaunchIndicator();\n  cleanupGroundShadows();\n  clearVisionCones();\n  clearPhysicsObjects(gameState, sceneRef);\n  clearPressurePlates(gameState, sceneRef);\n  resetBendMode();\n  if (room.lockedBends && room.lockedBends.length > 0) {\n    setLockedBends(room.lockedBends);\n  }\n  resetPhysicsObjectIds();\n\n  // Swap arena layout\n  setArenaConfig(room.obstacles, room.pits, room.arenaHalfX, room.arenaHalfZ);\n  setHeightZones(room.heightZones ?? []);\n  invalidateCollisionBounds();\n  rebuildArenaVisuals();\n  setFrustumSize(room.frustumSize ?? 12);\n  initGroundShadows();\n\n  // Spawn physics objects (if room defines them)\n  if (room.physicsObjects) {\n    for (const placement of room.physicsObjects) {\n      const obj = createPhysicsObject(placement);\n      createPhysicsObjectMesh(obj, sceneRef);\n      gameState.physicsObjects.push(obj);\n    }\n  }\n\n  // Spawn pressure plates (if room defines them)\n  if (room.pressurePlates) {\n    for (const placement of room.pressurePlates) {\n      const plate = createPressurePlate(placement);\n      createPressurePlateMesh(plate, sceneRef);\n      gameState.pressurePlates.push(plate);\n    }\n  }\n\n  // Set player position\n  setPlayerPosition(room.playerStart.x, room.playerStart.z);\n\n  // Update game state\n  gameState.currentWave = index + 1;\n\n  // Profile switch (before special room handling so it applies to all rooms)\n  setProfile(room.profile);\n  setPlayerVisual(room.profile);\n\n  // Show room intro modal \u2014 gameplay paused until Continue\n  gameState.phase = 'intro';\n  showRoomIntro(room, () => {\n    gameState.phase = 'playing';\n    if (onContinueCallback) onContinueCallback();\n  });\n\n  // Handle special rooms\n  if (room.isRestRoom) {\n    // Heal player\n    gameState.playerHealth = gameState.playerMaxHealth;\n    emit({ type: 'playerHealed', amount: gameState.playerMaxHealth, position: { x: room.playerStart.x, z: room.playerStart.z } });\n    emit({ type: 'restRoomEntered', roomIndex: index });\n    roomCleared = true; // no enemies to fight\n    // Create door that auto-opens after a delay\n    if (index + 1 < ROOMS.length) {\n      createDoor(room.arenaHalfX, room.arenaHalfZ, index);\n      restRoomTimer = DOOR_CONFIG.restPause;\n    }\n    return;\n  }\n\n  if (room.isVictoryRoom) {\n    showAnnounce('VICTORY!');\n    emit({ type: 'roomCleared', roomIndex: index });\n    roomCleared = true;\n    // No door \u2014 victory room is the end\n    return;\n  }\n\n  // Combat room \u2014 create locked door at far end\n  if (index + 1 < ROOMS.length) {\n    createDoor(room.arenaHalfX, room.arenaHalfZ, index);\n  }\n\n  // Sandbox mode \u2014 door starts unlocked, enemies still spawn\n  if (room.sandboxMode) {\n    unlockDoor();\n  }\n\n  // Trigger feature highlights (pits, obstacles, etc.)\n  if (room.highlights && room.highlights.length > 0) {\n    triggerRoomHighlights(room.highlights);\n  }\n}\n\nexport function updateRoomManager(dt: number, gameState: any) {\n  if (gameState.phase !== 'playing') return;\n\n  const room = ROOMS[currentRoomIndex];\n  if (!room) return;\n\n  // \u2500\u2500\u2500 Handle rest room door auto-open \u2500\u2500\u2500\n  if (room.isRestRoom && restRoomTimer > 0) {\n    restRoomTimer -= dt * 1000;\n    if (restRoomTimer <= 0) {\n      unlockDoor();\n    }\n  }\n\n  // \u2500\u2500\u2500 Update door + check for room transition \u2500\u2500\u2500\n  const playerPos = getPlayerPos();\n  const input = getInputState();\n  const doorTriggered = updateDoor(dt, playerPos, input.interact);\n  if (doorTriggered) {\n    loadRoom(currentRoomIndex + 1, gameState);\n    return;\n  }\n\n  // \u2500\u2500\u2500 Update active telegraphs \u2500\u2500\u2500\n  for (let i = activeTelegraphs.length - 1; i >= 0; i--) {\n    const tg = activeTelegraphs[i];\n    tg.timer -= dt * 1000;\n    const progress = 1 - (tg.timer / tg.duration);\n\n    // Update telegraph visuals\n    for (const tel of tg.telegraphs) {\n      updateTelegraph(tel, Math.min(progress, 1), dt);\n    }\n\n    // Telegraph expired \u2014 spawn enemies\n    if (tg.timer <= 0) {\n      for (const tel of tg.telegraphs) {\n        removeTelegraph(tel);\n      }\n      // Spawn enemies at resolved positions\n      for (let j = 0; j < tg.pack.enemies.length; j++) {\n        const enemy = tg.pack.enemies[j];\n        const pos = tg.positions[j];\n        const spawnPos = new THREE.Vector3(pos.x, 0, pos.z);\n        spawnEnemy(enemy.type, spawnPos, gameState, enemy.patrolWaypoints);\n      }\n      emit({ type: 'spawnPackSpawned', packIndex: tg.packIdx, roomIndex: currentRoomIndex });\n      activeTelegraphs.splice(i, 1);\n    }\n  }\n\n  // \u2500\u2500\u2500 Skip dispatch logic for special rooms \u2500\u2500\u2500\n  if (room.isRestRoom || room.isVictoryRoom) return;\n\n  // \u2500\u2500\u2500 Count alive enemies \u2500\u2500\u2500\n  const aliveCount = gameState.enemies.length;\n  const budget = room.spawnBudget;\n  const effectiveMaxConcurrent = Math.round(budget.maxConcurrent * SPAWN_CONFIG.maxConcurrentMult);\n\n  // \u2500\u2500\u2500 Announce final wave \u2500\u2500\u2500\n  if (!finalWaveAnnounced && packIndex >= budget.packs.length && activeTelegraphs.length === 0 && aliveCount > 0) {\n    finalWaveAnnounced = true;\n    showAnnounce('FINAL WAVE');\n    setTimeout(hideAnnounce, 1500);\n  }\n\n  // \u2500\u2500\u2500 Dispatch new packs \u2500\u2500\u2500\n  spawnCooldownTimer -= dt * 1000;\n\n  if (packIndex < budget.packs.length && spawnCooldownTimer <= 0) {\n    const nextPack = budget.packs[packIndex];\n    // Count enemies being telegraphed (not yet spawned)\n    const telegraphingCount = activeTelegraphs.reduce(\n      (sum, tg) => sum + tg.pack.enemies.length, 0\n    );\n    const totalActive = aliveCount + telegraphingCount;\n\n    if (totalActive + nextPack.enemies.length <= effectiveMaxConcurrent + 1) {\n      // Dispatch this pack: resolve positions, create telegraphs\n      const positions = resolveSpawnPositions(nextPack, room);\n      const telegraphs = positions.map((pos, idx) =>\n        createTelegraph(pos.x, pos.z, nextPack.enemies[idx].type)\n      );\n\n      const duration = budget.telegraphDuration || SPAWN_CONFIG.telegraphDuration;\n      activeTelegraphs.push({\n        telegraphs,\n        pack: nextPack,\n        positions,\n        timer: duration,\n        duration,\n        packIdx: packIndex,\n      });\n\n      emit({ type: 'spawnPackTelegraph', packIndex, roomIndex: currentRoomIndex });\n      packIndex++;\n      spawnCooldownTimer = SPAWN_CONFIG.spawnCooldown;\n    }\n  }\n\n  // \u2500\u2500\u2500 Check room cleared \u2500\u2500\u2500\n  if (!roomCleared && packIndex >= budget.packs.length && activeTelegraphs.length === 0 && aliveCount === 0) {\n    roomCleared = true;\n    emit({ type: 'roomCleared', roomIndex: currentRoomIndex });\n    emit({ type: 'roomClearComplete', roomIndex: currentRoomIndex });\n\n    if (currentRoomIndex + 1 >= ROOMS.length) {\n      // Last combat room cleared \u2014 victory\n      showAnnounce('VICTORY!');\n    } else {\n      showAnnounce('Room Cleared!');\n      setTimeout(hideAnnounce, 1500);\n      // Unlock the door \u2014 player walks through to proceed\n      unlockDoor();\n    }\n  }\n}\n\n// \u2500\u2500\u2500 Spawn Position Resolution \u2500\u2500\u2500\n\nfunction resolveSpawnPositions(pack: SpawnPack, room: RoomDefinition): { x: number; z: number }[] {\n  const playerPos = getPlayerPos();\n  const playerZ = playerPos ? playerPos.z : room.playerStart.z;\n  const playerX = playerPos ? playerPos.x : room.playerStart.x;\n\n  const hx = room.arenaHalfX - 1.5;  // margin from walls\n  const hz = room.arenaHalfZ - 1.5;\n\n  return pack.enemies.map((enemyDef) => {\n    // Fixed position overrides zone-based spawning\n    if (enemyDef.fixedPos) {\n      return { x: enemyDef.fixedPos.x, z: enemyDef.fixedPos.z };\n    }\n\n    let x: number, z: number;\n\n    for (let attempt = 0; attempt < 10; attempt++) {\n      switch (pack.spawnZone) {\n        case 'ahead': {\n          // Ahead = toward -Z (the exit / top-right in iso)\n          const aheadMin = SPAWN_CONFIG.spawnAheadMin;\n          const aheadMax = SPAWN_CONFIG.spawnAheadMax;\n          x = (Math.random() * 2 - 1) * hx;\n          z = playerZ - aheadMin - Math.random() * (aheadMax - aheadMin);\n          break;\n        }\n        case 'sides': {\n          // Near the X walls, slightly ahead (-Z) of player\n          const side = Math.random() < 0.5 ? -1 : 1;\n          x = side * (hx * 0.6 + Math.random() * hx * 0.3);\n          z = playerZ - 3 - Math.random() * 10;\n          break;\n        }\n        case 'far': {\n          // Near the far end of the room (-Z exit wall)\n          x = (Math.random() * 2 - 1) * hx;\n          z = -hz + 2 + Math.random() * 5;\n          break;\n        }\n        case 'behind': {\n          // Behind = toward +Z (entrance / bottom-left in iso)\n          x = (Math.random() * 2 - 1) * hx;\n          z = playerZ + 5 + Math.random() * 5;\n          break;\n        }\n        default: {\n          x = (Math.random() * 2 - 1) * hx;\n          z = playerZ - 5 - Math.random() * 10;\n        }\n      }\n\n      // Clamp to arena bounds\n      x = Math.max(-hx, Math.min(hx, x));\n      z = Math.max(-hz, Math.min(hz, z));\n\n      // Validate: not inside obstacle or pit\n      if (!isInsideObstacle(x, z) && !isInsidePit(x, z)) {\n        return { x, z };\n      }\n    }\n\n    // Fallback: spawn at room center-ish\n    return { x: (Math.random() * 2 - 1) * 3, z: 0 };\n  });\n}\n\nfunction isInsideObstacle(x: number, z: number): boolean {\n  const bounds = getBounds();\n  // Only check obstacle bounds, not walls (first N entries before the 4 wall entries)\n  const obstacleCount = bounds.length - 4;\n  for (let i = 0; i < obstacleCount; i++) {\n    const b = bounds[i];\n    if (x >= b.minX - 1 && x <= b.maxX + 1 && z >= b.minZ - 1 && z <= b.maxZ + 1) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isInsidePit(x: number, z: number): boolean {\n  const pits = getPits();\n  for (const p of pits) {\n    if (x >= p.minX - 0.5 && x <= p.maxX + 0.5 && z >= p.minZ - 0.5 && z <= p.maxZ + 0.5) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// \u2500\u2500\u2500 Public Getters \u2500\u2500\u2500\n\nexport function getCurrentRoom(): RoomDefinition | null {\n  return ROOMS[currentRoomIndex] ?? null;\n}\n\nexport function getCurrentRoomIndex(): number {\n  return currentRoomIndex;\n}\n\nexport function getCurrentRoomName(): string {\n  const room = ROOMS[currentRoomIndex];\n  return room ? room.name : '';\n}\n\nexport function getRoomCount(): number {\n  return ROOMS.length;\n}\n\nexport function isRoomCleared(): boolean {\n  return roomCleared;\n}\n\nexport function resetRoomManager() {\n  currentRoomIndex = 0;\n  packIndex = 0;\n  totalKills = 0;\n  roomBudgetTotal = 0;\n  roomCleared = false;\n  spawnCooldownTimer = 0;\n  finalWaveAnnounced = false;\n  restRoomTimer = 0;\n  activeTelegraphs = [];\n  removeDoor();\n}\n\n// \u2500\u2500\u2500 Announce UI \u2500\u2500\u2500\n\nfunction showAnnounce(text: string) {\n  if (!announceEl) return;\n  announceEl.textContent = text;\n  announceEl.classList.add('visible');\n}\n\nfunction hideAnnounce() {\n  if (!announceEl) return;\n  announceEl.classList.remove('visible');\n}\n", "// src/config/mobileControls.ts\n// Tunable config for mobile radial button layout.\n// Mutated directly by the tuning panel at runtime.\n\nexport const MOBILE_CONTROLS = {\n  // Layout\n  primarySize: 95,       // px \u2014 Attack/Push button\n  fanSize: 66,           // px \u2014 Dash, Jump, Launch\n  cancelSize: 45,        // px \u2014 Cancel button\n  arcRadius: 100,        // px \u2014 distance from primary center to fan buttons\n  arcStartAngle: -5,     // degrees \u2014 0=left, 90=up; -5 puts Dash near horizontal\n  arcSpread: 95,         // degrees \u2014 total angle spread: Dash=-5\u00B0, Jump=42.5\u00B0, Launch=90\u00B0\n  edgeMargin: 20,        // px \u2014 offset from screen edge\n\n  // Behavior\n  holdThreshold: 180,    // ms \u2014 tap vs hold on Attack/Push button\n  dragThreshold: 15,     // px \u2014 min distance to register as drag\n  dragMaxRadius: 80,     // px \u2014 full deflection range for drag-to-aim\n};\n", "import { ABILITIES } from '../config/abilities';\nimport { PLAYER } from '../config/player';\nimport {\n  triggerDash, triggerUltimate, setUltimateHeld,\n  triggerJump, triggerLaunch, triggerCancel,\n  setAimFromScreenDrag, setAbilityDirOverride, clearAbilityDirOverride,\n  getInputState\n} from '../engine/input';\nimport { MOBILE_CONTROLS } from '../config/mobileControls';\nimport { isBulletTimeActive, getBulletTimeResource, getBulletTimeMax } from '../engine/bulletTime';\nimport { getCurrentRoomIndex, getCurrentRoomName } from '../engine/roomManager';\nimport { getActiveProfile } from '../engine/profileManager';\nimport { getBendsRemaining, getMaxBends } from '../engine/bendMode';\nimport { on } from '../engine/events';\n\n// Which abilities are active per profile (unlocked = visible, rest grayed out)\nconst PROFILE_ABILITIES: Record<string, string[]> = {\n  origin:         ['dash'],\n  base:           ['dash', 'ultimate'],\n  assassin:       ['dash', 'ultimate'],\n  'rule-bending': ['dash', 'ultimate'],\n  vertical:       ['dash', 'ultimate'],\n};\n\n// Per-profile label overrides for ability slots (key \u2192 display name)\nconst PROFILE_ABILITY_LABELS: Record<string, Record<string, string>> = {\n  vertical: { ultimate: 'Launch / Dunk' },\n};\n\nlet healthBar: any, healthText: any, waveIndicator: any, currencyCount: any, abilityBar: any;\nlet bulletTimeMeter: any, bulletTimeFill: any;\nlet btVignette: any, btCeremony: any;\nlet btCeremonyTimeout: any = null;\n\n// Mobile action button refs\nlet mobileBtnDash: any, mobileBtnUlt: any, mobileBtnBend: any;\nlet mobileBtnJump: any, mobileBtnLaunch: any, mobileBtnCancel: any;\nlet lastMobileProfile: string = '';\n\nexport function initHUD() {\n  healthBar = document.getElementById('health-bar');\n  healthText = document.getElementById('health-text');\n  waveIndicator = document.getElementById('wave-indicator');\n  currencyCount = document.getElementById('currency-count');\n  abilityBar = document.getElementById('ability-bar');\n\n  // Build desktop ability slots (keyboard labels)\n  for (const [key, ability] of Object.entries(ABILITIES)) {\n    const el = document.createElement('div');\n    el.className = 'ability-slot ready';\n    el.id = `ability-${key}`;\n    el.innerHTML =\n      `<div class=\"ability-key\">${(ability as any).key}</div>` +\n      `<div class=\"ability-name\">${(ability as any).name}</div>` +\n      `<div class=\"ability-cooldown-text\"></div>` +\n      `<div class=\"ability-cooldown-overlay\"></div>`;\n    abilityBar.appendChild(el);\n  }\n\n  // Mobile action buttons \u2014 wire up touch handlers\n  const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n  if (hasTouch) {\n    initMobileButtons();\n  }\n\n  // Bullet time meter bar \u2014 positioned top-left below health bar\n  bulletTimeMeter = document.createElement('div');\n  bulletTimeMeter.id = 'bullet-time-meter';\n  bulletTimeMeter.style.cssText = `\n    position: fixed;\n    top: 44px;\n    left: 20px;\n    width: 220px;\n    height: 6px;\n    background: rgba(20, 20, 40, 0.7);\n    border: 1px solid rgba(100, 140, 255, 0.3);\n    border-radius: 3px;\n    z-index: 50;\n    overflow: hidden;\n  `;\n  bulletTimeFill = document.createElement('div');\n  bulletTimeFill.style.cssText = `\n    width: 100%;\n    height: 100%;\n    background: #6688ff;\n    border-radius: 2px;\n    transition: background-color 0.15s ease;\n  `;\n  bulletTimeMeter.appendChild(bulletTimeFill);\n\n  // Label \u2014 right side\n  const btLabel = document.createElement('div');\n  btLabel.style.cssText = `\n    position: absolute;\n    top: -1px;\n    right: -50px;\n    font-size: 8px;\n    color: rgba(100, 140, 255, 0.6);\n    letter-spacing: 1px;\n    font-family: 'Courier New', monospace;\n    pointer-events: none;\n  `;\n  btLabel.textContent = 'Q \\u2014 SLOW';\n  bulletTimeMeter.appendChild(btLabel);\n\n  document.body.appendChild(bulletTimeMeter);\n\n  // Bend counter (visible only in rule-bending rooms)\n  const bendCounter = document.createElement('div');\n  bendCounter.id = 'bend-counter';\n  bendCounter.style.cssText = `\n    position: fixed;\n    top: 60px;\n    left: 16px;\n    font-family: 'Courier New', monospace;\n    font-size: 14px;\n    color: rgba(100, 180, 255, 0.9);\n    letter-spacing: 2px;\n    text-shadow: 0 0 8px rgba(100, 140, 255, 0.4);\n    display: none;\n    pointer-events: none;\n  `;\n  document.body.appendChild(bendCounter);\n\n  // Bullet time vignette overlay\n  btVignette = document.createElement('div');\n  btVignette.id = 'bt-vignette';\n  btVignette.style.cssText = `\n    position: fixed;\n    top: 0; left: 0; right: 0; bottom: 0;\n    pointer-events: none;\n    z-index: 40;\n    opacity: 0;\n    transition: opacity 0.3s ease;\n    background: radial-gradient(ellipse at center, transparent 50%, rgba(100, 140, 255, 0.15) 100%);\n    box-shadow: inset 0 0 80px rgba(100, 140, 255, 0.2);\n  `;\n  document.body.appendChild(btVignette);\n\n  // Bullet time ceremony text\n  btCeremony = document.createElement('div');\n  btCeremony.id = 'bt-ceremony';\n  btCeremony.style.cssText = `\n    position: fixed;\n    top: 18%;\n    left: 50%;\n    transform: translateX(-50%);\n    font-size: 14px;\n    font-family: 'Courier New', monospace;\n    color: rgba(100, 160, 255, 0.9);\n    letter-spacing: 6px;\n    text-transform: uppercase;\n    text-shadow: 0 0 12px rgba(100, 140, 255, 0.6), 0 0 30px rgba(100, 140, 255, 0.3);\n    pointer-events: none;\n    z-index: 55;\n    opacity: 0;\n    transition: opacity 0.2s ease;\n  `;\n  document.body.appendChild(btCeremony);\n\n  // Subscribe to bullet time events for vignette + ceremony\n  on('bulletTimeActivated', () => {\n    if (btVignette) btVignette.style.opacity = '1';\n    showBTCeremony('BULLET TIME ENGAGED', 1200);\n  });\n  on('bulletTimeDeactivated', () => {\n    if (btVignette) btVignette.style.opacity = '0';\n    showBTCeremony('BULLET TIME ENDED', 800);\n  });\n}\n\nfunction showBTCeremony(text: string, durationMs: number) {\n  if (!btCeremony) return;\n  if (btCeremonyTimeout) clearTimeout(btCeremonyTimeout);\n  btCeremony.textContent = text;\n  btCeremony.style.opacity = '1';\n  btCeremonyTimeout = setTimeout(() => {\n    btCeremony.style.opacity = '0';\n    btCeremonyTimeout = null;\n  }, durationMs);\n}\n\n// Drag-to-aim constants\nconst DRAG_THRESHOLD = 15;  // px \u2014 distinguish tap from drag\nconst DRAG_MAX_RADIUS = 80; // px \u2014 full deflection range\n\n// Isometric basis vectors (duplicated from input.js for screen\u2192world mapping)\nconst INV_SQRT2 = 1 / Math.SQRT2;\nconst ISO_RIGHT_X = INV_SQRT2;\nconst ISO_RIGHT_Z = -INV_SQRT2;\nconst ISO_UP_X = -INV_SQRT2;\nconst ISO_UP_Z = -INV_SQRT2;\n\nfunction initMobileButtons() {\n  mobileBtnDash = document.getElementById('mobile-btn-dash');\n  mobileBtnUlt = document.getElementById('mobile-btn-ultimate');\n  mobileBtnJump = document.getElementById('mobile-btn-jump');\n  mobileBtnLaunch = document.getElementById('mobile-btn-launch');\n  mobileBtnCancel = document.getElementById('mobile-btn-cancel');\n\n  if (!mobileBtnDash) return;\n\n  // --- Dash: drag-to-aim, release to fire ---\n  setupDragToAim(mobileBtnDash, {\n    onDragStart: () => { /* don't trigger yet \u2014 wait for release */ },\n    onDragMove: (normX: number, normY: number) => {\n      const isoX = normX * ISO_RIGHT_X + normY * ISO_UP_X;\n      const isoZ = normX * ISO_RIGHT_Z + normY * ISO_UP_Z;\n      setAbilityDirOverride(isoX, isoZ);\n      setAimFromScreenDrag(normX, normY);\n    },\n    onRelease: (wasDrag: boolean) => {\n      triggerDash();\n      if (!wasDrag) clearAbilityDirOverride();\n    },\n    onCancel: () => {\n      clearAbilityDirOverride();\n    },\n  });\n\n  // --- Ultimate (Push): drag-to-aim, charge while held ---\n  if (mobileBtnUlt) {\n    setupDragToAim(mobileBtnUlt, {\n      onDragStart: () => {\n        triggerUltimate();\n        setUltimateHeld(true);\n      },\n      onDragMove: (normX: number, normY: number) => {\n        setAimFromScreenDrag(normX, normY);\n      },\n      onRelease: () => {\n        setUltimateHeld(false);\n        clearAbilityDirOverride();\n      },\n      onCancel: () => {\n        setUltimateHeld(false);\n        clearAbilityDirOverride();\n      },\n    });\n  }\n\n  // --- Jump: simple tap ---\n  if (mobileBtnJump) {\n    mobileBtnJump.addEventListener('touchstart', (e: any) => {\n      e.preventDefault();\n      triggerJump();\n    });\n  }\n\n  // --- Launch: simple tap ---\n  if (mobileBtnLaunch) {\n    mobileBtnLaunch.addEventListener('touchstart', (e: any) => {\n      e.preventDefault();\n      triggerLaunch();\n    });\n  }\n\n  // --- Cancel: simple tap ---\n  if (mobileBtnCancel) {\n    mobileBtnCancel.addEventListener('touchstart', (e: any) => {\n      e.preventDefault();\n      triggerCancel();\n    });\n  }\n\n  // --- Bend toggle: wire existing HTML button ---\n  mobileBtnBend = document.getElementById('mobile-btn-bend') as HTMLDivElement | null;\n  if (mobileBtnBend) {\n    mobileBtnBend.addEventListener('touchstart', (e: any) => {\n      e.preventDefault();\n      getInputState().bendMode = true;\n    });\n  }\n\n  // Initial profile-based layout\n  updateMobileButtons();\n}\n\n/**\n * Show/hide mobile buttons and position them in a radial fan based on profile.\n * Called once on init and whenever the profile changes.\n */\nexport function updateMobileButtons() {\n  const profile = getActiveProfile();\n  if (profile === lastMobileProfile) return;\n  lastMobileProfile = profile;\n\n  const allBtns = [mobileBtnDash, mobileBtnUlt, mobileBtnJump, mobileBtnLaunch, mobileBtnCancel, mobileBtnBend];\n\n  // Hide all first\n  for (const btn of allBtns) {\n    if (btn) btn.classList.remove('visible');\n  }\n\n  // Determine which buttons to show\n  let visibleBtns: { el: any; size: number }[] = [];\n\n  if (profile === 'vertical') {\n    visibleBtns = [\n      { el: mobileBtnDash, size: MOBILE_CONTROLS.fanSize },\n      { el: mobileBtnJump, size: MOBILE_CONTROLS.fanSize },\n      { el: mobileBtnLaunch, size: MOBILE_CONTROLS.fanSize },\n      { el: mobileBtnCancel, size: MOBILE_CONTROLS.cancelSize },\n    ];\n  } else if (profile === 'origin') {\n    // Origin has auto-fire, no combat buttons needed\n    visibleBtns = [];\n  } else if (profile === 'rule-bending') {\n    visibleBtns = [\n      { el: mobileBtnDash, size: MOBILE_CONTROLS.fanSize },\n      { el: mobileBtnUlt, size: MOBILE_CONTROLS.primarySize },\n      { el: mobileBtnBend, size: MOBILE_CONTROLS.fanSize },\n    ];\n  } else {\n    // 'base', 'assassin' \u2014 default set\n    visibleBtns = [\n      { el: mobileBtnDash, size: MOBILE_CONTROLS.fanSize },\n      { el: mobileBtnUlt, size: MOBILE_CONTROLS.primarySize },\n    ];\n  }\n\n  // Position buttons in a radial fan from bottom-right anchor\n  const mc = MOBILE_CONTROLS;\n  const anchorRight = mc.edgeMargin;\n  const anchorBottom = window.innerHeight * 0.20; // 20% from bottom, matching old layout\n\n  const container = document.getElementById('mobile-actions');\n  if (container) {\n    container.style.right = '0px';\n    container.style.bottom = '0px';\n    container.style.width = '100%';\n    container.style.height = '100%';\n  }\n\n  const count = visibleBtns.length;\n  for (let i = 0; i < count; i++) {\n    const { el, size } = visibleBtns[i];\n    if (!el) continue;\n\n    el.classList.add('visible');\n    el.style.width = size + 'px';\n    el.style.height = size + 'px';\n\n    // Fan angle: distribute buttons along arc\n    const angleDeg = mc.arcStartAngle + (count > 1 ? (mc.arcSpread * i) / (count - 1) : 0);\n    const angleRad = (angleDeg * Math.PI) / 180;\n\n    // Compute position relative to anchor point (bottom-right)\n    const dx = -Math.cos(angleRad) * mc.arcRadius; // negative = leftward from right edge\n    const dy = -Math.sin(angleRad) * mc.arcRadius; // negative = upward from bottom\n\n    // Position from bottom-right corner\n    el.style.right = (anchorRight - dx) + 'px';\n    el.style.bottom = (anchorBottom - dy) + 'px';\n    el.style.transform = 'translate(50%, 50%)'; // center on computed position\n  }\n\n}\n\n/**\n * Generic drag-to-aim handler for a mobile ability button.\n * Touch down \u2192 drag to aim \u2192 release to fire.\n * Callbacks:\n *   onDragStart() \u2014 called once when touch begins\n *   onDragMove(normX, normY) \u2014 called each touchmove when past threshold\n *     normX: -1..1 screen-right, normY: -1..1 screen-up\n *   onRelease(wasDrag) \u2014 called on touchend (wasDrag = true if threshold exceeded)\n *   onCancel() \u2014 called on touchcancel\n */\nfunction setupDragToAim(btnEl: any, { onDragStart, onDragMove, onRelease, onCancel }: any) {\n  let touchId: number | null = null;\n  let startX = 0, startY = 0;\n  let isDragging = false;\n\n  btnEl.addEventListener('touchstart', (e: any) => {\n    e.preventDefault();\n    if (touchId !== null) return; // already tracking a touch\n    const touch = e.changedTouches[0];\n    touchId = touch.identifier;\n    startX = touch.clientX;\n    startY = touch.clientY;\n    isDragging = false;\n    onDragStart();\n  });\n\n  // Listen on window so drag can extend beyond button bounds\n  window.addEventListener('touchmove', (e: any) => {\n    if (touchId === null) return;\n    const touch = findTouch(e.changedTouches, touchId);\n    if (!touch) return;\n\n    const dx = touch.clientX - startX;\n    const dy = touch.clientY - startY;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n\n    if (dist > DRAG_THRESHOLD) {\n      isDragging = true;\n      // Normalize to -1..1 range, clamped by max radius\n      const clampedDist = Math.min(dist, DRAG_MAX_RADIUS);\n      const normX = (dx / dist) * (clampedDist / DRAG_MAX_RADIUS);\n      const normY = (-dy / dist) * (clampedDist / DRAG_MAX_RADIUS); // invert Y (screen down = negative)\n      onDragMove(normX, normY);\n    }\n  }, { passive: true });\n\n  window.addEventListener('touchend', (e: any) => {\n    if (touchId === null) return;\n    const touch = findTouch(e.changedTouches, touchId);\n    if (!touch) return;\n    touchId = null;\n    onRelease(isDragging);\n  });\n\n  window.addEventListener('touchcancel', (e: any) => {\n    if (touchId === null) return;\n    const touch = findTouch(e.changedTouches, touchId);\n    if (!touch) return;\n    touchId = null;\n    onCancel();\n  });\n}\n\nfunction findTouch(touchList: any, id: number) {\n  for (let i = 0; i < touchList.length; i++) {\n    if (touchList[i].identifier === id) return touchList[i];\n  }\n  return null;\n}\n\nexport function updateHUD(gameState: any) {\n  // Update mobile button visibility when profile changes (short-circuits if same)\n  updateMobileButtons();\n\n  // Health bar\n  const pct = Math.max(0, gameState.playerHealth / gameState.playerMaxHealth);\n  healthBar.style.width = (pct * 100) + '%';\n\n  if (pct > 0.5) {\n    healthBar.style.backgroundColor = '#44ff88';\n  } else if (pct > 0.25) {\n    healthBar.style.backgroundColor = '#ffcc44';\n  } else {\n    healthBar.style.backgroundColor = '#ff4444';\n  }\n\n  healthText.textContent = Math.ceil(gameState.playerHealth) + ' / ' + gameState.playerMaxHealth;\n\n  // Room indicator\n  waveIndicator.textContent = `${getCurrentRoomIndex() + 1}. ${getCurrentRoomName()}`;\n\n  // Currency\n  currencyCount.textContent = gameState.currency;\n\n  // Bullet time meter\n  if (bulletTimeFill) {\n    const btPct = getBulletTimeResource() / getBulletTimeMax();\n    bulletTimeFill.style.width = (btPct * 100) + '%';\n    const btActive = isBulletTimeActive();\n    bulletTimeFill.style.backgroundColor = btActive ? '#ffcc44' : '#6688ff';\n    if (bulletTimeMeter) {\n      bulletTimeMeter.style.borderColor = btActive\n        ? 'rgba(255, 204, 68, 0.6)'\n        : 'rgba(100, 140, 255, 0.3)';\n    }\n  }\n\n  // Ability availability \u2014 gray out abilities not active for this profile\n  const profile = getActiveProfile();\n  const activeAbilities = PROFILE_ABILITIES[profile] ?? ['dash', 'ultimate'];\n  const labelOverrides = PROFILE_ABILITY_LABELS[profile] ?? {};\n  for (const key of Object.keys(ABILITIES)) {\n    const slot = document.getElementById(`ability-${key}`);\n    if (slot) {\n      if (activeAbilities.includes(key)) {\n        slot.classList.remove('disabled');\n      } else {\n        slot.classList.add('disabled');\n      }\n      // Apply per-profile label overrides\n      const nameEl = slot.querySelector('.ability-name') as HTMLElement;\n      if (nameEl) {\n        nameEl.textContent = labelOverrides[key] ?? (ABILITIES as any)[key].name;\n      }\n    }\n  }\n\n  // Ability cooldowns \u2014 update both desktop slots and mobile buttons\n  for (const [key, state] of Object.entries(gameState.abilities)) {\n    if (!(ABILITIES as any)[key]) continue;\n    const cfg = (ABILITIES as any)[key];\n\n    // --- Desktop ability slot ---\n    const slot = document.getElementById(`ability-${key}`);\n    if (slot) {\n      const overlay = slot.querySelector('.ability-cooldown-overlay') as any;\n      const cdText = slot.querySelector('.ability-cooldown-text') as any;\n\n      if ((state as any).cooldownRemaining > 0) {\n        const pctRemaining = Math.max(0, (state as any).cooldownRemaining / cfg.cooldown);\n        overlay.style.height = (pctRemaining * 100) + '%';\n        slot.classList.remove('ready');\n        const secs = Math.ceil((state as any).cooldownRemaining / 1000);\n        cdText.textContent = secs;\n        cdText.style.display = 'flex';\n      } else {\n        overlay.style.height = '0%';\n        slot.classList.add('ready');\n        cdText.style.display = 'none';\n      }\n\n      // Show charging state for ultimate (Force Push)\n      if (key === 'ultimate' && (state as any).charging) {\n        const chargePct = Math.round((state as any).chargeT * 100);\n        slot.style.borderColor = 'rgba(68, 255, 170, 0.8)';\n        slot.style.boxShadow = '0 0 12px rgba(68, 255, 170, 0.4)';\n        cdText.textContent = chargePct + '%';\n        cdText.style.display = 'flex';\n        cdText.style.color = '#44ffaa';\n        overlay.style.height = ((1 - (state as any).chargeT) * 100) + '%';\n        overlay.style.backgroundColor = 'rgba(68, 255, 170, 0.3)';\n      } else {\n        if (slot.style.borderColor) slot.style.borderColor = '';\n        if (slot.style.boxShadow) slot.style.boxShadow = '';\n        cdText.style.color = '';\n        overlay.style.backgroundColor = '';\n      }\n    }\n\n    // --- Mobile action button ---\n    const mBtn = key === 'dash' ? mobileBtnDash : key === 'ultimate' ? mobileBtnUlt : null;\n    if (mBtn) {\n      const mOverlay = mBtn.querySelector('.mobile-btn-cd-overlay');\n      const mCdText = mBtn.querySelector('.mobile-btn-cd-text');\n\n      if ((state as any).cooldownRemaining > 0) {\n        const pctRemaining = Math.max(0, (state as any).cooldownRemaining / cfg.cooldown);\n        mOverlay.style.height = (pctRemaining * 100) + '%';\n        mBtn.classList.remove('ready');\n        const secs = Math.ceil((state as any).cooldownRemaining / 1000);\n        mCdText.textContent = secs;\n        mCdText.style.display = 'flex';\n      } else {\n        mOverlay.style.height = '0%';\n        mBtn.classList.add('ready');\n        mCdText.style.display = 'none';\n      }\n\n      // Charging state for ultimate\n      if (key === 'ultimate' && (state as any).charging) {\n        const chargePct = Math.round((state as any).chargeT * 100);\n        mBtn.style.borderColor = 'rgba(68, 255, 170, 0.9)';\n        mBtn.style.boxShadow = '0 0 16px rgba(68, 255, 170, 0.5)';\n        mCdText.textContent = chargePct + '%';\n        mCdText.style.display = 'flex';\n        mCdText.style.color = '#44ffaa';\n        mOverlay.style.height = ((1 - (state as any).chargeT) * 100) + '%';\n        mOverlay.style.backgroundColor = 'rgba(68, 255, 170, 0.3)';\n      } else if (key === 'ultimate') {\n        if (mBtn.style.borderColor) mBtn.style.borderColor = '';\n        if (mBtn.style.boxShadow) mBtn.style.boxShadow = '';\n        mCdText.style.color = '';\n        mOverlay.style.backgroundColor = '';\n      }\n    }\n  }\n\n  // Bend counter\n  const bendCounterEl = document.getElementById('bend-counter');\n  if (bendCounterEl) {\n    if (getActiveProfile() === 'rule-bending') {\n      bendCounterEl.style.display = 'block';\n      bendCounterEl.textContent = `BENDS: ${getBendsRemaining()}/${getMaxBends()}`;\n    } else {\n      bendCounterEl.style.display = 'none';\n    }\n  }\n}\n", "// Room Selector \u2014 populates start screen with room buttons\n// Clicking a room button starts the game at that room index\n\nimport { ROOMS } from '../config/rooms';\n\nlet onSelectCallback: ((roomIndex: number) => void) | null = null;\n\nexport function initRoomSelector(onSelect: (roomIndex: number) => void): void {\n  onSelectCallback = onSelect;\n\n  const listEl = document.getElementById('room-selector-list');\n  if (!listEl) return;\n\n  // Clear any existing buttons\n  while (listEl.firstChild) {\n    listEl.removeChild(listEl.firstChild);\n  }\n\n  ROOMS.forEach((room, index) => {\n    const btn = document.createElement('button');\n    btn.className = 'room-selector-btn';\n\n    const nameSpan = document.createElement('span');\n    nameSpan.className = 'room-name';\n    nameSpan.textContent = `${index + 1}. ${room.name}`;\n    btn.appendChild(nameSpan);\n\n    const descSpan = document.createElement('span');\n    descSpan.className = 'room-desc';\n    descSpan.textContent = room.commentary;\n    btn.appendChild(descSpan);\n\n    const handleClick = () => {\n      if (onSelectCallback) onSelectCallback(index);\n    };\n\n    btn.addEventListener('click', handleClick);\n    btn.addEventListener('touchend', (e) => {\n      e.preventDefault();\n      handleClick();\n    });\n\n    listEl.appendChild(btn);\n  });\n}\n", "import { initRoomSelector } from './roomSelector';\n\nlet startScreen: any, startBtn: any;\nlet gameOverScreen: any, restartBtn: any, gameOverStats: any;\n\nexport function initScreens(\n  onRestart: () => void,\n  onStart: () => void,\n  onStartAtRoom?: (roomIndex: number) => void\n) {\n  // Start screen\n  startScreen = document.getElementById('start-screen');\n  startBtn = document.getElementById('start-btn');\n\n  const handleStart = () => {\n    hideStartScreen();\n    onStart();\n  };\n  startBtn.addEventListener('click', handleStart);\n  startBtn.addEventListener('touchend', (e: any) => {\n    e.preventDefault();\n    handleStart();\n  });\n\n  // Room selector\n  if (onStartAtRoom) {\n    initRoomSelector((roomIndex) => {\n      hideStartScreen();\n      onStartAtRoom(roomIndex);\n    });\n  }\n\n  // Game over screen\n  gameOverScreen = document.getElementById('game-over-screen');\n  restartBtn = document.getElementById('restart-btn');\n  gameOverStats = document.getElementById('game-over-stats');\n\n  restartBtn.addEventListener('click', () => {\n    hideScreens();\n    onRestart();\n  });\n}\n\nexport function hideStartScreen() {\n  startScreen.classList.add('hidden');\n}\n\nexport function showGameOver(gameState: any) {\n  gameOverStats.textContent = `Enemies defeated: ${gameState.currency} gold earned`;\n  gameOverScreen.classList.remove('hidden');\n}\n\nexport function hideScreens() {\n  gameOverScreen.classList.add('hidden');\n}\n", "// Audio Foundation \u2014 synthesized sound effects via Web Audio API\n// No audio files, no asset pipeline. Each sound is a procedurally generated\n// burst of oscillators and noise. Matches the primitive art philosophy.\n//\n// Call initAudio() after first user gesture (click/key) to create AudioContext.\n// Then subscribe to event bus for automatic sound playback.\n\nimport { on } from './events';\nimport type { GameEvent } from './events';\n\n// \u2500\u2500\u2500 Config (tunable) \u2500\u2500\u2500\n\nexport const AUDIO_CONFIG = {\n  masterVolume: 0.3,\n  hitVolume: 0.4,\n  deathVolume: 0.5,\n  dashVolume: 0.25,\n  shieldBreakVolume: 0.6,\n  chargeVolume: 0.35,\n  waveClearVolume: 0.4,\n  playerHitVolume: 0.5,\n  meleeSwingVolume: 0.3,\n  meleeHitVolume: 0.45,\n  wallSlamVolume: 0.5,\n  enemyImpactVolume: 0.4,\n  // Vertical combat\n  jumpVolume: 0.25,\n  landVolume: 0.3,\n  launchVolume: 0.4,\n  aerialStrikeVolume: 0.45,\n  slamVolume: 0.5,\n  dunkGrabVolume: 0.35,\n  dunkImpactVolume: 0.55,\n  enabled: true,\n};\n\n// \u2500\u2500\u2500 State \u2500\u2500\u2500\n\nlet ctx: AudioContext | null = null;\nlet masterGain: GainNode | null = null;\nlet initialized = false;\n\n// \u2500\u2500\u2500 Init \u2500\u2500\u2500\n\nexport function initAudio(): void {\n  if (initialized) return;\n\n  try {\n    ctx = new (window.AudioContext || (window as any).webkitAudioContext)();\n    masterGain = ctx.createGain();\n    masterGain.gain.value = AUDIO_CONFIG.masterVolume;\n    masterGain.connect(ctx.destination);\n    initialized = true;\n\n    // Subscribe to game events\n    wireEventBus();\n\n    // Wire mute button\n    const muteBtn = document.getElementById('mute-btn');\n    if (muteBtn) {\n      muteBtn.addEventListener('click', () => {\n        AUDIO_CONFIG.enabled = !AUDIO_CONFIG.enabled;\n        if (masterGain) {\n          masterGain.gain.value = AUDIO_CONFIG.enabled ? AUDIO_CONFIG.masterVolume : 0;\n        }\n        muteBtn.textContent = AUDIO_CONFIG.enabled ? '\\u{1F50A}' : '\\u{1F507}';\n        muteBtn.classList.toggle('muted', !AUDIO_CONFIG.enabled);\n      });\n    }\n  } catch (e) {\n    console.warn('[audio] Web Audio API not available:', e);\n  }\n}\n\n// Resume context on user interaction (required by browsers)\nexport function resumeAudio(): void {\n  if (ctx && ctx.state === 'suspended') {\n    ctx.resume();\n  }\n}\n\nexport function setMasterVolume(v: number): void {\n  AUDIO_CONFIG.masterVolume = v;\n  if (masterGain) {\n    masterGain.gain.value = v;\n  }\n}\n\n// \u2500\u2500\u2500 Sound Generators \u2500\u2500\u2500\n\n// Utility: create white noise buffer\nfunction createNoiseBuffer(duration: number): AudioBuffer {\n  if (!ctx) return new AudioBuffer({ length: 1, sampleRate: 44100 });\n  const length = Math.floor(ctx.sampleRate * duration);\n  const buffer = ctx.createBuffer(1, length, ctx.sampleRate);\n  const data = buffer.getChannelData(0);\n  for (let i = 0; i < length; i++) {\n    data[i] = Math.random() * 2 - 1;\n  }\n  return buffer;\n}\n\n// Hit: short noise burst + descending pitch sweep\nexport function playHit(intensity: number = 1): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const vol = AUDIO_CONFIG.hitVolume * Math.min(intensity, 2);\n  const duration = 0.06 + intensity * 0.02;\n\n  // Noise burst\n  const noise = ctx.createBufferSource();\n  noise.buffer = createNoiseBuffer(duration);\n  const noiseGain = ctx.createGain();\n  noiseGain.gain.setValueAtTime(vol * 0.6, now);\n  noiseGain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  const noiseFilter = ctx.createBiquadFilter();\n  noiseFilter.type = 'highpass';\n  noiseFilter.frequency.value = 2000 + intensity * 500;\n  noise.connect(noiseFilter);\n  noiseFilter.connect(noiseGain);\n  noiseGain.connect(masterGain);\n  noise.start(now);\n  noise.stop(now + duration);\n\n  // Impact tone\n  const osc = ctx.createOscillator();\n  osc.type = 'square';\n  osc.frequency.setValueAtTime(200 + intensity * 80, now);\n  osc.frequency.exponentialRampToValueAtTime(80, now + duration);\n  const oscGain = ctx.createGain();\n  oscGain.gain.setValueAtTime(vol * 0.3, now);\n  oscGain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  osc.connect(oscGain);\n  oscGain.connect(masterGain);\n  osc.start(now);\n  osc.stop(now + duration);\n}\n\n// Death: descending tone + noise fade\nexport function playDeath(): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const duration = 0.2;\n\n  const osc = ctx.createOscillator();\n  osc.type = 'sawtooth';\n  osc.frequency.setValueAtTime(400, now);\n  osc.frequency.exponentialRampToValueAtTime(60, now + duration);\n  const gain = ctx.createGain();\n  gain.gain.setValueAtTime(AUDIO_CONFIG.deathVolume * 0.4, now);\n  gain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  osc.connect(gain);\n  gain.connect(masterGain);\n  osc.start(now);\n  osc.stop(now + duration);\n\n  // Noise component\n  const noise = ctx.createBufferSource();\n  noise.buffer = createNoiseBuffer(duration * 0.7);\n  const nGain = ctx.createGain();\n  nGain.gain.setValueAtTime(AUDIO_CONFIG.deathVolume * 0.2, now);\n  nGain.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.7);\n  noise.connect(nGain);\n  nGain.connect(masterGain);\n  noise.start(now);\n  noise.stop(now + duration);\n}\n\n// Dash: whoosh \u2014 bandpass-filtered noise sweep\nexport function playDash(): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const duration = 0.15;\n\n  const noise = ctx.createBufferSource();\n  noise.buffer = createNoiseBuffer(duration);\n  const filter = ctx.createBiquadFilter();\n  filter.type = 'bandpass';\n  filter.frequency.setValueAtTime(800, now);\n  filter.frequency.exponentialRampToValueAtTime(3000, now + duration * 0.3);\n  filter.frequency.exponentialRampToValueAtTime(400, now + duration);\n  filter.Q.value = 2;\n  const gain = ctx.createGain();\n  gain.gain.setValueAtTime(AUDIO_CONFIG.dashVolume, now);\n  gain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  noise.connect(filter);\n  filter.connect(gain);\n  gain.connect(masterGain);\n  noise.start(now);\n  noise.stop(now + duration);\n}\n\n// Shield break: metallic crash \u2014 resonant noise + ring\nexport function playShieldBreak(): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const duration = 0.3;\n\n  // Crash noise\n  const noise = ctx.createBufferSource();\n  noise.buffer = createNoiseBuffer(duration);\n  const filter = ctx.createBiquadFilter();\n  filter.type = 'bandpass';\n  filter.frequency.value = 1200;\n  filter.Q.value = 8;\n  const nGain = ctx.createGain();\n  nGain.gain.setValueAtTime(AUDIO_CONFIG.shieldBreakVolume * 0.5, now);\n  nGain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  noise.connect(filter);\n  filter.connect(nGain);\n  nGain.connect(masterGain);\n  noise.start(now);\n  noise.stop(now + duration);\n\n  // Metallic ring\n  const osc = ctx.createOscillator();\n  osc.type = 'triangle';\n  osc.frequency.value = 880;\n  const oscGain = ctx.createGain();\n  oscGain.gain.setValueAtTime(AUDIO_CONFIG.shieldBreakVolume * 0.3, now);\n  oscGain.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.8);\n  osc.connect(oscGain);\n  oscGain.connect(masterGain);\n  osc.start(now);\n  osc.stop(now + duration);\n}\n\n// Charge fired: impact boom \u2014 low thump + noise\nexport function playChargeFire(chargeT: number): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const duration = 0.15 + chargeT * 0.1;\n\n  // Low thump\n  const osc = ctx.createOscillator();\n  osc.type = 'sine';\n  osc.frequency.setValueAtTime(80 + chargeT * 40, now);\n  osc.frequency.exponentialRampToValueAtTime(30, now + duration);\n  const gain = ctx.createGain();\n  gain.gain.setValueAtTime(AUDIO_CONFIG.chargeVolume * (0.5 + chargeT * 0.5), now);\n  gain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  osc.connect(gain);\n  gain.connect(masterGain);\n  osc.start(now);\n  osc.stop(now + duration);\n\n  // Noise burst\n  const noise = ctx.createBufferSource();\n  noise.buffer = createNoiseBuffer(duration * 0.6);\n  const nGain = ctx.createGain();\n  nGain.gain.setValueAtTime(AUDIO_CONFIG.chargeVolume * 0.3 * chargeT, now);\n  nGain.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.6);\n  noise.connect(nGain);\n  nGain.connect(masterGain);\n  noise.start(now);\n  noise.stop(now + duration);\n}\n\n// Wave clear: ascending 3-note chime\nexport function playWaveClear(): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const notes = [523, 659, 784]; // C5, E5, G5\n  const noteLen = 0.12;\n\n  notes.forEach((freq, i) => {\n    const osc = ctx!.createOscillator();\n    osc.type = 'sine';\n    osc.frequency.value = freq;\n    const gain = ctx!.createGain();\n    const start = now + i * 0.08;\n    gain.gain.setValueAtTime(0, start);\n    gain.gain.linearRampToValueAtTime(AUDIO_CONFIG.waveClearVolume * 0.3, start + 0.01);\n    gain.gain.exponentialRampToValueAtTime(0.001, start + noteLen);\n    osc.connect(gain);\n    gain.connect(masterGain!);\n    osc.start(start);\n    osc.stop(start + noteLen);\n  });\n}\n\n// Player hit: short harsh buzz\nexport function playPlayerHit(): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const duration = 0.08;\n\n  const osc = ctx.createOscillator();\n  osc.type = 'square';\n  osc.frequency.value = 150;\n  const gain = ctx.createGain();\n  gain.gain.setValueAtTime(AUDIO_CONFIG.playerHitVolume * 0.3, now);\n  gain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  osc.connect(gain);\n  gain.connect(masterGain);\n  osc.start(now);\n  osc.stop(now + duration);\n\n  // Noise\n  const noise = ctx.createBufferSource();\n  noise.buffer = createNoiseBuffer(duration);\n  const nGain = ctx.createGain();\n  nGain.gain.setValueAtTime(AUDIO_CONFIG.playerHitVolume * 0.4, now);\n  nGain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  noise.connect(nGain);\n  nGain.connect(masterGain);\n  noise.start(now);\n  noise.stop(now + duration);\n}\n\n// Melee swing: short ascending whoosh\nexport function playMeleeSwing(): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const duration = 0.12;\n\n  const noise = ctx.createBufferSource();\n  noise.buffer = createNoiseBuffer(duration);\n  const filter = ctx.createBiquadFilter();\n  filter.type = 'highpass';\n  filter.frequency.setValueAtTime(1500, now);\n  filter.frequency.exponentialRampToValueAtTime(5000, now + duration);\n  const gain = ctx.createGain();\n  gain.gain.setValueAtTime(AUDIO_CONFIG.meleeSwingVolume, now);\n  gain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  noise.connect(filter);\n  filter.connect(gain);\n  gain.connect(masterGain);\n  noise.start(now);\n  noise.stop(now + duration);\n}\n\n// Melee hit: punchy thump + bright noise\nexport function playMeleeHit(): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const duration = 0.08;\n\n  // Low thump\n  const osc = ctx.createOscillator();\n  osc.type = 'sine';\n  osc.frequency.setValueAtTime(120, now);\n  osc.frequency.exponentialRampToValueAtTime(50, now + duration);\n  const oscGain = ctx.createGain();\n  oscGain.gain.setValueAtTime(AUDIO_CONFIG.meleeHitVolume * 0.5, now);\n  oscGain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  osc.connect(oscGain);\n  oscGain.connect(masterGain);\n  osc.start(now);\n  osc.stop(now + duration);\n\n  // Bright noise snap\n  const noise = ctx.createBufferSource();\n  noise.buffer = createNoiseBuffer(duration * 0.6);\n  const filter = ctx.createBiquadFilter();\n  filter.type = 'bandpass';\n  filter.frequency.value = 3000;\n  filter.Q.value = 3;\n  const nGain = ctx.createGain();\n  nGain.gain.setValueAtTime(AUDIO_CONFIG.meleeHitVolume * 0.4, now);\n  nGain.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.6);\n  noise.connect(filter);\n  filter.connect(nGain);\n  nGain.connect(masterGain);\n  noise.start(now);\n  noise.stop(now + duration);\n}\n\n// Wall slam: heavy impact thud with low rumble\nexport function playWallSlam(intensity: number = 1): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const duration = 0.15;\n  const vol = AUDIO_CONFIG.wallSlamVolume * Math.min(intensity, 2);\n\n  // Deep thud \u2014 lower pitch than melee hit\n  const osc = ctx.createOscillator();\n  osc.type = 'sine';\n  osc.frequency.setValueAtTime(80, now);\n  osc.frequency.exponentialRampToValueAtTime(30, now + duration);\n  const oscGain = ctx.createGain();\n  oscGain.gain.setValueAtTime(vol * 0.6, now);\n  oscGain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  osc.connect(oscGain);\n  oscGain.connect(masterGain);\n  osc.start(now);\n  osc.stop(now + duration);\n\n  // Crunch noise\n  const noise = ctx.createBufferSource();\n  noise.buffer = createNoiseBuffer(duration * 0.5);\n  const filter = ctx.createBiquadFilter();\n  filter.type = 'lowpass';\n  filter.frequency.value = 2000;\n  filter.Q.value = 2;\n  const nGain = ctx.createGain();\n  nGain.gain.setValueAtTime(vol * 0.4, now);\n  nGain.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.5);\n  noise.connect(filter);\n  filter.connect(nGain);\n  nGain.connect(masterGain);\n  noise.start(now);\n  noise.stop(now + duration);\n}\n\n// Enemy impact: mid-pitched collision thud \u2014 distinct from wall slam\nexport function playEnemyImpact(intensity: number = 1): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const duration = 0.1;\n  const vol = AUDIO_CONFIG.enemyImpactVolume * Math.min(intensity, 2);\n\n  // Mid-pitched thump (higher than wall slam, lower than melee hit)\n  const osc = ctx.createOscillator();\n  osc.type = 'sine';\n  osc.frequency.setValueAtTime(150, now);\n  osc.frequency.exponentialRampToValueAtTime(60, now + duration);\n  const oscGain = ctx.createGain();\n  oscGain.gain.setValueAtTime(vol * 0.5, now);\n  oscGain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  osc.connect(oscGain);\n  oscGain.connect(masterGain);\n  osc.start(now);\n  osc.stop(now + duration);\n\n  // Short noise pop\n  const noise = ctx.createBufferSource();\n  noise.buffer = createNoiseBuffer(duration * 0.4);\n  const filter = ctx.createBiquadFilter();\n  filter.type = 'bandpass';\n  filter.frequency.value = 1500;\n  filter.Q.value = 3;\n  const nGain = ctx.createGain();\n  nGain.gain.setValueAtTime(vol * 0.3, now);\n  nGain.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.4);\n  noise.connect(filter);\n  filter.connect(nGain);\n  nGain.connect(masterGain);\n  noise.start(now);\n  noise.stop(now + duration);\n}\n\n// Door unlock: ascending 4-note arpeggio (more dramatic than wave clear)\nexport function playDoorUnlock(): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const notes = [392, 523, 659, 784]; // G4, C5, E5, G5\n  const noteLen = 0.18;\n\n  notes.forEach((freq, i) => {\n    const osc = ctx!.createOscillator();\n    osc.type = 'sine';\n    osc.frequency.value = freq;\n    const gain = ctx!.createGain();\n    const start = now + i * 0.1;\n    gain.gain.setValueAtTime(0, start);\n    gain.gain.linearRampToValueAtTime(AUDIO_CONFIG.waveClearVolume * 0.35, start + 0.01);\n    gain.gain.exponentialRampToValueAtTime(0.001, start + noteLen);\n    osc.connect(gain);\n    gain.connect(masterGain!);\n    osc.start(start);\n    osc.stop(start + noteLen);\n  });\n}\n\n// Player healed: warm ascending tone\nexport function playHeal(): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const osc = ctx.createOscillator();\n  osc.type = 'sine';\n  osc.frequency.setValueAtTime(330, now);\n  osc.frequency.linearRampToValueAtTime(660, now + 0.4);\n  const gain = ctx.createGain();\n  gain.gain.setValueAtTime(0, now);\n  gain.gain.linearRampToValueAtTime(0.2, now + 0.05);\n  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);\n  osc.connect(gain);\n  gain.connect(masterGain);\n  osc.start(now);\n  osc.stop(now + 0.5);\n}\n\n// \u2500\u2500\u2500 Vertical Combat Sounds \u2500\u2500\u2500\n\n// Jump: short ascending whoosh\nexport function playJump(): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const duration = 0.1;\n\n  const noise = ctx.createBufferSource();\n  noise.buffer = createNoiseBuffer(duration);\n  const filter = ctx.createBiquadFilter();\n  filter.type = 'bandpass';\n  filter.frequency.setValueAtTime(600, now);\n  filter.frequency.exponentialRampToValueAtTime(2500, now + duration);\n  filter.Q.value = 2;\n  const gain = ctx.createGain();\n  gain.gain.setValueAtTime(AUDIO_CONFIG.jumpVolume, now);\n  gain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  noise.connect(filter);\n  filter.connect(gain);\n  gain.connect(masterGain);\n  noise.start(now);\n  noise.stop(now + duration);\n}\n\n// Land: low thump proportional to fall speed\nexport function playLand(fallSpeed: number): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const intensity = Math.min(fallSpeed / 15, 1.5);\n  const duration = 0.08 + intensity * 0.04;\n\n  const osc = ctx.createOscillator();\n  osc.type = 'sine';\n  osc.frequency.setValueAtTime(60 + intensity * 30, now);\n  osc.frequency.exponentialRampToValueAtTime(25, now + duration);\n  const gain = ctx.createGain();\n  gain.gain.setValueAtTime(AUDIO_CONFIG.landVolume * intensity, now);\n  gain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  osc.connect(gain);\n  gain.connect(masterGain);\n  osc.start(now);\n  osc.stop(now + duration);\n}\n\n// Launch: upward punch \u2014 ascending tone + pop\nexport function playLaunch(): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const duration = 0.15;\n\n  // Rising tone\n  const osc = ctx.createOscillator();\n  osc.type = 'square';\n  osc.frequency.setValueAtTime(120, now);\n  osc.frequency.exponentialRampToValueAtTime(600, now + duration * 0.7);\n  const gain = ctx.createGain();\n  gain.gain.setValueAtTime(AUDIO_CONFIG.launchVolume * 0.3, now);\n  gain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  osc.connect(gain);\n  gain.connect(masterGain);\n  osc.start(now);\n  osc.stop(now + duration);\n\n  // Pop noise\n  const noise = ctx.createBufferSource();\n  noise.buffer = createNoiseBuffer(duration * 0.5);\n  const filter = ctx.createBiquadFilter();\n  filter.type = 'highpass';\n  filter.frequency.value = 2000;\n  const nGain = ctx.createGain();\n  nGain.gain.setValueAtTime(AUDIO_CONFIG.launchVolume * 0.4, now);\n  nGain.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.5);\n  noise.connect(filter);\n  filter.connect(nGain);\n  nGain.connect(masterGain);\n  noise.start(now);\n  noise.stop(now + duration);\n}\n\n// Aerial strike: sharp descending crack\nexport function playAerialStrike(): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const duration = 0.1;\n\n  const osc = ctx.createOscillator();\n  osc.type = 'sawtooth';\n  osc.frequency.setValueAtTime(500, now);\n  osc.frequency.exponentialRampToValueAtTime(100, now + duration);\n  const gain = ctx.createGain();\n  gain.gain.setValueAtTime(AUDIO_CONFIG.aerialStrikeVolume * 0.4, now);\n  gain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  osc.connect(gain);\n  gain.connect(masterGain);\n  osc.start(now);\n  osc.stop(now + duration);\n\n  // Bright snap\n  const noise = ctx.createBufferSource();\n  noise.buffer = createNoiseBuffer(duration * 0.6);\n  const filter = ctx.createBiquadFilter();\n  filter.type = 'bandpass';\n  filter.frequency.value = 4000;\n  filter.Q.value = 4;\n  const nGain = ctx.createGain();\n  nGain.gain.setValueAtTime(AUDIO_CONFIG.aerialStrikeVolume * 0.5, now);\n  nGain.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.6);\n  noise.connect(filter);\n  filter.connect(nGain);\n  nGain.connect(masterGain);\n  noise.start(now);\n  noise.stop(now + duration);\n}\n\n// Slam: heavy ground pound \u2014 deep boom + noise\nexport function playSlam(fallSpeed: number): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const intensity = Math.min(fallSpeed / 20, 1.5);\n  const duration = 0.2 + intensity * 0.05;\n\n  // Deep boom\n  const osc = ctx.createOscillator();\n  osc.type = 'sine';\n  osc.frequency.setValueAtTime(50 + intensity * 20, now);\n  osc.frequency.exponentialRampToValueAtTime(20, now + duration);\n  const gain = ctx.createGain();\n  gain.gain.setValueAtTime(AUDIO_CONFIG.slamVolume * (0.4 + intensity * 0.3), now);\n  gain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  osc.connect(gain);\n  gain.connect(masterGain);\n  osc.start(now);\n  osc.stop(now + duration);\n\n  // Debris noise\n  const noise = ctx.createBufferSource();\n  noise.buffer = createNoiseBuffer(duration * 0.7);\n  const filter = ctx.createBiquadFilter();\n  filter.type = 'lowpass';\n  filter.frequency.value = 1500;\n  filter.Q.value = 2;\n  const nGain = ctx.createGain();\n  nGain.gain.setValueAtTime(AUDIO_CONFIG.slamVolume * 0.4, now);\n  nGain.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.7);\n  noise.connect(filter);\n  filter.connect(nGain);\n  nGain.connect(masterGain);\n  noise.start(now);\n  noise.stop(now + duration);\n}\n\n// Dunk grab: metallic catch sound\nexport function playDunkGrab(): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const duration = 0.1;\n\n  // High metallic ping\n  const osc = ctx.createOscillator();\n  osc.type = 'triangle';\n  osc.frequency.value = 1200;\n  const gain = ctx.createGain();\n  gain.gain.setValueAtTime(AUDIO_CONFIG.dunkGrabVolume * 0.4, now);\n  gain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  osc.connect(gain);\n  gain.connect(masterGain);\n  osc.start(now);\n  osc.stop(now + duration);\n}\n\n// Dunk impact: massive boom \u2014 bigger than slam\nexport function playDunkImpact(): void {\n  if (!ctx || !masterGain || !AUDIO_CONFIG.enabled) return;\n  const now = ctx.currentTime;\n  const duration = 0.25;\n\n  // Ultra-low boom\n  const osc = ctx.createOscillator();\n  osc.type = 'sine';\n  osc.frequency.setValueAtTime(40, now);\n  osc.frequency.exponentialRampToValueAtTime(15, now + duration);\n  const gain = ctx.createGain();\n  gain.gain.setValueAtTime(AUDIO_CONFIG.dunkImpactVolume * 0.6, now);\n  gain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  osc.connect(gain);\n  gain.connect(masterGain);\n  osc.start(now);\n  osc.stop(now + duration);\n\n  // Heavy crunch\n  const noise = ctx.createBufferSource();\n  noise.buffer = createNoiseBuffer(duration * 0.6);\n  const filter = ctx.createBiquadFilter();\n  filter.type = 'lowpass';\n  filter.frequency.value = 2000;\n  filter.Q.value = 3;\n  const nGain = ctx.createGain();\n  nGain.gain.setValueAtTime(AUDIO_CONFIG.dunkImpactVolume * 0.5, now);\n  nGain.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.6);\n  noise.connect(filter);\n  filter.connect(nGain);\n  nGain.connect(masterGain);\n  noise.start(now);\n  noise.stop(now + duration);\n\n  // Sub-bass rumble\n  const sub = ctx.createOscillator();\n  sub.type = 'sine';\n  sub.frequency.value = 25;\n  const subGain = ctx.createGain();\n  subGain.gain.setValueAtTime(AUDIO_CONFIG.dunkImpactVolume * 0.3, now);\n  subGain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n  sub.connect(subGain);\n  subGain.connect(masterGain);\n  sub.start(now);\n  sub.stop(now + duration);\n}\n\n// \u2500\u2500\u2500 Event Bus Integration \u2500\u2500\u2500\n\nfunction wireEventBus(): void {\n  on('enemyHit', (e: GameEvent) => {\n    if (e.type === 'enemyHit') playHit(e.damage / 15); // normalize around 15 dmg\n  });\n\n  on('enemyDied', () => playDeath());\n\n  on('playerHit', () => playPlayerHit());\n\n  on('playerDash', () => playDash());\n\n  on('shieldBreak', () => playShieldBreak());\n\n  on('chargeFired', (e: GameEvent) => {\n    if (e.type === 'chargeFired') playChargeFire(e.chargeT);\n  });\n\n  on('waveCleared', () => playWaveClear());\n\n  on('roomCleared', () => playWaveClear());\n\n  on('roomClearComplete', () => playDoorUnlock());\n\n  on('playerHealed', () => playHeal());\n\n  on('meleeSwing', () => playMeleeSwing());\n\n  on('meleeHit', () => playMeleeHit());\n\n  on('wallSlam', (e: GameEvent) => {\n    if (e.type === 'wallSlam') playWallSlam(e.speed / 5); // normalize around speed 5\n  });\n\n  on('enemyImpact', (e: GameEvent) => {\n    if (e.type === 'enemyImpact') playEnemyImpact(e.speed / 5);\n  });\n\n  // \u2500\u2500\u2500 Vertical Combat Events \u2500\u2500\u2500\n\n  on('playerJump', () => playJump());\n\n  on('playerLand', (e: GameEvent) => {\n    if (e.type === 'playerLand') playLand(e.fallSpeed);\n  });\n\n  on('enemyLaunched', () => playLaunch());\n\n  on('aerialStrike', () => playAerialStrike());\n\n  on('playerSlam', (e: GameEvent) => {\n    if (e.type === 'playerSlam') playSlam(e.fallSpeed);\n  });\n\n  on('dunkGrab', () => playDunkGrab());\n\n  on('dunkImpact', () => playDunkImpact());\n}\n", "import { BossConfig } from '../types/index';\n\nexport const BOSS: BossConfig = {\n  name: 'The Warden',\n  health: 300,\n  speed: 2.0,\n  damage: 30,\n  size: { radius: 0.8, height: 2.0 },\n  color: 0xff8800,\n  emissive: 0xff4400,\n  phases: [\n    { healthThreshold: 1.0, behavior: 'chase', attackRate: 1000 },\n    { healthThreshold: 0.5, behavior: 'enrage', attackRate: 600, speed: 3.0, spawnMinions: { type: 'goblin', count: 3 } },\n  ]\n};\n", "// URL query parameter overrides \u2014 apply gameplay config from URL\n// Format: ?player.speed=10&goblin.health=50&dash.cooldown=500\n//\n// First segment = config root, rest = nested dot-path within that object.\n// Values are auto-parsed as number, boolean, hex (0x...), or string.\n\nimport { PLAYER } from '../config/player';\nimport { ENEMY_TYPES } from '../config/enemies';\nimport { ABILITIES } from '../config/abilities';\nimport { BOSS } from '../config/boss';\n\n// Registry: first segment of param key \u2192 config object\nconst CONFIG_ROOTS: Record<string, any> = {\n  player:          PLAYER,\n  goblin:          ENEMY_TYPES.goblin,\n  skeletonArcher:  ENEMY_TYPES.skeletonArcher,\n  iceMortarImp:    ENEMY_TYPES.iceMortarImp,\n  stoneGolem:      ENEMY_TYPES.stoneGolem,\n  dash:            ABILITIES.dash,\n  ultimate:        ABILITIES.ultimate,\n  boss:            BOSS,\n};\n\nfunction getNestedValue(obj: any, path: string) {\n  const parts = path.split('.');\n  let cur = obj;\n  for (const p of parts) {\n    if (cur == null) return undefined;\n    cur = cur[p];\n  }\n  return cur;\n}\n\nfunction setNestedValue(obj: any, path: string, value: any) {\n  const parts = path.split('.');\n  let cur = obj;\n  for (let i = 0; i < parts.length - 1; i++) {\n    if (cur[parts[i]] == null) cur[parts[i]] = {};\n    cur = cur[parts[i]];\n  }\n  cur[parts[parts.length - 1]] = value;\n}\n\nfunction parseValue(raw: string) {\n  if (raw === 'true') return true;\n  if (raw === 'false') return false;\n  if (raw.startsWith('0x') || raw.startsWith('0X')) {\n    const hex = parseInt(raw, 16);\n    if (!isNaN(hex)) return hex;\n  }\n  const num = Number(raw);\n  return isNaN(num) ? raw : num;\n}\n\n/**\n * Parse URL search params and apply overrides to config objects.\n * Returns the count of params applied.\n */\nexport function applyUrlParams() {\n  const params = new URLSearchParams(window.location.search);\n  let applied = 0;\n\n  for (const [key, rawValue] of params) {\n    const dotIdx = key.indexOf('.');\n    if (dotIdx === -1) continue; // no prefix, skip\n\n    const prefix = key.slice(0, dotIdx);\n    const path = key.slice(dotIdx + 1);\n    if (!path) continue;\n\n    const root = CONFIG_ROOTS[prefix];\n    if (!root) {\n      console.warn(`[urlParams] Unknown prefix: \"${prefix}\" (from \"${key}\")`);\n      continue;\n    }\n\n    // Validate property exists (prevent typos from creating junk keys)\n    const existing = getNestedValue(root, path);\n    if (existing === undefined) {\n      console.warn(`[urlParams] Unknown path: \"${key}\" \u2014 no such property`);\n      continue;\n    }\n\n    const value = parseValue(rawValue);\n    setNestedValue(root, path, value);\n    applied++;\n    console.log(`[urlParams] ${key} = ${value}`);\n  }\n\n  if (applied > 0) {\n    console.log(`[urlParams] Applied ${applied} override(s) from URL`);\n  }\n  return applied;\n}\n\n/**\n * Snapshot current config values (call BEFORE applyUrlParams to capture defaults).\n */\nexport function snapshotDefaults() {\n  const snap: Record<string, any> = {};\n  for (const [prefix, root] of Object.entries(CONFIG_ROOTS)) {\n    snap[prefix] = JSON.parse(JSON.stringify(root));\n  }\n  return snap;\n}\n\n/**\n * Build a share URL containing only parameters that differ from defaults.\n */\nexport function buildShareUrl(defaults: Record<string, any>) {\n  const params = new URLSearchParams();\n\n  for (const [prefix, root] of Object.entries(CONFIG_ROOTS)) {\n    const defRoot = defaults[prefix];\n    if (!defRoot) continue;\n    collectDiffs(params, prefix, defRoot, root, '');\n  }\n\n  const base = window.location.origin + window.location.pathname;\n  const qs = params.toString();\n  return qs ? base + '?' + qs : base;\n}\n\nfunction collectDiffs(params: URLSearchParams, prefix: string, defObj: any, curObj: any, pathPrefix: string) {\n  for (const key of Object.keys(curObj)) {\n    const fullPath = pathPrefix ? pathPrefix + '.' + key : key;\n    const curVal = curObj[key];\n    const defVal = getNestedValue(defObj, fullPath);\n\n    if (curVal != null && typeof curVal === 'object' && !Array.isArray(curVal)) {\n      collectDiffs(params, prefix, defObj, curVal, fullPath);\n    } else if (curVal !== defVal) {\n      params.set(prefix + '.' + fullPath, String(curVal));\n    }\n  }\n}\n", "import { initRenderer, updateCamera, getScene, getRendererInstance, getCamera } from './renderer';\nimport { initInput, updateInput, consumeInput, getInputState, autoAimClosestEnemy, consumeCancel, setUltimateHeld } from './input';\nimport { createPlayer, updatePlayer, getPlayerPos, resetPlayer } from '../entities/player';\nimport { initProjectilePool, updateProjectiles } from '../entities/projectile';\nimport { initEnemySystem, updateEnemies } from '../entities/enemy';\nimport { initMortarSystem, updateMortarProjectiles, updateIcePatches } from '../entities/mortarProjectile';\nimport { initRoomManager, loadRoom, updateRoomManager, resetRoomManager } from './roomManager';\nimport { checkCollisions, checkPitFalls, updateEffectGhosts, applyVelocities, resolveEnemyCollisions, applyObjectVelocities, resolveObjectCollisions, resolvePhysicsObjectBodyCollisions } from './physics';\nimport { initAoeTelegraph, updateAoeTelegraphs, updatePendingEffects } from './aoeTelegraph';\nimport { initHUD, updateHUD } from '../ui/hud';\nimport { initScreens, showGameOver, hideScreens } from '../ui/screens';\nimport { initDamageNumbers, updateDamageNumbers } from '../ui/damageNumbers';\nimport { initAudio, resumeAudio } from './audio';\nimport { initParticles, updateParticles } from './particles';\nimport { initBulletTime, toggleBulletTime, updateBulletTime, getBulletTimeScale, resetBulletTime } from './bulletTime';\nimport { initBendMode, toggleBendMode, isBendModeActive, isBendTargeting, handleBendClick, enterTargeting, resetBendMode, updateBendMode, updateBendHover } from './bendMode';\nimport { initRadialMenu, setOnBendSelected } from '../ui/radialMenu';\nimport { getActiveProfile } from './profileManager';\nimport { initAerialVerbs, updateAerialVerbs, resetAerialVerbs, cancelActiveVerb } from './aerialVerbs';\nimport { clearAllTags } from './tags';\nimport { dunkVerb } from '../verbs/dunk';\nimport { floatSelectorVerb } from '../verbs/floatSelector';\nimport { spikeVerb } from '../verbs/spike';\nimport { updateCarriers, clearCarriers } from './entityCarrier';\nimport { initGroundShadows, updateGroundShadows } from './groundShadows';\nimport { initVisionCones } from './visionCone';\nimport { initLaunchPillars, updateLaunchPillars, clearLaunchPillars } from '../effects/launchPillar';\nimport { initLaunchIndicator, clearLaunchIndicator } from '../effects/launchIndicator';\nimport { raycastTerrainDist } from '../entities/enemy';\nimport { PLAYER, MELEE, DUNK } from '../config/player';\nimport { on } from './events';\nimport { updatePressurePlates } from './pressurePlate';\nimport { updateTetherVisuals } from '../entities/physicsObject';\nimport { applyUrlParams, snapshotDefaults } from './urlParams';\nimport { GameState } from '../types/index';\n\nconst gameState: GameState = {\n  phase: 'waiting',\n  playerHealth: PLAYER.maxHealth,\n  playerMaxHealth: PLAYER.maxHealth,\n  currency: 0,\n  currentWave: 1,\n  enemies: [],\n  physicsObjects: [],\n  bendMode: false,\n  bendsPerRoom: 3,\n  pressurePlates: [],\n  abilities: {\n    dash:     { cooldownRemaining: 0 },\n    ultimate: { cooldownRemaining: 0, active: false, activeRemaining: 0, charging: false, chargeT: 0 }\n  }\n};\n\nlet lastTime = 0;\nlet hitPauseTimer = 0; // ms remaining \u2014 freeze frame on melee hit\n\nfunction gameLoop(timestamp: number): void {\n  requestAnimationFrame(gameLoop);\n\n  if (gameState.phase === 'waiting') {\n    getRendererInstance().render(getScene(), getCamera());\n    return;\n  }\n\n  if (gameState.phase === 'intro') {\n    getRendererInstance().render(getScene(), getCamera());\n    return;\n  }\n\n  if (gameState.phase === 'gameOver') {\n    getRendererInstance().render(getScene(), getCamera());\n    return;\n  }\n\n  let dt = (timestamp - lastTime) / 1000;\n  lastTime = timestamp;\n  dt = Math.min(dt, 0.05);\n\n  if (dt <= 0) return;\n\n  // Hit pause (freeze frame on melee hit)\n  if (hitPauseTimer > 0) {\n    hitPauseTimer -= dt * 1000;\n    getRendererInstance().render(getScene(), getCamera());\n    return;\n  }\n\n  // 1. Input\n  updateInput();\n\n  // 1a. Cancel \u2014 release aerial verb + force push charge\n  if (consumeCancel()) {\n    cancelActiveVerb();\n    setUltimateHeld(false);\n  }\n\n  autoAimClosestEnemy(gameState.enemies);\n  const input = getInputState();\n\n  // 1b. Bend Mode / Bullet Time toggle (profile-gated)\n  if (getActiveProfile() === 'rule-bending') {\n    if (input.bendMode) toggleBendMode();\n  } else {\n    if (input.bulletTime) toggleBulletTime();\n  }\n  updateBulletTime(dt);\n  const gameDt = dt * getBulletTimeScale(); // slowed dt for world systems\n\n  // 1c. Bend targeting click\n  if (isBendModeActive() && isBendTargeting() && input.attack) {\n    handleBendClick(input.mouseNDC, gameState);\n  }\n\n  // 1d. Bend mode update (highlights + hover)\n  updateBendMode(dt, gameState);\n  if (isBendModeActive() && isBendTargeting()) {\n    updateBendHover(input.mouseNDC, gameState);\n  }\n\n  // 2. Player (uses real dt \u2014 player moves at normal speed)\n  // Gate combat input when bend mode is active\n  if (isBendModeActive()) {\n    const gatedInput = { ...input, attack: false, dash: false, ultimate: false, ultimateHeld: false };\n    updatePlayer(gatedInput, dt, gameState);\n  } else {\n    updatePlayer(input, dt, gameState);\n  }\n\n  // 2b. Aerial verbs (dunk, spike, etc.) \u2014 uses gameDt so bullet time slows\n  (input as any)._gameState = gameState;\n  updateAerialVerbs(gameDt, getPlayerPos(), input);\n\n  // 2c. Entity carriers (spiked enemies as projectiles) \u2014 real dt like player\n  updateCarriers(dt, gameState);\n\n  // 2d. Launch pillars (visual only, real dt)\n  updateLaunchPillars(dt);\n\n  // 3. Projectiles (slowed)\n  updateProjectiles(gameDt);\n\n  // 4. Room Manager (slowed)\n  updateRoomManager(gameDt, gameState);\n\n  // 5. Enemies (slowed)\n  updateEnemies(gameDt, getPlayerPos(), gameState);\n\n  // 6. Collisions\n  checkCollisions(gameState);\n\n  // 6a. Physics velocities \u2014 knockback sliding, wall slam detection (slowed)\n  applyVelocities(gameDt, gameState);\n\n  // 6a2. Enemy-enemy collision (separation + momentum transfer)\n  resolveEnemyCollisions(gameState);\n\n  // 6a1. Physics object velocities (no-ops when physicsObjects array is empty)\n  applyObjectVelocities(gameDt, gameState);\n\n  // 6a3. Object-object + object-enemy collision\n  resolveObjectCollisions(gameState);\n\n  // 6a3b. Physics objects as solid bodies\n  resolvePhysicsObjectBodyCollisions(gameState);\n\n  // 6a4. Pressure plates (check if heavy object resting on plate)\n  updatePressurePlates(gameState);\n\n  // 6a5. Tether visuals (pulse opacity on suspended physics objects)\n  updateTetherVisuals(gameState);\n\n  // 6b. Pit falls\n  checkPitFalls(gameState);\n\n  // 6c. Effect ghosts (slowed)\n  updateEffectGhosts(gameDt);\n\n  // 6d. Particles (slowed)\n  updateParticles(gameDt);\n\n  // 7. AoE telegraphs (slowed)\n  updateAoeTelegraphs(gameDt);\n  updatePendingEffects(gameDt);\n\n  // 8. Mortar projectiles (slowed)\n  updateMortarProjectiles(gameDt);\n\n  // 8b. Ice patches (slowed)\n  updateIcePatches(gameDt);\n\n  // 9. Clamp health \u2014 demo mode, player can't die\n  if (gameState.playerHealth < 1) {\n    gameState.playerHealth = 1;\n    gameState.phase = 'playing';\n  }\n\n  // 10. Camera (real dt \u2014 smooth camera)\n  updateCamera(getPlayerPos(), dt);\n\n  // 10b. Ground shadows (track entity positions)\n  updateGroundShadows(gameState);\n\n  // 11. HUD\n  updateHUD(gameState);\n\n  // 12. Consume edge-triggered inputs\n  consumeInput();\n\n  // 14. Render\n  getRendererInstance().render(getScene(), getCamera());\n\n  // 15. Damage numbers (slowed)\n  updateDamageNumbers(gameDt);\n}\n\nfunction restart(): void {\n  gameState.phase = 'playing';\n  gameState.playerHealth = PLAYER.maxHealth;\n  gameState.playerMaxHealth = PLAYER.maxHealth;\n  gameState.currency = 0;\n  gameState.currentWave = 1;\n  gameState.abilities.dash.cooldownRemaining = 0;\n  gameState.abilities.ultimate.cooldownRemaining = 0;\n  gameState.abilities.ultimate.active = false;\n  gameState.abilities.ultimate.activeRemaining = 0;\n  gameState.abilities.ultimate.charging = false;\n  gameState.abilities.ultimate.chargeT = 0;\n\n  resetPlayer();\n  resetAerialVerbs();\n  clearCarriers();\n  clearLaunchPillars();\n  clearLaunchIndicator();\n  clearAllTags();\n  resetRoomManager();\n  resetBulletTime();\n  loadRoom(0, gameState);\n}\n\nfunction init(): void {\n  try {\n    (window as any).__configDefaults = snapshotDefaults();\n    applyUrlParams();\n\n    const { scene } = initRenderer();\n\n    initInput();\n    createPlayer(scene);\n    initProjectilePool(scene);\n    initEnemySystem(scene);\n    initMortarSystem(scene);\n    initAoeTelegraph(scene);\n    initRoomManager(scene);\n    initAudio();\n    initParticles(scene);\n    initBulletTime();\n    initRadialMenu();\n    setOnBendSelected((_bendId: string) => { enterTargeting(); });\n    initBendMode();\n    initVisionCones(scene, raycastTerrainDist);\n    initAerialVerbs([floatSelectorVerb, dunkVerb, spikeVerb]);\n    initLaunchPillars(scene);\n    initLaunchIndicator(scene);\n    initGroundShadows();\n\n    // Hit pause \u2014 subscribe to impact events\n    on('meleeHit', () => {\n      hitPauseTimer = MELEE.hitPause;\n    });\n    on('dunkGrab', () => {\n      hitPauseTimer = DUNK.grabPause;\n    });\n    initHUD();\n    initDamageNumbers();\n    initScreens(restart, () => {\n      resumeAudio(); // AudioContext requires user gesture to start\n      document.getElementById('hud')!.style.visibility = 'visible';\n      loadRoom(0, gameState);\n      lastTime = performance.now();\n    }, (roomIndex: number) => {\n      resumeAudio();\n      document.getElementById('hud')!.style.visibility = 'visible';\n      loadRoom(roomIndex, gameState);\n      lastTime = performance.now();\n    });\n\n    document.getElementById('hud')!.style.visibility = 'hidden';\n\n    lastTime = performance.now();\n    requestAnimationFrame(gameLoop);\n  } catch (err) {\n    console.error('[init] Fatal error during initialization:', err);\n  }\n}\n\ninit();\n\n// DEBUG: Expose game state for verification scripts (localhost only)\nif (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {\n  (window as any).gameState = gameState;\n  (window as any).getPlayerPos = getPlayerPos;\n}\n"],
  "mappings": "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",
  "names": ["playerPos", "camera", "scene", "gameState", "sceneRef", "scene", "pool", "active", "sceneRef", "scene", "target", "sceneRef", "scene", "gameState", "target", "playerPos", "gameState", "sceneRef", "ringMat", "ringMesh", "gameState", "sceneRef", "sceneRef", "scene", "easeOutQuad", "inputState", "isDashing", "isSlamming", "isCharging", "phase", "easeOutQuad", "playerPos", "inputState", "scene", "fillGeo", "ringGeo", "ringMat", "playerPos", "inputState", "phase", "target", "floatTimer", "landingX", "landingZ", "playerVelYOverride", "decalGroup", "decalFill", "decalRing", "decalAge", "DECAL_EXPAND_MS", "createDecal", "scene", "fillGeo", "ringGeo", "ringMat", "updateDecal", "aimX", "aimZ", "removeDecal", "updateTargeting", "playerPos", "inputState", "playerVelYOverride", "phase", "target", "floatTimer", "playerVelYOverride", "landingX", "landingZ", "removeDecal", "gameState", "phase", "target", "playerVelYOverride", "playerPos", "inputState", "playerVelYOverride", "phase", "target", "sceneRef", "scene", "easeOutQuad", "sceneRef", "ringGeo", "scene", "playerPos", "target", "scene", "inputState", "gameState", "fillGeo", "scene", "scene", "gameState", "_ghostHeadGeo", "scene", "gameState", "playerPos", "resolved", "POOL_SIZE", "pool", "sceneRef", "scene", "sceneRef", "ringGeo", "scene", "sceneRef", "ringGeo", "ringMat", "removeTelegraph", "scene", "target", "pillarGeo", "rafId", "sceneRef", "scene", "playerPos", "scene", "gameState", "maxBends", "target", "nameEl", "active", "gameState", "camera", "target", "announceEl", "active", "scene", "ringGeo", "ringMat", "gameState", "activeTelegraphs", "sceneRef", "scene", "gameState", "playerPos", "removeTelegraph", "pack", "activeTelegraphs", "INV_SQRT2", "ISO_RIGHT_X", "ISO_RIGHT_Z", "ISO_UP_X", "ISO_UP_Z", "gameState", "nameEl", "ctx", "initialized", "wireEventBus", "ctx", "wireEventBus", "scene"]
}
